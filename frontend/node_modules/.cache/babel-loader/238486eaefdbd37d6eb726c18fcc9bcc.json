{"ast":null,"code":"/**\r\n * Callback for setting the board state\r\n *\r\n * @callback setBoardState\r\n * @param {Object} board An dictionary representing the current board state\r\n */\nimport { support } from \"jquery\";\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {setBoardState} setBoardState sets a new state of the board\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\n\nexport function movePiece(toX, toY, setBoardState, setTakenPieces, item, boardState) {\n  const square = squareIsEmpty(toX, toY, boardState);\n\n  if (square != null) {\n    if (!square.isOwner) {\n      boardState[square.piece].isAlive = false;\n      const pieceNameSplit = square.piece.split(\"_\");\n      const piecePathName = pieceNameSplit[0] + \"_\" + pieceNameSplit[1];\n      const pieceImgPath = \"/Images/pieces/\" + piecePathName + \".png\";\n      let colour;\n      if (pieceNameSplit[1] === \"w\") colour = \"white\";else colour = \"black\";\n      setTakenPieces(prevState => ({ ...prevState,\n        [colour]: [...prevState[colour], pieceImgPath].sort()\n      }));\n    }\n  }\n\n  setBoardState(prevState => ({ ...prevState,\n    [item.pieceName]: {\n      row: toY,\n      col: toX,\n      hasMoved: true,\n      isOwner: true,\n      isAlive: true\n    }\n  }));\n}\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} monitor contains data about the currently dragged piece\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\n\nexport function canMovePiece(toX, toY, item, boardState, monitor) {\n  const square = squareIsEmpty(toX, toY, boardState);\n  if (square && square.state.isOwner) return false;\n  var dx = Math.abs(toX - item.pieceState.col);\n  var dy = Math.abs(toY - item.pieceState.row);\n  const pieceName = item.pieceName.split(\"_\")[0];\n  const diagCollisions = checkDiagCollisions(toX, toY, boardState, monitor);\n  const straightCollisions = checkStraightCollisions(toX, toY, boardState, monitor);\n\n  switch (pieceName) {\n    case \"castle\":\n      return (dx === 0 && dy > 0 || dx > 0 && dy === 0) && !straightCollisions;\n\n    case \"knight\":\n      return dx === 2 && dy === 1 || dx === 1 && dy === 2;\n\n    case \"bishop\":\n      return !(dx === 0 && dy > 0) && !(dx > 0 && dy === 0) && (dx === dy || dx === dy) && !diagCollisions;\n\n    case \"queen\":\n      return (dx === 0 && dy > 0 || dx > 0 && dy === 0) && !straightCollisions || (dx === dy || dx === dy) && !diagCollisions;\n\n    case \"king\":\n      return (dx === 1 || dx === 0) && (dy === 1 || dy === 0);\n\n    case \"pawn\":\n      // Recalculate dx/dy with direction\n      dx = toX - item.pieceState.col;\n      dy = toY - item.pieceState.row; // Allow pawn to move 2 squares on first move\n\n      if (!item.pieceState.hasMoved) {\n        // Negative direction moves up the board (player always at bottom)\n        if (dx === 0 && (dy === -1 || dy === -2) && !straightCollisions) {\n          return square === null;\n        }\n      } // Allow pawn to take opponents pieces diagonal by 1 square\n\n\n      if ((dx === 1 || dx === -1) && dy === -1 && square !== null) return true; // Allow pawn to move forward by 1 square\n\n      return dx === 0 && dy === -1 && square === null;\n\n    default:\n      return false;\n  }\n}\n/**\r\n * Checks if the current square is empty\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @returns piece name and state if square is not empty, null otherwise\r\n */\n\nfunction squareIsEmpty(x, y, boardState) {\n  for (const [piece, state] of Object.entries(boardState)) {\n    if (x === state.col && y === state.row) {\n      return {\n        piece,\n        state\n      };\n    }\n  }\n\n  return null;\n}\n/**\r\n * Checks if there is a piece in the diagonal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} monitor contains data about the currently dragged piece\r\n * @returns true if an opponents piece is inbetween the square and the currently dragged piece, false otherwise\r\n */\n\n\nfunction checkDiagCollisions(x, y, boardState, monitor) {\n  const row = monitor.getItem().pieceState.row;\n  const col = monitor.getItem().pieceState.col;\n  const dirX = Math.sign(x - col);\n  const dirY = Math.sign(y - row);\n\n  for (let i = 1; i < Math.abs(x - col) + 1; i++) {\n    for (const [_, state] of Object.entries(boardState)) {\n      if (col + i * dirX === state.col && row + i * dirY === state.row && state.isAlive) {\n        if (i !== Math.abs(x - col)) {\n          // Stops opponents pieces from being taken when hidden behind each other\n          return true;\n        }\n\n        return state.isOwner;\n      }\n    }\n  }\n\n  return false;\n}\n/**\r\n * Checks if there is a piece in the vertical and horizontal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} monitor contains data about the currently dragged piece\r\n * @returns true if an opponents piece is inbetween the square and the currently dragged piece, false otherwise\r\n */\n\n\nfunction checkStraightCollisions(x, y, boardState, monitor) {\n  const row = monitor.getItem().pieceState.row;\n  const col = monitor.getItem().pieceState.col;\n  const dx = Math.abs(x - col);\n  const dy = Math.abs(y - row);\n  if (dx > 0 && dy > 0) return true;\n  const dirX = Math.sign(x - col);\n  const dirY = Math.sign(y - row);\n\n  for (let i = 1; i < Math.max(dx, dy) + 1; i++) {\n    for (const [_, state] of Object.entries(boardState)) {\n      if (state.isAlive) {\n        // Move is horizontal if dy = 0, otherwise vertical\n        if (dy === 0) {\n          if (col + i * dirX === state.col && row === state.row) {\n            if (i !== Math.abs(x - col)) {\n              // Stops opponents pieces from being taken when hidden behind each other\n              return true;\n            }\n\n            return state.isOwner;\n          }\n        } else {\n          if (row + i * dirY === state.row && col === state.col) {\n            if (i !== Math.abs(y - row)) {\n              // Stops opponents pieces from being taken when hidden behind each other\n              return true;\n            }\n\n            return state.isOwner;\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}","map":{"version":3,"names":["support","movePiece","toX","toY","setBoardState","setTakenPieces","item","boardState","square","squareIsEmpty","isOwner","piece","isAlive","pieceNameSplit","split","piecePathName","pieceImgPath","colour","prevState","sort","pieceName","row","col","hasMoved","canMovePiece","monitor","state","dx","Math","abs","pieceState","dy","diagCollisions","checkDiagCollisions","straightCollisions","checkStraightCollisions","x","y","Object","entries","getItem","dirX","sign","dirY","i","_","max"],"sources":["C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/src/components/Game.js"],"sourcesContent":["/**\r\n * Callback for setting the board state\r\n *\r\n * @callback setBoardState\r\n * @param {Object} board An dictionary representing the current board state\r\n */\r\n\r\nimport { support } from \"jquery\";\r\n\r\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {setBoardState} setBoardState sets a new state of the board\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\r\nexport function movePiece(\r\n    toX,\r\n    toY,\r\n    setBoardState,\r\n    setTakenPieces,\r\n    item,\r\n    boardState\r\n) {\r\n    const square = squareIsEmpty(toX, toY, boardState);\r\n    if (square != null) {\r\n        if (!square.isOwner) {\r\n            boardState[square.piece].isAlive = false;\r\n\r\n            const pieceNameSplit = square.piece.split(\"_\");\r\n            const piecePathName = pieceNameSplit[0] + \"_\" + pieceNameSplit[1];\r\n            const pieceImgPath = \"/Images/pieces/\" + piecePathName + \".png\";\r\n            let colour;\r\n            if (pieceNameSplit[1] === \"w\") colour = \"white\";\r\n            else colour = \"black\";\r\n            setTakenPieces((prevState) => ({\r\n                ...prevState,\r\n                [colour]: [...prevState[colour], pieceImgPath].sort(),\r\n            }));\r\n        }\r\n    }\r\n\r\n    setBoardState((prevState) => ({\r\n        ...prevState,\r\n        [item.pieceName]: {\r\n            row: toY,\r\n            col: toX,\r\n            hasMoved: true,\r\n            isOwner: true,\r\n            isAlive: true,\r\n        },\r\n    }));\r\n}\r\n\r\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} monitor contains data about the currently dragged piece\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\r\nexport function canMovePiece(toX, toY, item, boardState, monitor) {\r\n    const square = squareIsEmpty(toX, toY, boardState);\r\n    if (square && square.state.isOwner) return false;\r\n\r\n    var dx = Math.abs(toX - item.pieceState.col);\r\n    var dy = Math.abs(toY - item.pieceState.row);\r\n\r\n    const pieceName = item.pieceName.split(\"_\")[0];\r\n\r\n    const diagCollisions = checkDiagCollisions(toX, toY, boardState, monitor);\r\n    const straightCollisions = checkStraightCollisions(\r\n        toX,\r\n        toY,\r\n        boardState,\r\n        monitor\r\n    );\r\n\r\n    switch (pieceName) {\r\n        case \"castle\":\r\n            return (\r\n                ((dx === 0 && dy > 0) || (dx > 0 && dy === 0)) &&\r\n                !straightCollisions\r\n            );\r\n\r\n        case \"knight\":\r\n            return (dx === 2 && dy === 1) || (dx === 1 && dy === 2);\r\n\r\n        case \"bishop\":\r\n            return (\r\n                !(dx === 0 && dy > 0) &&\r\n                !(dx > 0 && dy === 0) &&\r\n                (dx === dy || dx === dy) &&\r\n                !diagCollisions\r\n            );\r\n\r\n        case \"queen\":\r\n            return (\r\n                (((dx === 0 && dy > 0) || (dx > 0 && dy === 0)) &&\r\n                    !straightCollisions) ||\r\n                ((dx === dy || dx === dy) && !diagCollisions)\r\n            );\r\n\r\n        case \"king\":\r\n            return (dx === 1 || dx === 0) && (dy === 1 || dy === 0);\r\n\r\n        case \"pawn\":\r\n            // Recalculate dx/dy with direction\r\n            dx = toX - item.pieceState.col;\r\n            dy = toY - item.pieceState.row;\r\n            // Allow pawn to move 2 squares on first move\r\n            if (!item.pieceState.hasMoved) {\r\n                // Negative direction moves up the board (player always at bottom)\r\n                if (\r\n                    dx === 0 &&\r\n                    (dy === -1 || dy === -2) &&\r\n                    !straightCollisions\r\n                ) {\r\n                    return square === null;\r\n                }\r\n            }\r\n            // Allow pawn to take opponents pieces diagonal by 1 square\r\n            if ((dx === 1 || dx === -1) && dy === -1 && square !== null)\r\n                return true;\r\n\r\n            // Allow pawn to move forward by 1 square\r\n            return dx === 0 && dy === -1 && square === null;\r\n\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if the current square is empty\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @returns piece name and state if square is not empty, null otherwise\r\n */\r\nfunction squareIsEmpty(x, y, boardState) {\r\n    for (const [piece, state] of Object.entries(boardState)) {\r\n        if (x === state.col && y === state.row) {\r\n            return { piece, state };\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks if there is a piece in the diagonal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} monitor contains data about the currently dragged piece\r\n * @returns true if an opponents piece is inbetween the square and the currently dragged piece, false otherwise\r\n */\r\nfunction checkDiagCollisions(x, y, boardState, monitor) {\r\n    const row = monitor.getItem().pieceState.row;\r\n    const col = monitor.getItem().pieceState.col;\r\n\r\n    const dirX = Math.sign(x - col);\r\n    const dirY = Math.sign(y - row);\r\n    for (let i = 1; i < Math.abs(x - col) + 1; i++) {\r\n        for (const [_, state] of Object.entries(boardState)) {\r\n            if (\r\n                col + i * dirX === state.col &&\r\n                row + i * dirY === state.row &&\r\n                state.isAlive\r\n            ) {\r\n                if (i !== Math.abs(x - col)) {\r\n                    // Stops opponents pieces from being taken when hidden behind each other\r\n                    return true;\r\n                }\r\n                return state.isOwner;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Checks if there is a piece in the vertical and horizontal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} monitor contains data about the currently dragged piece\r\n * @returns true if an opponents piece is inbetween the square and the currently dragged piece, false otherwise\r\n */\r\nfunction checkStraightCollisions(x, y, boardState, monitor) {\r\n    const row = monitor.getItem().pieceState.row;\r\n    const col = monitor.getItem().pieceState.col;\r\n    const dx = Math.abs(x - col);\r\n    const dy = Math.abs(y - row);\r\n\r\n    if (dx > 0 && dy > 0) return true;\r\n    const dirX = Math.sign(x - col);\r\n    const dirY = Math.sign(y - row);\r\n\r\n    for (let i = 1; i < Math.max(dx, dy) + 1; i++) {\r\n        for (const [_, state] of Object.entries(boardState)) {\r\n            if (state.isAlive) {\r\n                // Move is horizontal if dy = 0, otherwise vertical\r\n                if (dy === 0) {\r\n                    if (col + i * dirX === state.col && row === state.row) {\r\n                        if (i !== Math.abs(x - col)) {\r\n                            // Stops opponents pieces from being taken when hidden behind each other\r\n                            return true;\r\n                        }\r\n                        return state.isOwner;\r\n                    }\r\n                } else {\r\n                    if (row + i * dirY === state.row && col === state.col) {\r\n                        if (i !== Math.abs(y - row)) {\r\n                            // Stops opponents pieces from being taken when hidden behind each other\r\n                            return true;\r\n                        }\r\n                        return state.isOwner;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}