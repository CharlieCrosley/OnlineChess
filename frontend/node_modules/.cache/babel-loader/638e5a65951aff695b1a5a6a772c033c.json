{"ast":null,"code":"import _slicedToArray from\"C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import _defineProperty from\"C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";import _toConsumableArray from\"C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _objectSpread from\"C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// Audio handler for game events\nvar audio={move:new Audio(require(\"../assets/sounds/move.mp3\")),capture:new Audio(require(\"../assets/sounds/capture.ogg\")),end:new Audio(require(\"../assets/sounds/game_end.mp3\"))};/**\r\n * Callback for setting the board state\r\n *\r\n * @callback setBoardState\r\n * @param {Object} board An dictionary representing the current board state\r\n */ /**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {setBoardState} setBoardState sets a new state of the board\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */export function movePiece(toX,toY,setBoardState,setTakenPieces,item,boardState){var square=squareIsEmpty(toX,toY,boardState);// check if piece on square\n// Ensure piece on square is not owned and is alive before taking\nif(square!=null&&!square.isOwner&&boardState[square.piece].isAlive){boardState[square.piece].isAlive=false;// Track what pieces are taken so that they can be rendered under player name\nvar pieceNameSplit=square.piece.split(\"_\");var piecePathName=pieceNameSplit[0]+\"_\"+pieceNameSplit[1];var pieceImgPath=require(\"../assets/images/pieces/\"+piecePathName+\".png\");var colour;if(pieceNameSplit[1]===\"w\")colour=\"white\";else colour=\"black\";// Sort the array of pieces so that matching pieces appear next to eachother\nsetTakenPieces(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},colour,[].concat(_toConsumableArray(prevState[colour]),[pieceImgPath]).sort()));});// play sound effect when capturing a piece\naudio.capture.play();}else{// play sound effect when moving a piece\naudio.move.play();}// Update state of the moved piece\nsetBoardState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},item.pieceName,{row:toY,col:toX,hasMoved:true,isOwner:true,isAlive:true}));});}/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} monitor contains data about the currently dragged piece\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */export function canMovePiece(toX,toY,draggedPiece,boardState){var square=squareIsEmpty(toX,toY,boardState);// if a friendly piece is in a square, don't allow this piece to be moved there\nif(square&&square.state.isOwner&&square.state.isAlive)return false;// calculate the difference between the new square and the piece being dragged\nvar dx=Math.abs(toX-draggedPiece.pieceState.col);var dy=Math.abs(toY-draggedPiece.pieceState.row);var pieceName=draggedPiece.pieceName.split(\"_\")[0];// Check the row and column of the piece to see if the movement should be blocked\n// by another piece\nvar straightCollision=checkStraightCollisions(toX,toY,boardState,draggedPiece);// Check the diagonal of the piece to see if the movement should be blocked\n// by another piece\nvar diagCollision=checkDiagCollisions(toX,toY,boardState,draggedPiece);// Check if the piece is currently under attack\nvar isPieceUnderAttack=checkIfMoveUnderAttack(draggedPiece.pieceState.col,draggedPiece.pieceState.row,boardState);// Get the players king\nvar king=boardState[\"king_w\"].isOwner?boardState[\"king_w\"]:boardState[\"king_b\"];var pieceAttackingKing,isProtectingKing;// Move must protect king if king is in check\n/* const kingInCheck =\r\n        king.inCheck &&\r\n        checkIfPieceIsProtectingKing(toX, toY, boardState, draggedPiece); */ /* if (king.inCheck) {\r\n        pieceAttackingKing = checkIfPieceIsProtectingKing(\r\n            toX,\r\n            toY,\r\n            boardState,\r\n            draggedPiece\r\n        );\r\n    } */ //boardState[\"queen_w\"].row = 4;\n//boardState[\"queen_w\"].col = 7;\n//boardState[\"king_b\"].row = 4;\n//boardState[\"king_b\"].col = 4;\nif(pieceName!==\"king\"){// Check if the piece is defending the king\n// Get the piece that is attacking the king if true\npieceAttackingKing=checkIfPieceIsProtectingKing(draggedPiece.pieceState.col,draggedPiece.pieceState.row,boardState,draggedPiece.pieceName);isProtectingKing=pieceAttackingKing!==null&&isPieceUnderAttack;}var canMoveWhilstProtecting=function canMoveWhilstProtecting(){// Dont allow the pawn to move if its protecting king unless it can take the piece\n// and ensure that the piece is alive before taking\nif(isProtectingKing&&(square!==null&&pieceAttackingKing!==square.piece||square===null||square!==null&&!square.state.isAlive))return false;return true;};switch(pieceName){case\"king\":var moveNotInCheck=!checkIfMoveUnderAttack(toX,toY,boardState);return(dx===1||dx===0)&&(dy===1||dy===0)&&moveNotInCheck;case\"castle\":if(!canMoveWhilstProtecting())return;return(dx===0&&dy>0||dx>0&&dy===0)&&!straightCollision.collision;case\"knight\":if(!canMoveWhilstProtecting())return;return dx===2&&dy===1||dx===1&&dy===2;case\"bishop\":if(!canMoveWhilstProtecting())return;return!(dx===0&&dy>0)&&!(dx>0&&dy===0)&&(dx===dy||dx===dy)&&!diagCollision.collision;case\"queen\":if(!canMoveWhilstProtecting())return;return(dx===0&&dy>0||dx>0&&dy===0)&&!straightCollision.collision||(dx===dy||dx===dy)&&!diagCollision.collision;case\"pawn\":if(!canMoveWhilstProtecting())return;if(king.inCheck&&!checkIfPieceIsProtectingKing(toX,toY,boardState,draggedPiece))return;// Recalculate dx/dy with direction\ndx=toX-draggedPiece.pieceState.col;dy=toY-draggedPiece.pieceState.row;// Allow pawn to move 2 squares on first move\nif(!draggedPiece.pieceState.hasMoved){// Negative direction moves up the board (player always at bottom)\nif(dx===0&&(dy===-1||dy===-2)&&!straightCollision.collision){return square===null;}}// Allow pawn to take opponents pieces diagonal by 1 square\nif((dx===1||dx===-1)&&dy===-1&&square!==null)return true;// Allow pawn to move forward by 1 square\nreturn dx===0&&dy===-1&&square===null;default:return false;}}/**\r\n * Checks if the current square is empty\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @returns piece name and state if square is not empty, null otherwise\r\n */function squareIsEmpty(x,y,boardState){for(var _i=0,_Object$entries=Object.entries(boardState);_i<_Object$entries.length;_i++){var _Object$entries$_i=_slicedToArray(_Object$entries[_i],2),piece=_Object$entries$_i[0],state=_Object$entries$_i[1];if(x===state.col&&y===state.row){return{piece:piece,state:state};}}return null;}/**\r\n * Checks if there is a piece in the diagonal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece contains data about the currently dragged piece\r\n * @param {boolean} checkForOpponentPiece if true, the check will be on behalf of the opponent\r\n * @returns true if an opponents piece is inbetween the square and the currently dragged piece, false otherwise\r\n */function checkDiagCollisions(x,y,boardState,draggedPiece){var checkForOpponentPiece=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;// Get row and col of dragged piece\nvar row=draggedPiece.pieceState.row;var col=draggedPiece.pieceState.col;var dirX=Math.sign(x-col);var dirY=Math.sign(y-row);for(var i=1;i<Math.abs(x-col)+1;i++){for(var _i2=0,_Object$entries2=Object.entries(boardState);_i2<_Object$entries2.length;_i2++){var _Object$entries2$_i=_slicedToArray(_Object$entries2[_i2],2),piece=_Object$entries2$_i[0],state=_Object$entries2$_i[1];if(col+i*dirX===state.col&&row+i*dirY===state.row&&state.isAlive){if(i!==Math.abs(x-col)){// Stops opponents pieces from being taken when hidden behind each other\nreturn{piece:piece,collision:true};}return{piece:piece,collision:checkForOpponentPiece?!state.isOwner:state.isOwner};}}}return{piece:null,collision:false};}/**\r\n * Checks if there is a piece in the vertical and horizontal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece contains data about the currently dragged piece\r\n * @param {boolean} checkForOpponentPiece if true, the check will be on behalf of the opponent\r\n * @returns true and the piece name if an opponents piece is inbetween the square and the currently dragged piece, false and null otherwise\r\n */function checkStraightCollisions(x,y,boardState,draggedPiece){var checkForOpponentPiece=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;// Get row and col of dragged piece\nvar row=draggedPiece.pieceState.row;var col=draggedPiece.pieceState.col;// Get change in x and y between dragged piece and square\nvar dx=Math.abs(x-col);var dy=Math.abs(y-row);// Ignore diagonal moves\nif(dx>0&&dy>0)return true;// get direction of move\nvar dirX=Math.sign(x-col);var dirY=Math.sign(y-row);for(var i=1;i<Math.max(dx,dy)+1;i++){for(var _i3=0,_Object$entries3=Object.entries(boardState);_i3<_Object$entries3.length;_i3++){var _Object$entries3$_i=_slicedToArray(_Object$entries3[_i3],2),piece=_Object$entries3$_i[0],state=_Object$entries3$_i[1];if(state.isAlive){// Move is horizontal if dy = 0, otherwise vertical\nif(dy===0){if(col+i*dirX===state.col&&row===state.row){if(i!==Math.abs(x-col)){// Stops opponents pieces from being taken when hidden behind each other\nreturn{piece:piece,collision:true};}return{piece:piece,collision:checkForOpponentPiece?!state.isOwner:state.isOwner};}}else{if(row+i*dirY===state.row&&col===state.col){if(i!==Math.abs(y-row)){// Stops opponents pieces from being taken when hidden behind each other\nreturn{piece:piece,collision:true};}//console.log(piece, state.isAlive);\nreturn{piece:piece,collision:checkForOpponentPiece?!state.isOwner:state.isOwner};}}}}}return{piece:null,collision:false};}/**\r\n * Checks if a piece at (x,y) on the board is under attack by an opponents piece\r\n * @param {*} x x coordinate of the square currently being checked\r\n * @param {*} y y coordinate of the square currently being checked\r\n * @param {*} boardState current state of the board\r\n * @returns true if the piece is under attack, false otherwise\r\n */function checkIfMoveUnderAttack(x,y,boardState){for(var _i4=0,_Object$entries4=Object.entries(boardState);_i4<_Object$entries4.length;_i4++){var _Object$entries4$_i=_slicedToArray(_Object$entries4[_i4],2),piece=_Object$entries4$_i[0],state=_Object$entries4$_i[1];// King cannot be checked by its own pieces\nif(!state.isOwner){var dx=Math.abs(x-state.col);var dy=Math.abs(y-state.row);// Check if the square is under attack from an opponents piece via straight line\nvar straightCollisions=checkStraightCollisions(state.col,state.row,boardState,{pieceState:{col:x,row:y}});if(straightCollisions.piece&&!straightCollisions.collision){var pieceName=straightCollisions.piece.split(\"_\")[0];// If the piece can take pieces horizontally or vertically or king is in range,\n// then the move is not valid\nif(pieceName===\"queen\"||pieceName===\"castle\"||pieceName===\"king\"&&(dx===1||dy===1)){return true;}}// Check if the square is under attack from an opponents piece via diagonal line\nvar diagCollisions=checkDiagCollisions(state.col,state.row,boardState,{pieceState:{col:x,row:y}});if(diagCollisions.piece&&!diagCollisions.collision){var _pieceName=diagCollisions.piece.split(\"_\")[0];// If the piece can move diagonally or the pawn is in range of square,\n// then the move is not valid\nif(_pieceName===\"queen\"||_pieceName===\"bishop\"||_pieceName===\"king\"&&dx===1&&dy===1||_pieceName===\"pawn\"&&dx===1&&y-state.row===2){return true;}}// Check if square is under attack by a knight\nif(piece.split(\"_\")[0]===\"knight\"&&(dx===2&&dy===1||dx===1&&dy===2)){return true;}}}return false;}/**\r\n * Check if the piece at (x,y) on the board is blocking an opponent piece from checking the king\r\n * @param {*} x x coordinate of the square currently being checked\r\n * @param {*} y y coordinate of the square currently being checked\r\n * @param {*} boardState current state of the board\r\n * @param {*} draggedPiece piece being dragged\r\n * @returns name of piece attacking king, if no such piece exists, return null\r\n */function checkIfPieceIsProtectingKing(x,y,boardState,draggedPiece){// Get players king\nvar king=boardState[\"king_w\"].isOwner?boardState[\"king_w\"]:boardState[\"king_b\"];// Direction from (x,y) to king\nvar dirX=Math.sign(x-king.col);var dirY=Math.sign(y-king.row);var dx=Math.abs(king.col-x);var dy=Math.abs(king.row-y);var getOppositeCoords=function getOppositeCoords(king){var oppositeX=king.col;var oppositeY=king.row;// Get the x,y in the opposite direction to the king to the edge of the board\nwhile(oppositeX<=7&&oppositeX>=0&&oppositeY<=7&&oppositeY>=0){oppositeX+=dirX;oppositeY+=dirY;}return[oppositeX,oppositeY];};// Check pieces that are directly above or beside the king\nif(dx===0||(dirX===1||dirX===-1)&&dy===0){// Check if piece is inbetween king and opponent piece that can attack king\nvar straightCollisions=checkStraightCollisions(x,y,boardState,{pieceState:{col:king.col,row:king.row}});// A piece is inbetween the dragged piece and the king,\n// therefore, it is not protecting the king and can be moved\nif(straightCollisions.collision&&straightCollisions.piece!==draggedPiece)return null;var _getOppositeCoords=getOppositeCoords(king),_getOppositeCoords2=_slicedToArray(_getOppositeCoords,2),oppositeX=_getOppositeCoords2[0],oppositeY=_getOppositeCoords2[1];var oppositeStraightCollisions=checkStraightCollisions(x,y,boardState,{pieceState:{col:oppositeX,row:oppositeY}});if(oppositeStraightCollisions.piece){var pieceName=oppositeStraightCollisions.piece.split(\"_\")[0];// If the piece in opposite direction to king is able to attack the king\n// once the dragged piece is moved, then don't allow the piece to be moved\nif(pieceName===\"castle\"||pieceName===\"queen\"){// the piece is protecting the king\nreturn oppositeStraightCollisions.piece;}}}else if(dx===dy){// Check the pieces directly diagonal to the king\n// Check if piece is inbetween king and opponent piece that can attack king\nvar diagCollisions=checkDiagCollisions(x,y,boardState,{pieceState:{col:king.col,row:king.row}});// A piece is inbetween the dragged piece and the king,\n// therefore, it is not protecting the king and can be moved\nif(diagCollisions.collision&&diagCollisions.piece!==draggedPiece)return null;var _getOppositeCoords3=getOppositeCoords(king),_getOppositeCoords4=_slicedToArray(_getOppositeCoords3,2),_oppositeX=_getOppositeCoords4[0],_oppositeY=_getOppositeCoords4[1];var oppositeDiagCollisions=checkDiagCollisions(x,y,boardState,{pieceState:{col:_oppositeX,row:_oppositeY}});if(oppositeDiagCollisions.piece){var _pieceName2=oppositeDiagCollisions.piece.split(\"_\")[0];// If the piece in opposite direction to king is able to attack the king\n// once the dragged piece is moved, then don't allow the piece to be moved\nif(_pieceName2===\"bishop\"||_pieceName2===\"queen\"){// the piece is protecting the king\nreturn oppositeDiagCollisions.piece;}}}return null;}/**\r\n * Checks if a piece at (x,y) on the board is under attack by an opponents piece\r\n * @param {*} boardState current state of the board\r\n * @returns true if the piece is under attack, false otherwise\r\n */export function checkIfOpponentInCheck(boardState,opponentKing){for(var _i5=0,_Object$entries5=Object.entries(boardState);_i5<_Object$entries5.length;_i5++){var _Object$entries5$_i=_slicedToArray(_Object$entries5[_i5],2),piece=_Object$entries5$_i[0],state=_Object$entries5$_i[1];// King cannot be checked by its own pieces\nif(state.isOwner){var dx=Math.abs(opponentKing.col-state.col);var dy=Math.abs(opponentKing.row-state.row);// Check if the square is under attack from an opponents piece via straight line\nvar straightCollisions=checkStraightCollisions(state.col,state.row,boardState,{pieceState:{col:opponentKing.col,row:opponentKing.row}},true);//console.log(straightCollisions);\nif(straightCollisions.piece&&!straightCollisions.collision){var pieceName=straightCollisions.piece.split(\"_\")[0];// If the piece can take pieces horizontally or vertically or king is in range,\n// then the move is not valid\nif(pieceName===\"queen\"||pieceName===\"castle\"||pieceName===\"king\"&&(dx===1||dy===1)){return true;}}// Check if the square is under attack from an opponents piece via diagonal line\nvar diagCollisions=checkDiagCollisions(state.col,state.row,boardState,{pieceState:{col:opponentKing.col,row:opponentKing.row}},true);if(diagCollisions.piece&&!diagCollisions.collision){var _pieceName3=diagCollisions.piece.split(\"_\")[0];// If the piece can move diagonally or the pawn is in range of square,\n// then the move is not valid\nif(_pieceName3===\"queen\"||_pieceName3===\"bishop\"||_pieceName3===\"king\"&&dx===1&&dy===1||_pieceName3===\"pawn\"&&dx===1&&opponentKing.row-state.row===2){return true;}}// Check if square is under attack by a knight\nif(piece.split(\"_\")[0]===\"knight\"&&(dx===2&&dy===1||dx===1&&dy===2)){return true;}}}return false;}","map":{"version":3,"names":["audio","move","Audio","require","capture","end","movePiece","toX","toY","setBoardState","setTakenPieces","item","boardState","square","squareIsEmpty","isOwner","piece","isAlive","pieceNameSplit","split","piecePathName","pieceImgPath","colour","prevState","sort","play","pieceName","row","col","hasMoved","canMovePiece","draggedPiece","state","dx","Math","abs","pieceState","dy","straightCollision","checkStraightCollisions","diagCollision","checkDiagCollisions","isPieceUnderAttack","checkIfMoveUnderAttack","king","pieceAttackingKing","isProtectingKing","checkIfPieceIsProtectingKing","canMoveWhilstProtecting","moveNotInCheck","collision","inCheck","x","y","Object","entries","checkForOpponentPiece","dirX","sign","dirY","i","max","straightCollisions","diagCollisions","getOppositeCoords","oppositeX","oppositeY","oppositeStraightCollisions","oppositeDiagCollisions","checkIfOpponentInCheck","opponentKing"],"sources":["C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/src/components/Game.js"],"sourcesContent":["// Audio handler for game events\r\nconst audio = {\r\n    move: new Audio(require(\"../assets/sounds/move.mp3\")),\r\n    capture: new Audio(require(\"../assets/sounds/capture.ogg\")),\r\n    end: new Audio(require(\"../assets/sounds/game_end.mp3\")),\r\n};\r\n\r\n/**\r\n * Callback for setting the board state\r\n *\r\n * @callback setBoardState\r\n * @param {Object} board An dictionary representing the current board state\r\n */\r\n\r\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {setBoardState} setBoardState sets a new state of the board\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\r\nexport function movePiece(\r\n    toX,\r\n    toY,\r\n    setBoardState,\r\n    setTakenPieces,\r\n    item,\r\n    boardState\r\n) {\r\n    const square = squareIsEmpty(toX, toY, boardState);\r\n\r\n    // check if piece on square\r\n    // Ensure piece on square is not owned and is alive before taking\r\n    if (square != null && !square.isOwner && boardState[square.piece].isAlive) {\r\n        boardState[square.piece].isAlive = false;\r\n\r\n        // Track what pieces are taken so that they can be rendered under player name\r\n        const pieceNameSplit = square.piece.split(\"_\");\r\n        const piecePathName = pieceNameSplit[0] + \"_\" + pieceNameSplit[1];\r\n        const pieceImgPath = require(\"../assets/images/pieces/\" +\r\n            piecePathName +\r\n            \".png\");\r\n\r\n        let colour;\r\n        if (pieceNameSplit[1] === \"w\") colour = \"white\";\r\n        else colour = \"black\";\r\n        // Sort the array of pieces so that matching pieces appear next to eachother\r\n        setTakenPieces((prevState) => ({\r\n            ...prevState,\r\n            [colour]: [...prevState[colour], pieceImgPath].sort(),\r\n        }));\r\n\r\n        // play sound effect when capturing a piece\r\n        audio.capture.play();\r\n    } else {\r\n        // play sound effect when moving a piece\r\n        audio.move.play();\r\n    }\r\n\r\n    // Update state of the moved piece\r\n    setBoardState((prevState) => ({\r\n        ...prevState,\r\n        [item.pieceName]: {\r\n            row: toY,\r\n            col: toX,\r\n            hasMoved: true,\r\n            isOwner: true,\r\n            isAlive: true,\r\n        },\r\n    }));\r\n}\r\n\r\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} monitor contains data about the currently dragged piece\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\r\nexport function canMovePiece(toX, toY, draggedPiece, boardState) {\r\n    const square = squareIsEmpty(toX, toY, boardState);\r\n\r\n    // if a friendly piece is in a square, don't allow this piece to be moved there\r\n    if (square && square.state.isOwner && square.state.isAlive) return false;\r\n\r\n    // calculate the difference between the new square and the piece being dragged\r\n    var dx = Math.abs(toX - draggedPiece.pieceState.col);\r\n    var dy = Math.abs(toY - draggedPiece.pieceState.row);\r\n\r\n    const pieceName = draggedPiece.pieceName.split(\"_\")[0];\r\n\r\n    // Check the row and column of the piece to see if the movement should be blocked\r\n    // by another piece\r\n    const straightCollision = checkStraightCollisions(\r\n        toX,\r\n        toY,\r\n        boardState,\r\n        draggedPiece\r\n    );\r\n    // Check the diagonal of the piece to see if the movement should be blocked\r\n    // by another piece\r\n    const diagCollision = checkDiagCollisions(\r\n        toX,\r\n        toY,\r\n        boardState,\r\n        draggedPiece\r\n    );\r\n\r\n    // Check if the piece is currently under attack\r\n    const isPieceUnderAttack = checkIfMoveUnderAttack(\r\n        draggedPiece.pieceState.col,\r\n        draggedPiece.pieceState.row,\r\n        boardState\r\n    );\r\n\r\n    // Get the players king\r\n    const king = boardState[\"king_w\"].isOwner\r\n        ? boardState[\"king_w\"]\r\n        : boardState[\"king_b\"];\r\n    let pieceAttackingKing, isProtectingKing;\r\n    // Move must protect king if king is in check\r\n    /* const kingInCheck =\r\n        king.inCheck &&\r\n        checkIfPieceIsProtectingKing(toX, toY, boardState, draggedPiece); */\r\n    /* if (king.inCheck) {\r\n        pieceAttackingKing = checkIfPieceIsProtectingKing(\r\n            toX,\r\n            toY,\r\n            boardState,\r\n            draggedPiece\r\n        );\r\n    } */\r\n\r\n    //boardState[\"queen_w\"].row = 4;\r\n    //boardState[\"queen_w\"].col = 7;\r\n    //boardState[\"king_b\"].row = 4;\r\n    //boardState[\"king_b\"].col = 4;\r\n\r\n    if (pieceName !== \"king\") {\r\n        // Check if the piece is defending the king\r\n        // Get the piece that is attacking the king if true\r\n        pieceAttackingKing = checkIfPieceIsProtectingKing(\r\n            draggedPiece.pieceState.col,\r\n            draggedPiece.pieceState.row,\r\n            boardState,\r\n            draggedPiece.pieceName\r\n        );\r\n        isProtectingKing = pieceAttackingKing !== null && isPieceUnderAttack;\r\n    }\r\n\r\n    const canMoveWhilstProtecting = () => {\r\n        // Dont allow the pawn to move if its protecting king unless it can take the piece\r\n        // and ensure that the piece is alive before taking\r\n        if (\r\n            isProtectingKing &&\r\n            ((square !== null && pieceAttackingKing !== square.piece) ||\r\n                square === null ||\r\n                (square !== null && !square.state.isAlive))\r\n        )\r\n            return false;\r\n        return true;\r\n    };\r\n\r\n    switch (pieceName) {\r\n        case \"king\":\r\n            const moveNotInCheck = !checkIfMoveUnderAttack(\r\n                toX,\r\n                toY,\r\n                boardState\r\n            );\r\n            return (\r\n                (dx === 1 || dx === 0) &&\r\n                (dy === 1 || dy === 0) &&\r\n                moveNotInCheck\r\n            );\r\n\r\n        case \"castle\":\r\n            if (!canMoveWhilstProtecting()) return;\r\n            return (\r\n                ((dx === 0 && dy > 0) || (dx > 0 && dy === 0)) &&\r\n                !straightCollision.collision\r\n            );\r\n\r\n        case \"knight\":\r\n            if (!canMoveWhilstProtecting()) return;\r\n            return (dx === 2 && dy === 1) || (dx === 1 && dy === 2);\r\n\r\n        case \"bishop\":\r\n            if (!canMoveWhilstProtecting()) return;\r\n            return (\r\n                !(dx === 0 && dy > 0) &&\r\n                !(dx > 0 && dy === 0) &&\r\n                (dx === dy || dx === dy) &&\r\n                !diagCollision.collision\r\n            );\r\n\r\n        case \"queen\":\r\n            if (!canMoveWhilstProtecting()) return;\r\n            return (\r\n                (((dx === 0 && dy > 0) || (dx > 0 && dy === 0)) &&\r\n                    !straightCollision.collision) ||\r\n                ((dx === dy || dx === dy) && !diagCollision.collision)\r\n            );\r\n\r\n        case \"pawn\":\r\n            if (!canMoveWhilstProtecting()) return;\r\n            if (\r\n                king.inCheck &&\r\n                !checkIfPieceIsProtectingKing(\r\n                    toX,\r\n                    toY,\r\n                    boardState,\r\n                    draggedPiece\r\n                )\r\n            )\r\n                return;\r\n            // Recalculate dx/dy with direction\r\n            dx = toX - draggedPiece.pieceState.col;\r\n            dy = toY - draggedPiece.pieceState.row;\r\n            // Allow pawn to move 2 squares on first move\r\n            if (!draggedPiece.pieceState.hasMoved) {\r\n                // Negative direction moves up the board (player always at bottom)\r\n                if (\r\n                    dx === 0 &&\r\n                    (dy === -1 || dy === -2) &&\r\n                    !straightCollision.collision\r\n                ) {\r\n                    return square === null;\r\n                }\r\n            }\r\n            // Allow pawn to take opponents pieces diagonal by 1 square\r\n            if ((dx === 1 || dx === -1) && dy === -1 && square !== null)\r\n                return true;\r\n\r\n            // Allow pawn to move forward by 1 square\r\n            return dx === 0 && dy === -1 && square === null;\r\n\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if the current square is empty\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @returns piece name and state if square is not empty, null otherwise\r\n */\r\nfunction squareIsEmpty(x, y, boardState) {\r\n    for (const [piece, state] of Object.entries(boardState)) {\r\n        if (x === state.col && y === state.row) {\r\n            return { piece, state };\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks if there is a piece in the diagonal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece contains data about the currently dragged piece\r\n * @param {boolean} checkForOpponentPiece if true, the check will be on behalf of the opponent\r\n * @returns true if an opponents piece is inbetween the square and the currently dragged piece, false otherwise\r\n */\r\nfunction checkDiagCollisions(\r\n    x,\r\n    y,\r\n    boardState,\r\n    draggedPiece,\r\n    checkForOpponentPiece = false\r\n) {\r\n    // Get row and col of dragged piece\r\n    const row = draggedPiece.pieceState.row;\r\n    const col = draggedPiece.pieceState.col;\r\n\r\n    const dirX = Math.sign(x - col);\r\n    const dirY = Math.sign(y - row);\r\n    for (let i = 1; i < Math.abs(x - col) + 1; i++) {\r\n        for (const [piece, state] of Object.entries(boardState)) {\r\n            if (\r\n                col + i * dirX === state.col &&\r\n                row + i * dirY === state.row &&\r\n                state.isAlive\r\n            ) {\r\n                if (i !== Math.abs(x - col)) {\r\n                    // Stops opponents pieces from being taken when hidden behind each other\r\n                    return {\r\n                        piece: piece,\r\n                        collision: true,\r\n                    };\r\n                }\r\n                return {\r\n                    piece: piece,\r\n                    collision: checkForOpponentPiece\r\n                        ? !state.isOwner\r\n                        : state.isOwner,\r\n                };\r\n            }\r\n        }\r\n    }\r\n    return { piece: null, collision: false };\r\n}\r\n\r\n/**\r\n * Checks if there is a piece in the vertical and horizontal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece contains data about the currently dragged piece\r\n * @param {boolean} checkForOpponentPiece if true, the check will be on behalf of the opponent\r\n * @returns true and the piece name if an opponents piece is inbetween the square and the currently dragged piece, false and null otherwise\r\n */\r\nfunction checkStraightCollisions(\r\n    x,\r\n    y,\r\n    boardState,\r\n    draggedPiece,\r\n    checkForOpponentPiece = false\r\n) {\r\n    // Get row and col of dragged piece\r\n    const row = draggedPiece.pieceState.row;\r\n    const col = draggedPiece.pieceState.col;\r\n    // Get change in x and y between dragged piece and square\r\n    const dx = Math.abs(x - col);\r\n    const dy = Math.abs(y - row);\r\n\r\n    // Ignore diagonal moves\r\n    if (dx > 0 && dy > 0) return true;\r\n\r\n    // get direction of move\r\n    const dirX = Math.sign(x - col);\r\n    const dirY = Math.sign(y - row);\r\n\r\n    for (let i = 1; i < Math.max(dx, dy) + 1; i++) {\r\n        for (const [piece, state] of Object.entries(boardState)) {\r\n            if (state.isAlive) {\r\n                // Move is horizontal if dy = 0, otherwise vertical\r\n                if (dy === 0) {\r\n                    if (col + i * dirX === state.col && row === state.row) {\r\n                        if (i !== Math.abs(x - col)) {\r\n                            // Stops opponents pieces from being taken when hidden behind each other\r\n                            return {\r\n                                piece: piece,\r\n                                collision: true,\r\n                            };\r\n                        }\r\n                        return {\r\n                            piece: piece,\r\n                            collision: checkForOpponentPiece\r\n                                ? !state.isOwner\r\n                                : state.isOwner,\r\n                        };\r\n                    }\r\n                } else {\r\n                    if (row + i * dirY === state.row && col === state.col) {\r\n                        if (i !== Math.abs(y - row)) {\r\n                            // Stops opponents pieces from being taken when hidden behind each other\r\n                            return {\r\n                                piece: piece,\r\n                                collision: true,\r\n                            };\r\n                        }\r\n                        //console.log(piece, state.isAlive);\r\n                        return {\r\n                            piece: piece,\r\n                            collision: checkForOpponentPiece\r\n                                ? !state.isOwner\r\n                                : state.isOwner,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return { piece: null, collision: false };\r\n}\r\n\r\n/**\r\n * Checks if a piece at (x,y) on the board is under attack by an opponents piece\r\n * @param {*} x x coordinate of the square currently being checked\r\n * @param {*} y y coordinate of the square currently being checked\r\n * @param {*} boardState current state of the board\r\n * @returns true if the piece is under attack, false otherwise\r\n */\r\nfunction checkIfMoveUnderAttack(x, y, boardState) {\r\n    for (const [piece, state] of Object.entries(boardState)) {\r\n        // King cannot be checked by its own pieces\r\n        if (!state.isOwner) {\r\n            const dx = Math.abs(x - state.col);\r\n            const dy = Math.abs(y - state.row);\r\n\r\n            // Check if the square is under attack from an opponents piece via straight line\r\n            const straightCollisions = checkStraightCollisions(\r\n                state.col,\r\n                state.row,\r\n                boardState,\r\n                {\r\n                    pieceState: { col: x, row: y },\r\n                }\r\n            );\r\n\r\n            if (straightCollisions.piece && !straightCollisions.collision) {\r\n                const pieceName = straightCollisions.piece.split(\"_\")[0];\r\n                // If the piece can take pieces horizontally or vertically or king is in range,\r\n                // then the move is not valid\r\n                if (\r\n                    pieceName === \"queen\" ||\r\n                    pieceName === \"castle\" ||\r\n                    (pieceName === \"king\" && (dx === 1 || dy === 1))\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n            // Check if the square is under attack from an opponents piece via diagonal line\r\n            const diagCollisions = checkDiagCollisions(\r\n                state.col,\r\n                state.row,\r\n                boardState,\r\n                {\r\n                    pieceState: { col: x, row: y },\r\n                }\r\n            );\r\n            if (diagCollisions.piece && !diagCollisions.collision) {\r\n                const pieceName = diagCollisions.piece.split(\"_\")[0];\r\n\r\n                // If the piece can move diagonally or the pawn is in range of square,\r\n                // then the move is not valid\r\n                if (\r\n                    pieceName === \"queen\" ||\r\n                    pieceName === \"bishop\" ||\r\n                    (pieceName === \"king\" && dx === 1 && dy === 1) ||\r\n                    (pieceName === \"pawn\" && dx === 1 && y - state.row === 2)\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // Check if square is under attack by a knight\r\n            if (\r\n                piece.split(\"_\")[0] === \"knight\" &&\r\n                ((dx === 2 && dy === 1) || (dx === 1 && dy === 2))\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Check if the piece at (x,y) on the board is blocking an opponent piece from checking the king\r\n * @param {*} x x coordinate of the square currently being checked\r\n * @param {*} y y coordinate of the square currently being checked\r\n * @param {*} boardState current state of the board\r\n * @param {*} draggedPiece piece being dragged\r\n * @returns name of piece attacking king, if no such piece exists, return null\r\n */\r\nfunction checkIfPieceIsProtectingKing(x, y, boardState, draggedPiece) {\r\n    // Get players king\r\n    const king = boardState[\"king_w\"].isOwner\r\n        ? boardState[\"king_w\"]\r\n        : boardState[\"king_b\"];\r\n\r\n    // Direction from (x,y) to king\r\n    const dirX = Math.sign(x - king.col);\r\n    const dirY = Math.sign(y - king.row);\r\n\r\n    const dx = Math.abs(king.col - x);\r\n    const dy = Math.abs(king.row - y);\r\n\r\n    const getOppositeCoords = (king) => {\r\n        let oppositeX = king.col;\r\n        let oppositeY = king.row;\r\n        // Get the x,y in the opposite direction to the king to the edge of the board\r\n        while (\r\n            oppositeX <= 7 &&\r\n            oppositeX >= 0 &&\r\n            oppositeY <= 7 &&\r\n            oppositeY >= 0\r\n        ) {\r\n            oppositeX += dirX;\r\n            oppositeY += dirY;\r\n        }\r\n        return [oppositeX, oppositeY];\r\n    };\r\n\r\n    // Check pieces that are directly above or beside the king\r\n    if (dx === 0 || ((dirX === 1 || dirX === -1) && dy === 0)) {\r\n        // Check if piece is inbetween king and opponent piece that can attack king\r\n        const straightCollisions = checkStraightCollisions(x, y, boardState, {\r\n            pieceState: { col: king.col, row: king.row },\r\n        });\r\n\r\n        // A piece is inbetween the dragged piece and the king,\r\n        // therefore, it is not protecting the king and can be moved\r\n        if (\r\n            straightCollisions.collision &&\r\n            straightCollisions.piece !== draggedPiece\r\n        )\r\n            return null;\r\n\r\n        const [oppositeX, oppositeY] = getOppositeCoords(king);\r\n\r\n        const oppositeStraightCollisions = checkStraightCollisions(\r\n            x,\r\n            y,\r\n            boardState,\r\n            {\r\n                pieceState: { col: oppositeX, row: oppositeY },\r\n            }\r\n        );\r\n\r\n        if (oppositeStraightCollisions.piece) {\r\n            const pieceName = oppositeStraightCollisions.piece.split(\"_\")[0];\r\n            // If the piece in opposite direction to king is able to attack the king\r\n            // once the dragged piece is moved, then don't allow the piece to be moved\r\n            if (pieceName === \"castle\" || pieceName === \"queen\") {\r\n                // the piece is protecting the king\r\n                return oppositeStraightCollisions.piece;\r\n            }\r\n        }\r\n    } else if (dx === dy) {\r\n        // Check the pieces directly diagonal to the king\r\n        // Check if piece is inbetween king and opponent piece that can attack king\r\n        const diagCollisions = checkDiagCollisions(x, y, boardState, {\r\n            pieceState: { col: king.col, row: king.row },\r\n        });\r\n\r\n        // A piece is inbetween the dragged piece and the king,\r\n        // therefore, it is not protecting the king and can be moved\r\n        if (diagCollisions.collision && diagCollisions.piece !== draggedPiece)\r\n            return null;\r\n\r\n        const [oppositeX, oppositeY] = getOppositeCoords(king);\r\n\r\n        const oppositeDiagCollisions = checkDiagCollisions(x, y, boardState, {\r\n            pieceState: { col: oppositeX, row: oppositeY },\r\n        });\r\n        if (oppositeDiagCollisions.piece) {\r\n            const pieceName = oppositeDiagCollisions.piece.split(\"_\")[0];\r\n            // If the piece in opposite direction to king is able to attack the king\r\n            // once the dragged piece is moved, then don't allow the piece to be moved\r\n            if (pieceName === \"bishop\" || pieceName === \"queen\") {\r\n                // the piece is protecting the king\r\n                return oppositeDiagCollisions.piece;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks if a piece at (x,y) on the board is under attack by an opponents piece\r\n * @param {*} boardState current state of the board\r\n * @returns true if the piece is under attack, false otherwise\r\n */\r\nexport function checkIfOpponentInCheck(boardState, opponentKing) {\r\n    for (const [piece, state] of Object.entries(boardState)) {\r\n        // King cannot be checked by its own pieces\r\n        if (state.isOwner) {\r\n            const dx = Math.abs(opponentKing.col - state.col);\r\n            const dy = Math.abs(opponentKing.row - state.row);\r\n\r\n            // Check if the square is under attack from an opponents piece via straight line\r\n            const straightCollisions = checkStraightCollisions(\r\n                state.col,\r\n                state.row,\r\n                boardState,\r\n                {\r\n                    pieceState: {\r\n                        col: opponentKing.col,\r\n                        row: opponentKing.row,\r\n                    },\r\n                },\r\n                true\r\n            );\r\n\r\n            //console.log(straightCollisions);\r\n            if (straightCollisions.piece && !straightCollisions.collision) {\r\n                const pieceName = straightCollisions.piece.split(\"_\")[0];\r\n                // If the piece can take pieces horizontally or vertically or king is in range,\r\n                // then the move is not valid\r\n                if (\r\n                    pieceName === \"queen\" ||\r\n                    pieceName === \"castle\" ||\r\n                    (pieceName === \"king\" && (dx === 1 || dy === 1))\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n            // Check if the square is under attack from an opponents piece via diagonal line\r\n            const diagCollisions = checkDiagCollisions(\r\n                state.col,\r\n                state.row,\r\n                boardState,\r\n                {\r\n                    pieceState: {\r\n                        col: opponentKing.col,\r\n                        row: opponentKing.row,\r\n                    },\r\n                },\r\n                true\r\n            );\r\n            if (diagCollisions.piece && !diagCollisions.collision) {\r\n                const pieceName = diagCollisions.piece.split(\"_\")[0];\r\n\r\n                // If the piece can move diagonally or the pawn is in range of square,\r\n                // then the move is not valid\r\n                if (\r\n                    pieceName === \"queen\" ||\r\n                    pieceName === \"bishop\" ||\r\n                    (pieceName === \"king\" && dx === 1 && dy === 1) ||\r\n                    (pieceName === \"pawn\" &&\r\n                        dx === 1 &&\r\n                        opponentKing.row - state.row === 2)\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // Check if square is under attack by a knight\r\n            if (\r\n                piece.split(\"_\")[0] === \"knight\" &&\r\n                ((dx === 2 && dy === 1) || (dx === 1 && dy === 2))\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}