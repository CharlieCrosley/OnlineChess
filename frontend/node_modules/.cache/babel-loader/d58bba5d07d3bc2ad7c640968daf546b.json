{"ast":null,"code":"/**\r\n * Callback for setting the board state\r\n *\r\n * @callback setBoardState\r\n * @param {Object} board An dictionary representing the current board state\r\n */\n\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {setBoardState} setBoardState sets a new state of the board\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\nexport function movePiece(toX, toY, setBoardState, setTakenPieces, item, boardState) {\n  const square = squareIsEmpty(toX, toY, boardState); // check if piece on square\n  // Ensure piece on square is not owned and is alive before taking\n\n  if (square != null && !square.isOwner && square.state.isAlive) {\n    // Remove piece from board\n    delete boardState[square.piece]; // Track what pieces are taken so that they can be rendered under player name\n\n    const pieceNameSplit = square.piece.split(\"_\");\n    const piecePathName = pieceNameSplit[0] + \"_\" + pieceNameSplit[1];\n\n    const pieceImgPath = require(\"../assets/images/pieces/\" + piecePathName + \".png\");\n\n    let colour;\n    if (pieceNameSplit[1] === \"w\") colour = \"white\";else colour = \"black\"; // Sort the array of pieces so that matching pieces appear next to eachother\n\n    setTakenPieces(prevState => ({ ...prevState,\n      [colour]: [...prevState[colour], pieceImgPath].sort()\n    }));\n  }\n\n  const king = boardState[\"king_w\"].isOwner ? \"king_w\" : \"king_b\"; // Update state of the moved piece\n\n  if (item.pieceName.split(\"_\")[0] === \"king\") {\n    setBoardState(prevState => ({ ...prevState,\n      [item.pieceName]: {\n        row: toY,\n        col: toX,\n        hasMoved: true,\n        isOwner: true,\n        isAlive: true,\n        inCheck: false\n      }\n    }));\n  } else {\n    // Moving a piece will always take king out of check\n    setBoardState(prevState => ({ ...prevState,\n      [item.pieceName]: {\n        row: toY,\n        col: toX,\n        hasMoved: true,\n        isOwner: true,\n        isAlive: true\n      },\n      [king]: { ...boardState[king],\n        inCheck: false\n      }\n    }));\n  }\n}\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\n\nexport function canMovePiece(toX, toY, draggedPiece, boardState) {\n  const square = squareIsEmpty(toX, toY, boardState); // if a friendly piece is in a square, don't allow this piece to be moved there\n\n  if (square && square.state.isOwner && square.state.isAlive) return false; // calculate the difference between the new square and the piece being dragged\n\n  let dx = Math.abs(toX - draggedPiece.pieceState.col);\n  let dy = Math.abs(toY - draggedPiece.pieceState.row);\n  const pieceName = draggedPiece.pieceName.split(\"_\")[0]; // Check the row and column of the piece to see if the movement should be blocked\n  // by another piece\n\n  const straightCollision = checkStraightCollisions(toX, toY, boardState, draggedPiece); // Check the diagonal of the piece to see if the movement should be blocked\n  // by another piece\n\n  const diagCollision = checkDiagCollisions(toX, toY, boardState, draggedPiece); // Check if the piece is currently under attack\n\n  const isPieceUnderAttack = checkIfMoveUnderAttack(draggedPiece.pieceState.col, draggedPiece.pieceState.row, boardState) !== null; // Get the players king\n\n  const king = boardState[\"king_w\"].isOwner ? boardState[\"king_w\"] : boardState[\"king_b\"];\n  let pieceAttackingKing, isProtectingKing; // Move must protect king if king is in check\n\n  const pieceCheckingKing = checkIfPieceIsProtectingKing(toX, toY, boardState, draggedPiece.pieceName);\n  const cantMoveToProtectKing = king.inCheck && (pieceCheckingKing === null || square && square.piece !== pieceCheckingKing);\n\n  if (pieceName !== \"king\") {\n    // Check if the piece is defending the king\n    // Get the piece that is attacking the king if true\n    pieceAttackingKing = checkIfPieceIsProtectingKing(draggedPiece.pieceState.col, draggedPiece.pieceState.row, boardState, draggedPiece.pieceName);\n    isProtectingKing = pieceAttackingKing !== null && isPieceUnderAttack;\n  }\n\n  const canMoveWhilstProtecting = () => {\n    // Dont allow the pawn to move if its protecting king unless it can take the piece\n    // and ensure that the piece is alive before taking\n    if (isProtectingKing && (square !== null && pieceCheckingKing !== square.piece || square === null || square !== null && !square.state.isAlive)) return true;\n    return false;\n  };\n\n  switch (pieceName) {\n    case \"king\":\n      const moveNotInCheck = checkIfMoveUnderAttack(toX, toY, boardState) === null;\n      return (dx === 1 || dx === 0) && (dy === 1 || dy === 0) && moveNotInCheck;\n\n    case \"castle\":\n      if (canMoveWhilstProtecting()) return;\n      if (cantMoveToProtectKing) return;\n      return (dx === 0 && dy > 0 || dx > 0 && dy === 0) && !straightCollision.collision;\n\n    case \"knight\":\n      if (canMoveWhilstProtecting()) return;\n      if (cantMoveToProtectKing) return;\n      return dx === 2 && dy === 1 || dx === 1 && dy === 2;\n\n    case \"bishop\":\n      if (canMoveWhilstProtecting()) return;\n      if (cantMoveToProtectKing) return;\n      return !(dx === 0 && dy > 0) && !(dx > 0 && dy === 0) && (dx === dy || dx === dy) && !diagCollision.collision;\n\n    case \"queen\":\n      if (canMoveWhilstProtecting()) return;\n      if (cantMoveToProtectKing) return;\n      return (dx === 0 && dy > 0 || dx > 0 && dy === 0) && !straightCollision.collision || (dx === dy || dx === dy) && !diagCollision.collision;\n\n    case \"pawn\":\n      if (canMoveWhilstProtecting()) return;\n      if (cantMoveToProtectKing) return; // Recalculate dx/dy with direction\n\n      dx = toX - draggedPiece.pieceState.col;\n      dy = toY - draggedPiece.pieceState.row; // Allow pawn to move 2 squares on first move\n\n      if (!draggedPiece.pieceState.hasMoved) {\n        // Negative direction moves up the board (player always at bottom)\n        if (dx === 0 && (dy === -1 || dy === -2) && !straightCollision.collision) {\n          return square === null;\n        }\n      } // Allow pawn to take opponents pieces diagonal by 1 square\n\n\n      if ((dx === 1 || dx === -1) && dy === -1 && square !== null) return true; // Allow pawn to move forward by 1 square\n\n      return dx === 0 && dy === -1 && square === null;\n\n    default:\n      return false;\n  }\n}\n/**\r\n * Checks if the current square is empty\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @returns piece name and state if square is not empty, null otherwise\r\n */\n\nfunction squareIsEmpty(x, y, boardState) {\n  for (const [piece, state] of Object.entries(boardState)) {\n    if (x === state.col && y === state.row) {\n      return {\n        piece,\n        state\n      };\n    }\n  }\n\n  return null;\n}\n/**\r\n * Checks if there is a piece in the diagonal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece contains data about the currently dragged piece\r\n * @param {boolean} checkForOpponentPiece if true, the check will be on behalf of the opponent\r\n * @returns true if an opponents piece is inbetween the square and the currently dragged piece, false otherwise\r\n */\n\n\nfunction checkDiagCollisions(x, y, boardState, draggedPiece) {\n  let checkForOpponentPiece = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  // Get row and col of dragged piece\n  const row = draggedPiece.pieceState.row;\n  const col = draggedPiece.pieceState.col;\n  const dirX = Math.sign(x - col);\n  const dirY = Math.sign(y - row);\n\n  for (let i = 0; i < Math.abs(x - col) + 1; i++) {\n    for (const [piece, state] of Object.entries(boardState)) {\n      const owner = checkForOpponentPiece ? !state.isOwner : state.isOwner;\n\n      if (col + i * dirX === state.col && row + i * dirY === state.row && state.isAlive && (i === 0 && !owner || i !== 0)) {\n        if (i !== Math.abs(x - col)) {\n          // Stops opponents pieces from being taken when hidden behind each other\n          return {\n            piece: piece,\n            collision: true\n          };\n        }\n\n        return {\n          piece: piece,\n          collision: owner\n        };\n      }\n    }\n  }\n\n  return {\n    piece: null,\n    collision: false\n  };\n}\n/**\r\n * Checks if there is a piece in the vertical and horizontal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece contains data about the currently dragged piece\r\n * @param {boolean} checkForOpponentPiece if true, the check will be on behalf of the opponent\r\n * @returns true and the piece name if an opponents piece is inbetween the square and the currently dragged piece, false and null otherwise\r\n */\n\n\nfunction checkStraightCollisions(x, y, boardState, draggedPiece) {\n  let checkForOpponentPiece = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  // Get row and col of dragged piece\n  const row = draggedPiece.pieceState.row;\n  const col = draggedPiece.pieceState.col; // Get change in x and y between dragged piece and square\n\n  const dx = Math.abs(x - col);\n  const dy = Math.abs(y - row); // Ignore diagonal moves\n\n  if (dx > 0 && dy > 0) return true; // get direction of move\n\n  const dirX = Math.sign(x - col);\n  const dirY = Math.sign(y - row);\n\n  for (let i = 1; i < Math.max(dx, dy) + 1; i++) {\n    for (const [piece, state] of Object.entries(boardState)) {\n      if (state.isAlive) {\n        // Move is horizontal if dy = 0, otherwise vertical\n        if (dy === 0) {\n          if (col + i * dirX === state.col && row === state.row) {\n            if (i !== Math.abs(x - col)) {\n              // Stops opponents pieces from being taken when hidden behind each other\n              return {\n                piece: piece,\n                collision: true\n              };\n            }\n\n            return {\n              piece: piece,\n              collision: checkForOpponentPiece ? !state.isOwner : state.isOwner\n            };\n          }\n        } else {\n          if (row + i * dirY === state.row && col === state.col) {\n            if (i !== Math.abs(y - row)) {\n              // Stops opponents pieces from being taken when hidden behind each other\n              return {\n                piece: piece,\n                collision: true\n              };\n            }\n\n            return {\n              piece: piece,\n              collision: checkForOpponentPiece ? !state.isOwner : state.isOwner\n            };\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    piece: null,\n    collision: false\n  };\n}\n/**\r\n * Checks if a piece at (x,y) on the board is under attack by an opponents piece\r\n * @param {*} x x coordinate of the square currently being checked\r\n * @param {*} y y coordinate of the square currently being checked\r\n * @param {*} boardState current state of the board\r\n * @returns true if the piece is under attack, false otherwise\r\n */\n\n\nfunction checkIfMoveUnderAttack(x, y, boardState) {\n  for (const [piece, state] of Object.entries(boardState)) {\n    // King cannot be checked by its own pieces\n    if (!state.isOwner) {\n      const dx = Math.abs(x - state.col);\n      const dy = Math.abs(y - state.row); // Check if the square is under attack from an opponents piece via straight line\n\n      const straightCollisions = checkStraightCollisions(state.col, state.row, boardState, {\n        pieceName: null,\n        pieceState: {\n          col: x,\n          row: y\n        }\n      });\n\n      if (straightCollisions.piece && !straightCollisions.collision) {\n        const pieceName = straightCollisions.piece.split(\"_\")[0]; // If the piece can take pieces horizontally or vertically or king is in range,\n        // then the move is not valid\n\n        if (pieceName === \"queen\" || pieceName === \"castle\" || pieceName === \"king\" && (dx === 1 || dy === 1)) {\n          //return true;\n          return straightCollisions.piece;\n        }\n      } // Check if the square is under attack from an opponents piece via diagonal line\n\n\n      const diagCollisions = checkDiagCollisions(state.col, state.row, boardState, {\n        pieceState: {\n          col: x,\n          row: y\n        }\n      });\n\n      if (diagCollisions.piece && !diagCollisions.collision) {\n        const pieceName = diagCollisions.piece.split(\"_\")[0]; // If the piece can move diagonally or the pawn is in range of square,\n        // then the move is not valid\n\n        if (pieceName === \"queen\" || pieceName === \"bishop\" || pieceName === \"king\" && dx === 1 && dy === 1 || pieceName === \"pawn\" && dx === 1 && y - state.row === 1) {\n          //return true;\n          return diagCollisions.piece;\n        }\n      } // Check if square is under attack by a knight\n\n\n      if (piece.split(\"_\")[0] === \"knight\" && (dx === 2 && dy === 1 || dx === 1 && dy === 2)) {\n        return piece;\n      }\n    }\n  }\n\n  return null;\n}\n/**\r\n * Check if the piece at (x,y) on the board is blocking an opponent piece from checking the king\r\n * @param {*} x x coordinate of the square currently being checked\r\n * @param {*} y y coordinate of the square currently being checked\r\n * @param {*} boardState current state of the board\r\n * @param {*} draggedPiece piece being dragged\r\n * @returns name of piece attacking king, if no such piece exists, return null\r\n */\n\n\nfunction checkIfPieceIsProtectingKing(x, y, boardState, draggedPiece) {\n  // Get players king\n  const king = boardState[\"king_w\"].isOwner ? boardState[\"king_w\"] : boardState[\"king_b\"]; // Direction from (x,y) to king\n\n  const dirX = Math.sign(x - king.col);\n  const dirY = Math.sign(y - king.row);\n  const dx = Math.abs(king.col - x);\n  const dy = Math.abs(king.row - y);\n\n  const getOppositeCoords = king => {\n    let oppositeX = king.col;\n    let oppositeY = king.row; // Get the x,y in the opposite direction to the king to the edge of the board\n\n    while (oppositeX <= 7 && oppositeX >= 0 && oppositeY <= 7 && oppositeY >= 0) {\n      oppositeX += dirX;\n      oppositeY += dirY;\n    }\n\n    return [oppositeX, oppositeY];\n  }; // Check pieces that are directly above or beside the king\n\n\n  if (dx === 0 || (dirX === 1 || dirX === -1) && dy === 0) {\n    // Check if piece is inbetween king and opponent piece that can attack king\n    const straightCollisions = checkStraightCollisions(x, y, boardState, {\n      pieceState: {\n        col: king.col,\n        row: king.row\n      }\n    }); // A piece is inbetween the dragged piece and the king,\n    // therefore, it is not protecting the king and can be moved\n\n    if (straightCollisions.collision && straightCollisions.piece !== draggedPiece) return null;\n    const [oppositeX, oppositeY] = getOppositeCoords(king);\n    const oppositeStraightCollisions = checkStraightCollisions(oppositeX, oppositeY, boardState, {\n      pieceState: {\n        col: x,\n        row: y\n      }\n    });\n\n    if (oppositeStraightCollisions.piece) {\n      const pieceName = oppositeStraightCollisions.piece.split(\"_\")[0]; // If the piece in opposite direction to king is able to attack the king\n      // once the dragged piece is moved, then don't allow the piece to be moved\n\n      if (pieceName === \"castle\" || pieceName === \"queen\") {\n        // the piece is protecting the king\n        return oppositeStraightCollisions.piece;\n      }\n    }\n  } else if (dx === dy) {\n    // Check the pieces directly diagonal to the king\n    // Check if piece is inbetween king and opponent piece that can attack king\n    const diagCollisions = checkDiagCollisions(x, y, boardState, {\n      pieceState: {\n        col: king.col,\n        row: king.row\n      }\n    }); // A piece is inbetween the dragged piece and the king,\n    // therefore, it is not protecting the king and can be moved\n\n    if (diagCollisions.collision && diagCollisions.piece !== draggedPiece) return null;\n    const [oppositeX, oppositeY] = getOppositeCoords(king);\n    const oppositeDiagCollisions = checkDiagCollisions(oppositeX, oppositeY, boardState, {\n      pieceState: {\n        col: x,\n        row: y\n      }\n    });\n\n    if (oppositeDiagCollisions.piece) {\n      const pieceName = oppositeDiagCollisions.piece.split(\"_\")[0]; // If the piece in opposite direction to king is able to attack the king\n      // once the dragged piece is moved, then don't allow the piece to be moved\n\n      if (pieceName === \"bishop\" || pieceName === \"queen\") {\n        // the piece is protecting the king\n        return oppositeDiagCollisions.piece;\n      }\n    }\n  }\n\n  return null;\n}\n/**\r\n * Checks if a piece at (x,y) on the board is under attack by an opponents piece\r\n * @param {*} boardState current state of the board\r\n * @returns true if the piece is under attack, false otherwise\r\n */\n\n\nexport function checkIfOpponentInCheck(boardState, opponentKing) {\n  for (const [piece, state] of Object.entries(boardState)) {\n    // King cannot be checked by its own pieces\n    if (state.isOwner) {\n      const dx = Math.abs(opponentKing.col - state.col);\n      const dy = Math.abs(opponentKing.row - state.row); // Check if the square is under attack from an opponents piece via straight line\n\n      const straightCollisions = checkStraightCollisions(state.col, state.row, boardState, {\n        pieceState: {\n          col: opponentKing.col,\n          row: opponentKing.row\n        }\n      }, true);\n\n      if (straightCollisions.piece && !straightCollisions.collision) {\n        const pieceName = straightCollisions.piece.split(\"_\")[0]; // If the piece can take pieces horizontally or vertically or king is in range,\n        // then the move is not valid\n\n        if (pieceName === \"queen\" || pieceName === \"castle\" || pieceName === \"king\" && (dx === 1 || dy === 1)) {\n          return true;\n        }\n      } // Check if the square is under attack from an opponents piece via diagonal line\n\n\n      const diagCollisions = checkDiagCollisions(state.col, state.row, boardState, {\n        pieceState: {\n          col: opponentKing.col,\n          row: opponentKing.row\n        }\n      }, true);\n\n      if (diagCollisions.piece && !diagCollisions.collision) {\n        const pieceName = diagCollisions.piece.split(\"_\")[0]; // If the piece can move diagonally or the pawn is in range of square,\n        // then the move is not valid\n        // negative direction is up the board\n\n        if (pieceName === \"queen\" || pieceName === \"bishop\" || pieceName === \"king\" && dx === 1 && dy === 1 || pieceName === \"pawn\" && dx === 1 && opponentKing.row - state.row === -1) {\n          return true;\n        }\n      } // Check if square is under attack by a knight\n\n\n      if (piece.split(\"_\")[0] === \"knight\" && (dx === 2 && dy === 1 || dx === 1 && dy === 2)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}","map":{"version":3,"names":["movePiece","toX","toY","setBoardState","setTakenPieces","item","boardState","square","squareIsEmpty","isOwner","state","isAlive","piece","pieceNameSplit","split","piecePathName","pieceImgPath","require","colour","prevState","sort","king","pieceName","row","col","hasMoved","inCheck","canMovePiece","draggedPiece","dx","Math","abs","pieceState","dy","straightCollision","checkStraightCollisions","diagCollision","checkDiagCollisions","isPieceUnderAttack","checkIfMoveUnderAttack","pieceAttackingKing","isProtectingKing","pieceCheckingKing","checkIfPieceIsProtectingKing","cantMoveToProtectKing","canMoveWhilstProtecting","moveNotInCheck","collision","x","y","Object","entries","checkForOpponentPiece","dirX","sign","dirY","i","owner","max","straightCollisions","diagCollisions","getOppositeCoords","oppositeX","oppositeY","oppositeStraightCollisions","oppositeDiagCollisions","checkIfOpponentInCheck","opponentKing"],"sources":["C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/src/components/Game.js"],"sourcesContent":["/**\r\n * Callback for setting the board state\r\n *\r\n * @callback setBoardState\r\n * @param {Object} board An dictionary representing the current board state\r\n */\r\n\r\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {setBoardState} setBoardState sets a new state of the board\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\r\nexport function movePiece(\r\n    toX,\r\n    toY,\r\n    setBoardState,\r\n    setTakenPieces,\r\n    item,\r\n    boardState\r\n) {\r\n    const square = squareIsEmpty(toX, toY, boardState);\r\n\r\n    // check if piece on square\r\n    // Ensure piece on square is not owned and is alive before taking\r\n    if (square != null && !square.isOwner && square.state.isAlive) {\r\n        // Remove piece from board\r\n        delete boardState[square.piece];\r\n\r\n        // Track what pieces are taken so that they can be rendered under player name\r\n        const pieceNameSplit = square.piece.split(\"_\");\r\n        const piecePathName = pieceNameSplit[0] + \"_\" + pieceNameSplit[1];\r\n        const pieceImgPath = require(\"../assets/images/pieces/\" +\r\n            piecePathName +\r\n            \".png\");\r\n\r\n        let colour;\r\n        if (pieceNameSplit[1] === \"w\") colour = \"white\";\r\n        else colour = \"black\";\r\n        // Sort the array of pieces so that matching pieces appear next to eachother\r\n        setTakenPieces((prevState) => ({\r\n            ...prevState,\r\n            [colour]: [...prevState[colour], pieceImgPath].sort(),\r\n        }));\r\n    }\r\n\r\n    const king = boardState[\"king_w\"].isOwner ? \"king_w\" : \"king_b\";\r\n\r\n    // Update state of the moved piece\r\n    if (item.pieceName.split(\"_\")[0] === \"king\") {\r\n        setBoardState((prevState) => ({\r\n            ...prevState,\r\n            [item.pieceName]: {\r\n                row: toY,\r\n                col: toX,\r\n                hasMoved: true,\r\n                isOwner: true,\r\n                isAlive: true,\r\n                inCheck: false,\r\n            },\r\n        }));\r\n    } else {\r\n        // Moving a piece will always take king out of check\r\n        setBoardState((prevState) => ({\r\n            ...prevState,\r\n            [item.pieceName]: {\r\n                row: toY,\r\n                col: toX,\r\n                hasMoved: true,\r\n                isOwner: true,\r\n                isAlive: true,\r\n            },\r\n            [king]: {\r\n                ...boardState[king],\r\n                inCheck: false,\r\n            },\r\n        }));\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\r\nexport function canMovePiece(toX, toY, draggedPiece, boardState) {\r\n    const square = squareIsEmpty(toX, toY, boardState);\r\n\r\n    // if a friendly piece is in a square, don't allow this piece to be moved there\r\n    if (square && square.state.isOwner && square.state.isAlive) return false;\r\n\r\n    // calculate the difference between the new square and the piece being dragged\r\n    let dx = Math.abs(toX - draggedPiece.pieceState.col);\r\n    let dy = Math.abs(toY - draggedPiece.pieceState.row);\r\n\r\n    const pieceName = draggedPiece.pieceName.split(\"_\")[0];\r\n\r\n    // Check the row and column of the piece to see if the movement should be blocked\r\n    // by another piece\r\n    const straightCollision = checkStraightCollisions(\r\n        toX,\r\n        toY,\r\n        boardState,\r\n        draggedPiece\r\n    );\r\n    // Check the diagonal of the piece to see if the movement should be blocked\r\n    // by another piece\r\n    const diagCollision = checkDiagCollisions(\r\n        toX,\r\n        toY,\r\n        boardState,\r\n        draggedPiece\r\n    );\r\n\r\n    // Check if the piece is currently under attack\r\n    const isPieceUnderAttack =\r\n        checkIfMoveUnderAttack(\r\n            draggedPiece.pieceState.col,\r\n            draggedPiece.pieceState.row,\r\n            boardState\r\n        ) !== null;\r\n\r\n    // Get the players king\r\n    const king = boardState[\"king_w\"].isOwner\r\n        ? boardState[\"king_w\"]\r\n        : boardState[\"king_b\"];\r\n    let pieceAttackingKing, isProtectingKing;\r\n    // Move must protect king if king is in check\r\n    const pieceCheckingKing = checkIfPieceIsProtectingKing(\r\n        toX,\r\n        toY,\r\n        boardState,\r\n        draggedPiece.pieceName\r\n    );\r\n\r\n    const cantMoveToProtectKing =\r\n        king.inCheck &&\r\n        (pieceCheckingKing === null ||\r\n            (square && square.piece !== pieceCheckingKing));\r\n\r\n    if (pieceName !== \"king\") {\r\n        // Check if the piece is defending the king\r\n        // Get the piece that is attacking the king if true\r\n        pieceAttackingKing = checkIfPieceIsProtectingKing(\r\n            draggedPiece.pieceState.col,\r\n            draggedPiece.pieceState.row,\r\n            boardState,\r\n            draggedPiece.pieceName\r\n        );\r\n        isProtectingKing = pieceAttackingKing !== null && isPieceUnderAttack;\r\n    }\r\n\r\n    const canMoveWhilstProtecting = () => {\r\n        // Dont allow the pawn to move if its protecting king unless it can take the piece\r\n        // and ensure that the piece is alive before taking\r\n        if (\r\n            isProtectingKing &&\r\n            ((square !== null && pieceCheckingKing !== square.piece) ||\r\n                square === null ||\r\n                (square !== null && !square.state.isAlive))\r\n        )\r\n            return true;\r\n        return false;\r\n    };\r\n\r\n    switch (pieceName) {\r\n        case \"king\":\r\n            const moveNotInCheck =\r\n                checkIfMoveUnderAttack(toX, toY, boardState) === null;\r\n            return (\r\n                (dx === 1 || dx === 0) &&\r\n                (dy === 1 || dy === 0) &&\r\n                moveNotInCheck\r\n            );\r\n\r\n        case \"castle\":\r\n            if (canMoveWhilstProtecting()) return;\r\n            if (cantMoveToProtectKing) return;\r\n            return (\r\n                ((dx === 0 && dy > 0) || (dx > 0 && dy === 0)) &&\r\n                !straightCollision.collision\r\n            );\r\n\r\n        case \"knight\":\r\n            if (canMoveWhilstProtecting()) return;\r\n            if (cantMoveToProtectKing) return;\r\n            return (dx === 2 && dy === 1) || (dx === 1 && dy === 2);\r\n\r\n        case \"bishop\":\r\n            if (canMoveWhilstProtecting()) return;\r\n            if (cantMoveToProtectKing) return;\r\n            return (\r\n                !(dx === 0 && dy > 0) &&\r\n                !(dx > 0 && dy === 0) &&\r\n                (dx === dy || dx === dy) &&\r\n                !diagCollision.collision\r\n            );\r\n\r\n        case \"queen\":\r\n            if (canMoveWhilstProtecting()) return;\r\n            if (cantMoveToProtectKing) return;\r\n\r\n            return (\r\n                (((dx === 0 && dy > 0) || (dx > 0 && dy === 0)) &&\r\n                    !straightCollision.collision) ||\r\n                ((dx === dy || dx === dy) && !diagCollision.collision)\r\n            );\r\n\r\n        case \"pawn\":\r\n            if (canMoveWhilstProtecting()) return;\r\n            if (cantMoveToProtectKing) return;\r\n            // Recalculate dx/dy with direction\r\n            dx = toX - draggedPiece.pieceState.col;\r\n            dy = toY - draggedPiece.pieceState.row;\r\n            // Allow pawn to move 2 squares on first move\r\n            if (!draggedPiece.pieceState.hasMoved) {\r\n                // Negative direction moves up the board (player always at bottom)\r\n                if (\r\n                    dx === 0 &&\r\n                    (dy === -1 || dy === -2) &&\r\n                    !straightCollision.collision\r\n                ) {\r\n                    return square === null;\r\n                }\r\n            }\r\n            // Allow pawn to take opponents pieces diagonal by 1 square\r\n            if ((dx === 1 || dx === -1) && dy === -1 && square !== null)\r\n                return true;\r\n\r\n            // Allow pawn to move forward by 1 square\r\n            return dx === 0 && dy === -1 && square === null;\r\n\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if the current square is empty\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @returns piece name and state if square is not empty, null otherwise\r\n */\r\nfunction squareIsEmpty(x, y, boardState) {\r\n    for (const [piece, state] of Object.entries(boardState)) {\r\n        if (x === state.col && y === state.row) {\r\n            return { piece, state };\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks if there is a piece in the diagonal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece contains data about the currently dragged piece\r\n * @param {boolean} checkForOpponentPiece if true, the check will be on behalf of the opponent\r\n * @returns true if an opponents piece is inbetween the square and the currently dragged piece, false otherwise\r\n */\r\nfunction checkDiagCollisions(\r\n    x,\r\n    y,\r\n    boardState,\r\n    draggedPiece,\r\n    checkForOpponentPiece = false\r\n) {\r\n    // Get row and col of dragged piece\r\n    const row = draggedPiece.pieceState.row;\r\n    const col = draggedPiece.pieceState.col;\r\n\r\n    const dirX = Math.sign(x - col);\r\n    const dirY = Math.sign(y - row);\r\n    for (let i = 0; i < Math.abs(x - col) + 1; i++) {\r\n        for (const [piece, state] of Object.entries(boardState)) {\r\n            const owner = checkForOpponentPiece\r\n                ? !state.isOwner\r\n                : state.isOwner;\r\n            if (\r\n                col + i * dirX === state.col &&\r\n                row + i * dirY === state.row &&\r\n                state.isAlive &&\r\n                ((i === 0 && !owner) || i !== 0)\r\n            ) {\r\n                if (i !== Math.abs(x - col)) {\r\n                    // Stops opponents pieces from being taken when hidden behind each other\r\n                    return {\r\n                        piece: piece,\r\n                        collision: true,\r\n                    };\r\n                }\r\n                return {\r\n                    piece: piece,\r\n                    collision: owner,\r\n                };\r\n            }\r\n        }\r\n    }\r\n    return { piece: null, collision: false };\r\n}\r\n\r\n/**\r\n * Checks if there is a piece in the vertical and horizontal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece contains data about the currently dragged piece\r\n * @param {boolean} checkForOpponentPiece if true, the check will be on behalf of the opponent\r\n * @returns true and the piece name if an opponents piece is inbetween the square and the currently dragged piece, false and null otherwise\r\n */\r\nfunction checkStraightCollisions(\r\n    x,\r\n    y,\r\n    boardState,\r\n    draggedPiece,\r\n    checkForOpponentPiece = false\r\n) {\r\n    // Get row and col of dragged piece\r\n    const row = draggedPiece.pieceState.row;\r\n    const col = draggedPiece.pieceState.col;\r\n    // Get change in x and y between dragged piece and square\r\n    const dx = Math.abs(x - col);\r\n    const dy = Math.abs(y - row);\r\n\r\n    // Ignore diagonal moves\r\n    if (dx > 0 && dy > 0) return true;\r\n\r\n    // get direction of move\r\n    const dirX = Math.sign(x - col);\r\n    const dirY = Math.sign(y - row);\r\n\r\n    for (let i = 1; i < Math.max(dx, dy) + 1; i++) {\r\n        for (const [piece, state] of Object.entries(boardState)) {\r\n            if (state.isAlive) {\r\n                // Move is horizontal if dy = 0, otherwise vertical\r\n                if (dy === 0) {\r\n                    if (col + i * dirX === state.col && row === state.row) {\r\n                        if (i !== Math.abs(x - col)) {\r\n                            // Stops opponents pieces from being taken when hidden behind each other\r\n                            return {\r\n                                piece: piece,\r\n                                collision: true,\r\n                            };\r\n                        }\r\n                        return {\r\n                            piece: piece,\r\n                            collision: checkForOpponentPiece\r\n                                ? !state.isOwner\r\n                                : state.isOwner,\r\n                        };\r\n                    }\r\n                } else {\r\n                    if (row + i * dirY === state.row && col === state.col) {\r\n                        if (i !== Math.abs(y - row)) {\r\n                            // Stops opponents pieces from being taken when hidden behind each other\r\n                            return {\r\n                                piece: piece,\r\n                                collision: true,\r\n                            };\r\n                        }\r\n                        return {\r\n                            piece: piece,\r\n                            collision: checkForOpponentPiece\r\n                                ? !state.isOwner\r\n                                : state.isOwner,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return { piece: null, collision: false };\r\n}\r\n\r\n/**\r\n * Checks if a piece at (x,y) on the board is under attack by an opponents piece\r\n * @param {*} x x coordinate of the square currently being checked\r\n * @param {*} y y coordinate of the square currently being checked\r\n * @param {*} boardState current state of the board\r\n * @returns true if the piece is under attack, false otherwise\r\n */\r\nfunction checkIfMoveUnderAttack(x, y, boardState) {\r\n    for (const [piece, state] of Object.entries(boardState)) {\r\n        // King cannot be checked by its own pieces\r\n        if (!state.isOwner) {\r\n            const dx = Math.abs(x - state.col);\r\n            const dy = Math.abs(y - state.row);\r\n\r\n            // Check if the square is under attack from an opponents piece via straight line\r\n            const straightCollisions = checkStraightCollisions(\r\n                state.col,\r\n                state.row,\r\n                boardState,\r\n                {\r\n                    pieceName: null,\r\n                    pieceState: { col: x, row: y },\r\n                }\r\n            );\r\n\r\n            if (straightCollisions.piece && !straightCollisions.collision) {\r\n                const pieceName = straightCollisions.piece.split(\"_\")[0];\r\n                // If the piece can take pieces horizontally or vertically or king is in range,\r\n                // then the move is not valid\r\n                if (\r\n                    pieceName === \"queen\" ||\r\n                    pieceName === \"castle\" ||\r\n                    (pieceName === \"king\" && (dx === 1 || dy === 1))\r\n                ) {\r\n                    //return true;\r\n                    return straightCollisions.piece;\r\n                }\r\n            }\r\n            // Check if the square is under attack from an opponents piece via diagonal line\r\n            const diagCollisions = checkDiagCollisions(\r\n                state.col,\r\n                state.row,\r\n                boardState,\r\n                {\r\n                    pieceState: { col: x, row: y },\r\n                }\r\n            );\r\n            if (diagCollisions.piece && !diagCollisions.collision) {\r\n                const pieceName = diagCollisions.piece.split(\"_\")[0];\r\n\r\n                // If the piece can move diagonally or the pawn is in range of square,\r\n                // then the move is not valid\r\n                if (\r\n                    pieceName === \"queen\" ||\r\n                    pieceName === \"bishop\" ||\r\n                    (pieceName === \"king\" && dx === 1 && dy === 1) ||\r\n                    (pieceName === \"pawn\" && dx === 1 && y - state.row === 1)\r\n                ) {\r\n                    //return true;\r\n                    return diagCollisions.piece;\r\n                }\r\n            }\r\n\r\n            // Check if square is under attack by a knight\r\n            if (\r\n                piece.split(\"_\")[0] === \"knight\" &&\r\n                ((dx === 2 && dy === 1) || (dx === 1 && dy === 2))\r\n            ) {\r\n                return piece;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Check if the piece at (x,y) on the board is blocking an opponent piece from checking the king\r\n * @param {*} x x coordinate of the square currently being checked\r\n * @param {*} y y coordinate of the square currently being checked\r\n * @param {*} boardState current state of the board\r\n * @param {*} draggedPiece piece being dragged\r\n * @returns name of piece attacking king, if no such piece exists, return null\r\n */\r\nfunction checkIfPieceIsProtectingKing(x, y, boardState, draggedPiece) {\r\n    // Get players king\r\n    const king = boardState[\"king_w\"].isOwner\r\n        ? boardState[\"king_w\"]\r\n        : boardState[\"king_b\"];\r\n\r\n    // Direction from (x,y) to king\r\n    const dirX = Math.sign(x - king.col);\r\n    const dirY = Math.sign(y - king.row);\r\n\r\n    const dx = Math.abs(king.col - x);\r\n    const dy = Math.abs(king.row - y);\r\n\r\n    const getOppositeCoords = (king) => {\r\n        let oppositeX = king.col;\r\n        let oppositeY = king.row;\r\n        // Get the x,y in the opposite direction to the king to the edge of the board\r\n        while (\r\n            oppositeX <= 7 &&\r\n            oppositeX >= 0 &&\r\n            oppositeY <= 7 &&\r\n            oppositeY >= 0\r\n        ) {\r\n            oppositeX += dirX;\r\n            oppositeY += dirY;\r\n        }\r\n        return [oppositeX, oppositeY];\r\n    };\r\n\r\n    // Check pieces that are directly above or beside the king\r\n    if (dx === 0 || ((dirX === 1 || dirX === -1) && dy === 0)) {\r\n        // Check if piece is inbetween king and opponent piece that can attack king\r\n        const straightCollisions = checkStraightCollisions(x, y, boardState, {\r\n            pieceState: { col: king.col, row: king.row },\r\n        });\r\n\r\n        // A piece is inbetween the dragged piece and the king,\r\n        // therefore, it is not protecting the king and can be moved\r\n        if (\r\n            straightCollisions.collision &&\r\n            straightCollisions.piece !== draggedPiece\r\n        )\r\n            return null;\r\n\r\n        const [oppositeX, oppositeY] = getOppositeCoords(king);\r\n\r\n        const oppositeStraightCollisions = checkStraightCollisions(\r\n            oppositeX,\r\n            oppositeY,\r\n            boardState,\r\n            {\r\n                pieceState: { col: x, row: y },\r\n            }\r\n        );\r\n\r\n        if (oppositeStraightCollisions.piece) {\r\n            const pieceName = oppositeStraightCollisions.piece.split(\"_\")[0];\r\n            // If the piece in opposite direction to king is able to attack the king\r\n            // once the dragged piece is moved, then don't allow the piece to be moved\r\n            if (pieceName === \"castle\" || pieceName === \"queen\") {\r\n                // the piece is protecting the king\r\n                return oppositeStraightCollisions.piece;\r\n            }\r\n        }\r\n    } else if (dx === dy) {\r\n        // Check the pieces directly diagonal to the king\r\n        // Check if piece is inbetween king and opponent piece that can attack king\r\n        const diagCollisions = checkDiagCollisions(x, y, boardState, {\r\n            pieceState: { col: king.col, row: king.row },\r\n        });\r\n\r\n        // A piece is inbetween the dragged piece and the king,\r\n        // therefore, it is not protecting the king and can be moved\r\n        if (diagCollisions.collision && diagCollisions.piece !== draggedPiece)\r\n            return null;\r\n\r\n        const [oppositeX, oppositeY] = getOppositeCoords(king);\r\n\r\n        const oppositeDiagCollisions = checkDiagCollisions(\r\n            oppositeX,\r\n            oppositeY,\r\n            boardState,\r\n            {\r\n                pieceState: { col: x, row: y },\r\n            }\r\n        );\r\n\r\n        if (oppositeDiagCollisions.piece) {\r\n            const pieceName = oppositeDiagCollisions.piece.split(\"_\")[0];\r\n            // If the piece in opposite direction to king is able to attack the king\r\n            // once the dragged piece is moved, then don't allow the piece to be moved\r\n            if (pieceName === \"bishop\" || pieceName === \"queen\") {\r\n                // the piece is protecting the king\r\n                return oppositeDiagCollisions.piece;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks if a piece at (x,y) on the board is under attack by an opponents piece\r\n * @param {*} boardState current state of the board\r\n * @returns true if the piece is under attack, false otherwise\r\n */\r\nexport function checkIfOpponentInCheck(boardState, opponentKing) {\r\n    for (const [piece, state] of Object.entries(boardState)) {\r\n        // King cannot be checked by its own pieces\r\n        if (state.isOwner) {\r\n            const dx = Math.abs(opponentKing.col - state.col);\r\n            const dy = Math.abs(opponentKing.row - state.row);\r\n\r\n            // Check if the square is under attack from an opponents piece via straight line\r\n            const straightCollisions = checkStraightCollisions(\r\n                state.col,\r\n                state.row,\r\n                boardState,\r\n                {\r\n                    pieceState: {\r\n                        col: opponentKing.col,\r\n                        row: opponentKing.row,\r\n                    },\r\n                },\r\n                true\r\n            );\r\n\r\n            if (straightCollisions.piece && !straightCollisions.collision) {\r\n                const pieceName = straightCollisions.piece.split(\"_\")[0];\r\n                // If the piece can take pieces horizontally or vertically or king is in range,\r\n                // then the move is not valid\r\n                if (\r\n                    pieceName === \"queen\" ||\r\n                    pieceName === \"castle\" ||\r\n                    (pieceName === \"king\" && (dx === 1 || dy === 1))\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n            // Check if the square is under attack from an opponents piece via diagonal line\r\n            const diagCollisions = checkDiagCollisions(\r\n                state.col,\r\n                state.row,\r\n                boardState,\r\n                {\r\n                    pieceState: {\r\n                        col: opponentKing.col,\r\n                        row: opponentKing.row,\r\n                    },\r\n                },\r\n                true\r\n            );\r\n            if (diagCollisions.piece && !diagCollisions.collision) {\r\n                const pieceName = diagCollisions.piece.split(\"_\")[0];\r\n\r\n                // If the piece can move diagonally or the pawn is in range of square,\r\n                // then the move is not valid\r\n                // negative direction is up the board\r\n                if (\r\n                    pieceName === \"queen\" ||\r\n                    pieceName === \"bishop\" ||\r\n                    (pieceName === \"king\" && dx === 1 && dy === 1) ||\r\n                    (pieceName === \"pawn\" &&\r\n                        dx === 1 &&\r\n                        opponentKing.row - state.row === -1)\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // Check if square is under attack by a knight\r\n            if (\r\n                piece.split(\"_\")[0] === \"knight\" &&\r\n                ((dx === 2 && dy === 1) || (dx === 1 && dy === 2))\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}