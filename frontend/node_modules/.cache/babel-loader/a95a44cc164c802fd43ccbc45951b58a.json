{"ast":null,"code":"import _slicedToArray from\"C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import _defineProperty from\"C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";import _toConsumableArray from\"C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _objectSpread from\"C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";/**\r\n * Callback for setting the board state\r\n *\r\n * @callback setBoardState\r\n * @param {Object} board An dictionary representing the current board state\r\n */ /**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {setBoardState} setBoardState sets a new state of the board\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */export function MovePiece(toX,toY,setBoardState,setTakenPieces,draggedPiece,boardState){var square=GetPieceAtSquare(toX,toY,boardState);var enPassantPawn=CheckIfCanEnPassant(draggedPiece,boardState);// check if piece on square\n// Ensure piece on square is not owned and is alive before taking\nif(square!=null&&!square.isOwner&&square.state.isAlive||enPassantPawn&&enPassantPawn.state.col===toX&&enPassantPawn.state.row-1===toY){var pieceToTake=square!=null?square:enPassantPawn;// Remove piece from board\ndelete boardState[pieceToTake.piece];// Track what pieces are taken so that they can be rendered under player name\nvar pieceNameSplit=pieceToTake.piece.split(\"_\");var piecePathName=pieceNameSplit[0]+\"_\"+pieceNameSplit[1];var pieceImgPath=require(\"../assets/images/pieces/\"+piecePathName+\".png\");var colour;if(pieceNameSplit[1]===\"w\")colour=\"white\";else colour=\"black\";// Sort the array of pieces so that matching pieces appear next to eachother\nsetTakenPieces(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},colour,[].concat(_toConsumableArray(prevState[colour]),[pieceImgPath]).sort()));});}var king=boardState[\"king_w\"].isOwner?\"king_w\":\"king_b\";var properties;// Gets the castle if castling\nvar castleToMove=CheckIfCanCastle(toX,toY,draggedPiece,boardState);if(castleToMove!==null){var _objectSpread3;var newCastleCol=castleToMove.state.col===7?5:3;var newKingCol=newCastleCol===5?6:2;// Moves the king and castle when castling\n/* setBoardState((prevState) => ({\r\n            ...prevState,\r\n            [castleToMove.castleName]: {\r\n                ...boardState[castleToMove.castleName],\r\n                col: newCastleCol,\r\n                hasMoved: true,\r\n            },\r\n            [king]: {\r\n                ...boardState[king],\r\n                col: newKingCol,\r\n                hasMoved: true,\r\n            },\r\n            turn: boardState[\"turn\"] + 1,\r\n        })); */properties=_objectSpread(_objectSpread({},prevState),{},(_objectSpread3={},_defineProperty(_objectSpread3,castleToMove.castleName,_objectSpread(_objectSpread({},boardState[castleToMove.castleName]),{},{col:newCastleCol,hasMoved:true})),_defineProperty(_objectSpread3,king,_objectSpread(_objectSpread({},boardState[king]),{},{col:newKingCol,hasMoved:true})),_defineProperty(_objectSpread3,\"turn\",boardState[\"turn\"]+1),_objectSpread3));}// Update state of the moved piece\n/* else if (draggedPiece.pieceName.split(\"_\")[0] === \"king\") {\r\n        setBoardState((prevState) => ({\r\n            ...prevState,\r\n            [draggedPiece.pieceName]: {\r\n                ...boardState[draggedPiece.pieceName],\r\n                row: toY,\r\n                col: toX,\r\n                hasMoved: true,\r\n                inCheck: false,\r\n            },\r\n            turn: boardState[\"turn\"] + 1,\r\n        }));\r\n    } */else if(draggedPiece.pieceName.split(\"_\")[0]===\"pawn\"){var _objectSpread4;var justMovedTwo=!draggedPiece.pieceState.hasMoved&&draggedPiece.pieceState.row-toY===2;// If the pawn moved two squares then it can be taken via en passant\n// en passant can only happen on the same turn\n/* setBoardState((prevState) => ({\r\n            ...prevState,\r\n            [draggedPiece.pieceName]: {\r\n                ...boardState[draggedPiece.pieceName],\r\n                row: toY,\r\n                col: toX,\r\n                hasMoved: true,\r\n                movedTwoSquaresTurn: justMovedTwo\r\n                    ? boardState[\"turn\"] + 1\r\n                    : null,\r\n            },\r\n            [king]: {\r\n                ...boardState[king],\r\n                inCheck: false,\r\n            },\r\n            turn: boardState[\"turn\"] + 1,\r\n        })); */properties=_objectSpread(_objectSpread({},prevState),{},(_objectSpread4={},_defineProperty(_objectSpread4,draggedPiece.pieceName,_objectSpread(_objectSpread({},boardState[draggedPiece.pieceName]),{},{row:toY,col:toX,hasMoved:true,movedTwoSquaresTurn:justMovedTwo?boardState[\"turn\"]+1:null})),_defineProperty(_objectSpread4,king,_objectSpread(_objectSpread({},boardState[king]),{},{inCheck:false})),_defineProperty(_objectSpread4,\"turn\",boardState[\"turn\"]+1),_objectSpread4));}else{var _objectSpread5;// Moving a piece will always take king out of check\n/* setBoardState((prevState) => ({\r\n            ...prevState,\r\n            [draggedPiece.pieceName]: {\r\n                ...boardState[draggedPiece.pieceName],\r\n                row: toY,\r\n                col: toX,\r\n                hasMoved: true,\r\n            },\r\n            [king]: {\r\n                ...boardState[king],\r\n                inCheck: false,\r\n            },\r\n            turn: boardState[\"turn\"] + 1,\r\n        })); */properties=_objectSpread(_objectSpread({},prevState),{},(_objectSpread5={},_defineProperty(_objectSpread5,draggedPiece.pieceName,_objectSpread(_objectSpread({},boardState[draggedPiece.pieceName]),{},{row:toY,col:toX,hasMoved:true})),_defineProperty(_objectSpread5,king,_objectSpread(_objectSpread({},boardState[king]),{},{inCheck:false})),_defineProperty(_objectSpread5,\"turn\",boardState[\"turn\"]+1),_objectSpread5));}setBoardState(function(prevState){return{properties:properties};});}/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */export function CanMovePiece(toX,toY,draggedPiece,boardState){var square=GetPieceAtSquare(toX,toY,boardState);// if a friendly piece is in a square, don't allow this piece to be moved there\nif(square&&square.state.isOwner&&square.state.isAlive)return false;// calculate the difference between the new square and the piece being dragged\nvar dx=Math.abs(toX-draggedPiece.pieceState.col);var dy=Math.abs(toY-draggedPiece.pieceState.row);var pieceName=draggedPiece.pieceName.split(\"_\")[0];// Check the row and column of the piece to see if the movement should be blocked\n// by another piece\nvar straightCollision=CheckStraightCollisions(toX,toY,boardState,draggedPiece);// Check the diagonal of the piece to see if the movement should be blocked\n// by another piece\nvar diagCollision=CheckDiagCollisions(toX,toY,boardState,draggedPiece);// Checks if the move will block the piece attacking the king\nvar pieceCheckingKing=CheckIfPieceIsProtectingKing(toX,toY,boardState,draggedPiece.pieceName);// Get the players king\nvar king=boardState[\"king_w\"].isOwner?boardState[\"king_w\"]:boardState[\"king_b\"];var piecePuttingKingInCheck,cantMoveToProtectKing;if(king.inCheck){// Gets the piece that is putting the king in check\npiecePuttingKingInCheck=CheckIfMoveUnderAttack(king.col,king.row,boardState);var pieceAttackingKingNotAtSquare=square!==null&&square.piece!==piecePuttingKingInCheck;// Move must protect king if king is in check\ncantMoveToProtectKing=king.inCheck&&(pieceCheckingKing===null&&pieceAttackingKingNotAtSquare||pieceCheckingKing===null&&square===null);}var isProtectingKing;if(pieceName!==\"king\"){// Check if the piece is defending the king\n// Get the piece that is attacking the king if true\nvar pieceAttackingKing=CheckIfPieceIsProtectingKing(draggedPiece.pieceState.col,draggedPiece.pieceState.row,boardState,draggedPiece.pieceName);// Check if the piece is currently under attack\nvar isPieceUnderAttack=CheckIfMoveUnderAttack(draggedPiece.pieceState.col,draggedPiece.pieceState.row,boardState)!==null;isProtectingKing=pieceAttackingKing!==null&&isPieceUnderAttack;}var cantMoveWhilstProtecting=function cantMoveWhilstProtecting(){// Dont allow the pawn to move if its protecting king unless it can take the piece\n// and ensure that the piece is alive before taking\nif(isProtectingKing&&(square&&pieceCheckingKing!==square.piece||square===null||square&&!square.state.isAlive))return true;return false;};switch(pieceName){case\"king\":var moveUnderAttack=CheckIfMoveUnderAttack(toX,toY,boardState,draggedPiece.pieceName);var moveNotInCheck=moveUnderAttack===null||square&&square.piece===moveUnderAttack;var canCastle=CheckIfCanCastle(toX,toY,draggedPiece,boardState);return((dx===1||dx===0)&&(dy===1||dy===0)||canCastle&&dx===2&&dy===0)&&moveNotInCheck;case\"castle\":if(cantMoveWhilstProtecting())return;if(cantMoveToProtectKing)return;return(dx===0&&dy>0||dx>0&&dy===0)&&!straightCollision.collision;case\"knight\":if(cantMoveWhilstProtecting())return;if(cantMoveToProtectKing)return;return dx===2&&dy===1||dx===1&&dy===2;case\"bishop\":if(cantMoveWhilstProtecting())return;if(cantMoveToProtectKing)return;return!(dx===0&&dy>0)&&!(dx>0&&dy===0)&&(dx===dy||dx===dy)&&!diagCollision.collision;case\"queen\":if(cantMoveWhilstProtecting())return;if(cantMoveToProtectKing)return;return(dx===0&&dy>0||dx>0&&dy===0)&&!straightCollision.collision||(dx===dy||dx===dy)&&!diagCollision.collision;case\"pawn\":if(cantMoveWhilstProtecting())return;if(cantMoveToProtectKing)return;// Gets the pawn that can be taken via en passant\nvar enPassantPawn=CheckIfCanEnPassant(draggedPiece,boardState);// Recalculate dx/dy with direction\ndx=toX-draggedPiece.pieceState.col;dy=toY-draggedPiece.pieceState.row;// Allow pawn to move 2 squares on first move\nif(!draggedPiece.pieceState.hasMoved){// Negative direction moves up the board (player always at bottom)\nif(dx===0&&(dy===-1||dy===-2)&&!straightCollision.collision){return square===null;}}// Allow pawn to take opponents pawn via en passant\nif(enPassantPawn&&toX===enPassantPawn.state.col&&toY===enPassantPawn.state.row-1)return true;if((dx===1||dx===-1)&&dy===-1&&square!==null)// Allow pawn to take opponents pieces diagonal by 1 square\nreturn true;// Allow pawn to move forward by 1 square\nreturn dx===0&&dy===-1&&square===null;default:return false;}}/**\r\n * Checks if the current square is empty\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @returns piece name and state if square is not empty, null otherwise\r\n */function GetPieceAtSquare(x,y,boardState){for(var _i=0,_Object$entries=Object.entries(boardState);_i<_Object$entries.length;_i++){var _Object$entries$_i=_slicedToArray(_Object$entries[_i],2),piece=_Object$entries$_i[0],state=_Object$entries$_i[1];if(x===state.col&&y===state.row){return{piece:piece,state:state};}}return null;}/**\r\n * Checks if there is a piece in the diagonal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece contains data about the currently dragged piece\r\n * @param {boolean} checkForOpponentPiece if true, the check will be on behalf of the opponent\r\n * @returns piece and false if an opponents piece is inbetween the square and the currently dragged piece, piece and true otherwise\r\n */function CheckDiagCollisions(x,y,boardState,draggedPiece){var checkForOpponentPiece=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;// Get row and col of dragged piece\nvar row=draggedPiece.pieceState.row;var col=draggedPiece.pieceState.col;var dirX=Math.sign(x-col);var dirY=Math.sign(y-row);for(var i=0;i<Math.abs(x-col)+1;i++){for(var _i2=0,_Object$entries2=Object.entries(boardState);_i2<_Object$entries2.length;_i2++){var _Object$entries2$_i=_slicedToArray(_Object$entries2[_i2],2),piece=_Object$entries2$_i[0],state=_Object$entries2$_i[1];// Dont include collisions with self\nif(piece!==draggedPiece.pieceName){var owner=checkForOpponentPiece?!state.isOwner:state.isOwner;if(col+i*dirX===state.col&&row+i*dirY===state.row&&state.isAlive&&(i===0&&!owner||i!==0)){if(i!==Math.abs(x-col)){// Stops opponents pieces from being taken when hidden behind each other\nreturn{piece:piece,collision:true};}return{piece:piece,collision:owner};}}}}return{piece:null,collision:false};}/**\r\n * Checks if there is a piece in the vertical and horizontal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece contains data about the currently dragged piece\r\n * @param {boolean} checkForOpponentPiece if true, the check will be on behalf of the opponent\r\n * @returns true and the piece name if an opponents piece is inbetween the square and the currently dragged piece, false and null otherwise\r\n */function CheckStraightCollisions(x,y,boardState,draggedPiece){var checkForOpponentPiece=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;// Get row and col of dragged piece\nvar row=draggedPiece.pieceState.row;var col=draggedPiece.pieceState.col;// Get change in x and y between dragged piece and square\nvar dx=Math.abs(x-col);var dy=Math.abs(y-row);// Ignore diagonal moves\nif(dx>0&&dy>0)return true;// get direction of move\nvar dirX=Math.sign(x-col);var dirY=Math.sign(y-row);for(var i=1;i<Math.max(dx,dy)+1;i++){for(var _i3=0,_Object$entries3=Object.entries(boardState);_i3<_Object$entries3.length;_i3++){var _Object$entries3$_i=_slicedToArray(_Object$entries3[_i3],2),piece=_Object$entries3$_i[0],state=_Object$entries3$_i[1];// Dont include collisions with self\nif(piece!==draggedPiece.pieceName){if(state.isAlive){// Move is horizontal if dy = 0, otherwise vertical\nif(dy===0){if(col+i*dirX===state.col&&row===state.row){if(i!==Math.abs(x-col)){// Stops opponents pieces from being taken when hidden behind each other\nreturn{piece:piece,collision:true};}return{piece:piece,collision:checkForOpponentPiece?!state.isOwner:state.isOwner};}}else{if(row+i*dirY===state.row&&col===state.col){if(i!==Math.abs(y-row)){// Stops opponents pieces from being taken when hidden behind each other\nreturn{piece:piece,collision:true};}return{piece:piece,collision:checkForOpponentPiece?!state.isOwner:state.isOwner};}}}}}}return{piece:null,collision:false};}/**\r\n * Checks if a piece at (x,y) on the board is under attack by an opponents piece\r\n * @param {*} x x coordinate of the square currently being checked\r\n * @param {*} y y coordinate of the square currently being checked\r\n * @param {*} boardState current state of the board\r\n * @returns piece name if the piece is under attack, null otherwise\r\n */function CheckIfMoveUnderAttack(x,y,boardState){var pieceToMove=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;for(var _i4=0,_Object$entries4=Object.entries(boardState);_i4<_Object$entries4.length;_i4++){var _Object$entries4$_i=_slicedToArray(_Object$entries4[_i4],2),piece=_Object$entries4$_i[0],state=_Object$entries4$_i[1];// King cannot be checked by its own pieces\nif(!state.isOwner){var dx=Math.abs(x-state.col);var dy=Math.abs(y-state.row);// Check if the square is under attack from an opponents piece via straight line\nvar straightCollisions=CheckStraightCollisions(state.col,state.row,boardState,{pieceName:pieceToMove,pieceState:{col:x,row:y}});if(straightCollisions.piece&&!straightCollisions.collision){var pieceName=straightCollisions.piece.split(\"_\")[0];// If the piece can take pieces horizontally or vertically or king is in range,\n// then the move is not valid\nif(pieceName===\"queen\"||pieceName===\"castle\"||pieceName===\"king\"&&(dx===1||dy===1)){//return true;\nreturn straightCollisions.piece;}}// Check if the square is under attack from an opponents piece via diagonal line\nvar diagCollisions=CheckDiagCollisions(state.col,state.row,boardState,{pieceName:pieceToMove,pieceState:{col:x,row:y}});if(diagCollisions.piece&&diagCollisions.piece!==pieceToMove&&!diagCollisions.collision){// Dont include collisions with self\nif(diagCollisions.piece===pieceToMove)return null;var _pieceName=diagCollisions.piece.split(\"_\")[0];// If the piece can move diagonally or the pawn is in range of square,\n// then the move is not valid\nif(_pieceName===\"queen\"||_pieceName===\"bishop\"||_pieceName===\"king\"&&dx===1&&dy===1||_pieceName===\"pawn\"&&dx===1&&y-state.row===1){//return true;\nreturn diagCollisions.piece;}}// Check if square is under attack by a knight\nif(piece.split(\"_\")[0]===\"knight\"&&(dx===2&&dy===1||dx===1&&dy===2)){return piece;}}}return null;}/**\r\n * Check if the piece at (x,y) on the board is blocking an opponent piece from checking the king\r\n * @param {*} x x coordinate of the square currently being checked\r\n * @param {*} y y coordinate of the square currently being checked\r\n * @param {*} boardState current state of the board\r\n * @param {*} draggedPiece piece being dragged\r\n * @returns name of piece attacking king, if no such piece exists, return null\r\n */function CheckIfPieceIsProtectingKing(x,y,boardState,draggedPiece){// Get players king\nvar king=boardState[\"king_w\"].isOwner?boardState[\"king_w\"]:boardState[\"king_b\"];// Direction from (x,y) to king\nvar dirX=Math.sign(x-king.col);var dirY=Math.sign(y-king.row);if(dirX===0&&dirY===0)return null;var dx=Math.abs(king.col-x);var dy=Math.abs(king.row-y);var getOppositeCoords=function getOppositeCoords(king){var oppositeX=king.col;var oppositeY=king.row;// Get the x,y in the opposite direction to the king to the edge of the board\nwhile(oppositeX<=7&&oppositeX>=0&&oppositeY<=7&&oppositeY>=0){oppositeX+=dirX;oppositeY+=dirY;}return[oppositeX,oppositeY];};// Check pieces that are directly above or beside the king\nif(dx===0||(dirX===1||dirX===-1)&&dy===0){// Check if piece is inbetween king and opponent piece that can attack king\nvar straightCollisions=CheckStraightCollisions(x,y,boardState,{pieceState:{col:king.col,row:king.row}});// A piece is inbetween the dragged piece and the king,\n// therefore, it is not protecting the king and can be moved\nif(straightCollisions.collision&&straightCollisions.piece!==draggedPiece)return null;var _getOppositeCoords=getOppositeCoords(king),_getOppositeCoords2=_slicedToArray(_getOppositeCoords,2),oppositeX=_getOppositeCoords2[0],oppositeY=_getOppositeCoords2[1];var oppositeStraightCollisions=CheckStraightCollisions(oppositeX,oppositeY,boardState,{pieceState:{col:x,row:y}});if(oppositeStraightCollisions.piece&&!boardState[oppositeStraightCollisions.piece].isOwner){var pieceName=oppositeStraightCollisions.piece.split(\"_\")[0];// If the piece in opposite direction to king is able to attack the king\n// once the dragged piece is moved, then don't allow the piece to be moved\nif(pieceName===\"castle\"||pieceName===\"queen\"){// the piece is protecting the king\nreturn oppositeStraightCollisions.piece;}}}else if(dx===dy){// Check the pieces directly diagonal to the king\n// Check if piece is inbetween king and opponent piece that can attack king\nvar diagCollisions=CheckDiagCollisions(x,y,boardState,{pieceState:{col:king.col,row:king.row}});// A piece is inbetween the dragged piece and the king,\n// therefore, it is not protecting the king and can be moved\nif(diagCollisions.collision&&diagCollisions.piece!==draggedPiece)return null;var _getOppositeCoords3=getOppositeCoords(king),_getOppositeCoords4=_slicedToArray(_getOppositeCoords3,2),_oppositeX=_getOppositeCoords4[0],_oppositeY=_getOppositeCoords4[1];var oppositeDiagCollisions=CheckDiagCollisions(_oppositeX,_oppositeY,boardState,{pieceState:{col:x,row:y}});if(oppositeDiagCollisions.piece&&!boardState[oppositeDiagCollisions.piece].isOwner){var _pieceName2=oppositeDiagCollisions.piece.split(\"_\")[0];// If the piece in opposite direction to king is able to attack the king\n// once the dragged piece is moved, then don't allow the piece to be moved\nvar signDx=king.col-x;var signDy=king.col-x;if(_pieceName2===\"bishop\"||_pieceName2===\"queen\"||_pieceName2===\"pawn\"&&(signDx===1||signDx===-1)&&signDy===-1){// the piece is protecting the king\nreturn oppositeDiagCollisions.piece;}}}return null;}/**\r\n * Checks if a piece at (x,y) on the board is under attack by an opponents piece\r\n * @param {*} boardState current state of the board\r\n * @returns true if the piece is under attack, false otherwise\r\n */export function CheckIfOpponentInCheck(boardState,opponentKing){for(var _i5=0,_Object$entries5=Object.entries(boardState);_i5<_Object$entries5.length;_i5++){var _Object$entries5$_i=_slicedToArray(_Object$entries5[_i5],2),piece=_Object$entries5$_i[0],state=_Object$entries5$_i[1];// King cannot be checked by its own pieces\nif(state.isOwner){var dx=Math.abs(opponentKing.col-state.col);var dy=Math.abs(opponentKing.row-state.row);// Check if the square is under attack from an opponents piece via straight line\nvar straightCollisions=CheckStraightCollisions(state.col,state.row,boardState,{pieceState:{col:opponentKing.col,row:opponentKing.row}},true);if(straightCollisions.piece&&!straightCollisions.collision){var pieceName=straightCollisions.piece.split(\"_\")[0];// If the piece can take pieces horizontally or vertically or king is in range,\n// then the move is not valid\nif(pieceName===\"queen\"||pieceName===\"castle\"||pieceName===\"king\"&&(dx===1||dy===1)){return true;}}// Check if the square is under attack from an opponents piece via diagonal line\nvar diagCollisions=CheckDiagCollisions(state.col,state.row,boardState,{pieceState:{col:opponentKing.col,row:opponentKing.row}},true);if(diagCollisions.piece&&!diagCollisions.collision){var _pieceName3=diagCollisions.piece.split(\"_\")[0];// If the piece can move diagonally or the pawn is in range of square,\n// then the move is not valid\n// negative direction is up the board\nif(_pieceName3===\"queen\"||_pieceName3===\"bishop\"||_pieceName3===\"king\"&&dx===1&&dy===1||_pieceName3===\"pawn\"&&dx===1&&opponentKing.row-state.row===-1){return true;}}// Check if square is under attack by a knight\nif(piece.split(\"_\")[0]===\"knight\"&&(dx===2&&dy===1||dx===1&&dy===2)){return true;}}}return false;}function CheckIfCanCastle(x,y,draggedPiece,boardState){var pieceName=draggedPiece.pieceName.split(\"_\")[0];var pieceColour=draggedPiece.pieceName.split(\"_\")[1];if(pieceName===\"king\"&&!draggedPiece.pieceState.hasBeenInCheck&&!draggedPiece.pieceState.hasMoved){var castle_1=boardState[\"castle_\"+pieceColour+\"_1\"];var castle_2=boardState[\"castle_\"+pieceColour+\"_2\"];// Ensure move is at correct square, castle hasnt moved and there is no pieces\n// inbetween the king and castle\nif(x===2&&y===7&&castle_1&&!castle_1.hasMoved&&!GetPieceAtSquare(1,7,boardState)&&!GetPieceAtSquare(2,7,boardState)&&!GetPieceAtSquare(3,7,boardState)){return{castleName:\"castle_\"+pieceColour+\"_1\",state:castle_1};}else if(x===6&&y===7&&castle_2&&!castle_2.hasMoved&&!GetPieceAtSquare(6,7,boardState)&&!GetPieceAtSquare(5,7,boardState)){return{castleName:\"castle_\"+pieceColour+\"_2\",state:castle_2};}}return null;}function CheckIfCanEnPassant(draggedPiece,boardState){// Only a pawn can en passant\nif(draggedPiece.pieceName.split(\"_\")[0]!==\"pawn\")return null;var pawnOnLeft=GetPieceAtSquare(draggedPiece.pieceState.col-1,draggedPiece.pieceState.row,boardState);var pawnOnRight=GetPieceAtSquare(draggedPiece.pieceState.col+1,draggedPiece.pieceState.row,boardState);if(pawnOnLeft&&pawnOnLeft.state.movedTwoSquaresTurn===boardState[\"turn\"]){return pawnOnLeft;}if(pawnOnRight&&pawnOnRight.state.movedTwoSquaresTurn===boardState[\"turn\"]){return pawnOnRight;}return null;}","map":{"version":3,"names":["MovePiece","toX","toY","setBoardState","setTakenPieces","draggedPiece","boardState","square","GetPieceAtSquare","enPassantPawn","CheckIfCanEnPassant","isOwner","state","isAlive","col","row","pieceToTake","piece","pieceNameSplit","split","piecePathName","pieceImgPath","require","colour","prevState","sort","king","properties","castleToMove","CheckIfCanCastle","newCastleCol","newKingCol","castleName","hasMoved","pieceName","justMovedTwo","pieceState","movedTwoSquaresTurn","inCheck","CanMovePiece","dx","Math","abs","dy","straightCollision","CheckStraightCollisions","diagCollision","CheckDiagCollisions","pieceCheckingKing","CheckIfPieceIsProtectingKing","piecePuttingKingInCheck","cantMoveToProtectKing","CheckIfMoveUnderAttack","pieceAttackingKingNotAtSquare","isProtectingKing","pieceAttackingKing","isPieceUnderAttack","cantMoveWhilstProtecting","moveUnderAttack","moveNotInCheck","canCastle","collision","x","y","Object","entries","checkForOpponentPiece","dirX","sign","dirY","i","owner","max","pieceToMove","straightCollisions","diagCollisions","getOppositeCoords","oppositeX","oppositeY","oppositeStraightCollisions","oppositeDiagCollisions","signDx","signDy","CheckIfOpponentInCheck","opponentKing","pieceColour","hasBeenInCheck","castle_1","castle_2","pawnOnLeft","pawnOnRight"],"sources":["C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/src/components/Game.js"],"sourcesContent":["/**\r\n * Callback for setting the board state\r\n *\r\n * @callback setBoardState\r\n * @param {Object} board An dictionary representing the current board state\r\n */\r\n\r\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {setBoardState} setBoardState sets a new state of the board\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\r\nexport function MovePiece(\r\n    toX,\r\n    toY,\r\n    setBoardState,\r\n    setTakenPieces,\r\n    draggedPiece,\r\n    boardState\r\n) {\r\n    const square = GetPieceAtSquare(toX, toY, boardState);\r\n    const enPassantPawn = CheckIfCanEnPassant(draggedPiece, boardState);\r\n\r\n    // check if piece on square\r\n    // Ensure piece on square is not owned and is alive before taking\r\n    if (\r\n        (square != null && !square.isOwner && square.state.isAlive) ||\r\n        (enPassantPawn &&\r\n            enPassantPawn.state.col === toX &&\r\n            enPassantPawn.state.row - 1 === toY)\r\n    ) {\r\n        const pieceToTake = square != null ? square : enPassantPawn;\r\n        // Remove piece from board\r\n        delete boardState[pieceToTake.piece];\r\n\r\n        // Track what pieces are taken so that they can be rendered under player name\r\n        const pieceNameSplit = pieceToTake.piece.split(\"_\");\r\n        const piecePathName = pieceNameSplit[0] + \"_\" + pieceNameSplit[1];\r\n        const pieceImgPath = require(\"../assets/images/pieces/\" +\r\n            piecePathName +\r\n            \".png\");\r\n\r\n        let colour;\r\n        if (pieceNameSplit[1] === \"w\") colour = \"white\";\r\n        else colour = \"black\";\r\n        // Sort the array of pieces so that matching pieces appear next to eachother\r\n        setTakenPieces((prevState) => ({\r\n            ...prevState,\r\n            [colour]: [...prevState[colour], pieceImgPath].sort(),\r\n        }));\r\n    }\r\n\r\n    const king = boardState[\"king_w\"].isOwner ? \"king_w\" : \"king_b\";\r\n\r\n    let properties;\r\n    // Gets the castle if castling\r\n    const castleToMove = CheckIfCanCastle(toX, toY, draggedPiece, boardState);\r\n    if (castleToMove !== null) {\r\n        const newCastleCol = castleToMove.state.col === 7 ? 5 : 3;\r\n        const newKingCol = newCastleCol === 5 ? 6 : 2;\r\n        // Moves the king and castle when castling\r\n        /* setBoardState((prevState) => ({\r\n            ...prevState,\r\n            [castleToMove.castleName]: {\r\n                ...boardState[castleToMove.castleName],\r\n                col: newCastleCol,\r\n                hasMoved: true,\r\n            },\r\n            [king]: {\r\n                ...boardState[king],\r\n                col: newKingCol,\r\n                hasMoved: true,\r\n            },\r\n            turn: boardState[\"turn\"] + 1,\r\n        })); */\r\n        properties = {\r\n            ...prevState,\r\n            [castleToMove.castleName]: {\r\n                ...boardState[castleToMove.castleName],\r\n                col: newCastleCol,\r\n                hasMoved: true,\r\n            },\r\n            [king]: {\r\n                ...boardState[king],\r\n                col: newKingCol,\r\n                hasMoved: true,\r\n            },\r\n            turn: boardState[\"turn\"] + 1,\r\n        };\r\n    }\r\n    // Update state of the moved piece\r\n    /* else if (draggedPiece.pieceName.split(\"_\")[0] === \"king\") {\r\n        setBoardState((prevState) => ({\r\n            ...prevState,\r\n            [draggedPiece.pieceName]: {\r\n                ...boardState[draggedPiece.pieceName],\r\n                row: toY,\r\n                col: toX,\r\n                hasMoved: true,\r\n                inCheck: false,\r\n            },\r\n            turn: boardState[\"turn\"] + 1,\r\n        }));\r\n    } */\r\n    else if (draggedPiece.pieceName.split(\"_\")[0] === \"pawn\") {\r\n        const justMovedTwo =\r\n            !draggedPiece.pieceState.hasMoved &&\r\n            draggedPiece.pieceState.row - toY === 2;\r\n        // If the pawn moved two squares then it can be taken via en passant\r\n        // en passant can only happen on the same turn\r\n        /* setBoardState((prevState) => ({\r\n            ...prevState,\r\n            [draggedPiece.pieceName]: {\r\n                ...boardState[draggedPiece.pieceName],\r\n                row: toY,\r\n                col: toX,\r\n                hasMoved: true,\r\n                movedTwoSquaresTurn: justMovedTwo\r\n                    ? boardState[\"turn\"] + 1\r\n                    : null,\r\n            },\r\n            [king]: {\r\n                ...boardState[king],\r\n                inCheck: false,\r\n            },\r\n            turn: boardState[\"turn\"] + 1,\r\n        })); */\r\n        properties = {\r\n            ...prevState,\r\n            [draggedPiece.pieceName]: {\r\n                ...boardState[draggedPiece.pieceName],\r\n                row: toY,\r\n                col: toX,\r\n                hasMoved: true,\r\n                movedTwoSquaresTurn: justMovedTwo\r\n                    ? boardState[\"turn\"] + 1\r\n                    : null,\r\n            },\r\n            [king]: {\r\n                ...boardState[king],\r\n                inCheck: false,\r\n            },\r\n            turn: boardState[\"turn\"] + 1,\r\n        };\r\n    } else {\r\n        // Moving a piece will always take king out of check\r\n        /* setBoardState((prevState) => ({\r\n            ...prevState,\r\n            [draggedPiece.pieceName]: {\r\n                ...boardState[draggedPiece.pieceName],\r\n                row: toY,\r\n                col: toX,\r\n                hasMoved: true,\r\n            },\r\n            [king]: {\r\n                ...boardState[king],\r\n                inCheck: false,\r\n            },\r\n            turn: boardState[\"turn\"] + 1,\r\n        })); */\r\n        properties = {\r\n            ...prevState,\r\n            [draggedPiece.pieceName]: {\r\n                ...boardState[draggedPiece.pieceName],\r\n                row: toY,\r\n                col: toX,\r\n                hasMoved: true,\r\n            },\r\n            [king]: {\r\n                ...boardState[king],\r\n                inCheck: false,\r\n            },\r\n            turn: boardState[\"turn\"] + 1,\r\n        };\r\n    }\r\n\r\n    setBoardState((prevState) => ({\r\n        properties,\r\n    }));\r\n}\r\n\r\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\r\nexport function CanMovePiece(toX, toY, draggedPiece, boardState) {\r\n    const square = GetPieceAtSquare(toX, toY, boardState);\r\n\r\n    // if a friendly piece is in a square, don't allow this piece to be moved there\r\n    if (square && square.state.isOwner && square.state.isAlive) return false;\r\n\r\n    // calculate the difference between the new square and the piece being dragged\r\n    let dx = Math.abs(toX - draggedPiece.pieceState.col);\r\n    let dy = Math.abs(toY - draggedPiece.pieceState.row);\r\n\r\n    const pieceName = draggedPiece.pieceName.split(\"_\")[0];\r\n\r\n    // Check the row and column of the piece to see if the movement should be blocked\r\n    // by another piece\r\n    const straightCollision = CheckStraightCollisions(\r\n        toX,\r\n        toY,\r\n        boardState,\r\n        draggedPiece\r\n    );\r\n    // Check the diagonal of the piece to see if the movement should be blocked\r\n    // by another piece\r\n    const diagCollision = CheckDiagCollisions(\r\n        toX,\r\n        toY,\r\n        boardState,\r\n        draggedPiece\r\n    );\r\n\r\n    // Checks if the move will block the piece attacking the king\r\n    const pieceCheckingKing = CheckIfPieceIsProtectingKing(\r\n        toX,\r\n        toY,\r\n        boardState,\r\n        draggedPiece.pieceName\r\n    );\r\n\r\n    // Get the players king\r\n    const king = boardState[\"king_w\"].isOwner\r\n        ? boardState[\"king_w\"]\r\n        : boardState[\"king_b\"];\r\n\r\n    let piecePuttingKingInCheck, cantMoveToProtectKing;\r\n    if (king.inCheck) {\r\n        // Gets the piece that is putting the king in check\r\n        piecePuttingKingInCheck = CheckIfMoveUnderAttack(\r\n            king.col,\r\n            king.row,\r\n            boardState\r\n        );\r\n\r\n        const pieceAttackingKingNotAtSquare =\r\n            square !== null && square.piece !== piecePuttingKingInCheck;\r\n        // Move must protect king if king is in check\r\n        cantMoveToProtectKing =\r\n            king.inCheck &&\r\n            ((pieceCheckingKing === null && pieceAttackingKingNotAtSquare) ||\r\n                (pieceCheckingKing === null && square === null));\r\n    }\r\n\r\n    let isProtectingKing;\r\n    if (pieceName !== \"king\") {\r\n        // Check if the piece is defending the king\r\n        // Get the piece that is attacking the king if true\r\n        const pieceAttackingKing = CheckIfPieceIsProtectingKing(\r\n            draggedPiece.pieceState.col,\r\n            draggedPiece.pieceState.row,\r\n            boardState,\r\n            draggedPiece.pieceName\r\n        );\r\n        // Check if the piece is currently under attack\r\n        const isPieceUnderAttack =\r\n            CheckIfMoveUnderAttack(\r\n                draggedPiece.pieceState.col,\r\n                draggedPiece.pieceState.row,\r\n                boardState\r\n            ) !== null;\r\n        isProtectingKing = pieceAttackingKing !== null && isPieceUnderAttack;\r\n    }\r\n\r\n    const cantMoveWhilstProtecting = () => {\r\n        // Dont allow the pawn to move if its protecting king unless it can take the piece\r\n        // and ensure that the piece is alive before taking\r\n        if (\r\n            isProtectingKing &&\r\n            ((square && pieceCheckingKing !== square.piece) ||\r\n                square === null ||\r\n                (square && !square.state.isAlive))\r\n        )\r\n            return true;\r\n        return false;\r\n    };\r\n\r\n    switch (pieceName) {\r\n        case \"king\":\r\n            const moveUnderAttack = CheckIfMoveUnderAttack(\r\n                toX,\r\n                toY,\r\n                boardState,\r\n                draggedPiece.pieceName\r\n            );\r\n            const moveNotInCheck =\r\n                moveUnderAttack === null ||\r\n                (square && square.piece === moveUnderAttack);\r\n            const canCastle = CheckIfCanCastle(\r\n                toX,\r\n                toY,\r\n                draggedPiece,\r\n                boardState\r\n            );\r\n            return (\r\n                (((dx === 1 || dx === 0) && (dy === 1 || dy === 0)) ||\r\n                    (canCastle && dx === 2 && dy === 0)) &&\r\n                moveNotInCheck\r\n            );\r\n\r\n        case \"castle\":\r\n            if (cantMoveWhilstProtecting()) return;\r\n            if (cantMoveToProtectKing) return;\r\n            return (\r\n                ((dx === 0 && dy > 0) || (dx > 0 && dy === 0)) &&\r\n                !straightCollision.collision\r\n            );\r\n\r\n        case \"knight\":\r\n            if (cantMoveWhilstProtecting()) return;\r\n            if (cantMoveToProtectKing) return;\r\n            return (dx === 2 && dy === 1) || (dx === 1 && dy === 2);\r\n\r\n        case \"bishop\":\r\n            if (cantMoveWhilstProtecting()) return;\r\n            if (cantMoveToProtectKing) return;\r\n            return (\r\n                !(dx === 0 && dy > 0) &&\r\n                !(dx > 0 && dy === 0) &&\r\n                (dx === dy || dx === dy) &&\r\n                !diagCollision.collision\r\n            );\r\n\r\n        case \"queen\":\r\n            if (cantMoveWhilstProtecting()) return;\r\n            if (cantMoveToProtectKing) return;\r\n\r\n            return (\r\n                (((dx === 0 && dy > 0) || (dx > 0 && dy === 0)) &&\r\n                    !straightCollision.collision) ||\r\n                ((dx === dy || dx === dy) && !diagCollision.collision)\r\n            );\r\n\r\n        case \"pawn\":\r\n            if (cantMoveWhilstProtecting()) return;\r\n            if (cantMoveToProtectKing) return;\r\n\r\n            // Gets the pawn that can be taken via en passant\r\n            const enPassantPawn = CheckIfCanEnPassant(draggedPiece, boardState);\r\n\r\n            // Recalculate dx/dy with direction\r\n            dx = toX - draggedPiece.pieceState.col;\r\n            dy = toY - draggedPiece.pieceState.row;\r\n            // Allow pawn to move 2 squares on first move\r\n            if (!draggedPiece.pieceState.hasMoved) {\r\n                // Negative direction moves up the board (player always at bottom)\r\n                if (\r\n                    dx === 0 &&\r\n                    (dy === -1 || dy === -2) &&\r\n                    !straightCollision.collision\r\n                ) {\r\n                    return square === null;\r\n                }\r\n            }\r\n\r\n            // Allow pawn to take opponents pawn via en passant\r\n            if (\r\n                enPassantPawn &&\r\n                toX === enPassantPawn.state.col &&\r\n                toY === enPassantPawn.state.row - 1\r\n            )\r\n                return true;\r\n\r\n            if ((dx === 1 || dx === -1) && dy === -1 && square !== null)\r\n                // Allow pawn to take opponents pieces diagonal by 1 square\r\n                return true;\r\n\r\n            // Allow pawn to move forward by 1 square\r\n            return dx === 0 && dy === -1 && square === null;\r\n\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if the current square is empty\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @returns piece name and state if square is not empty, null otherwise\r\n */\r\nfunction GetPieceAtSquare(x, y, boardState) {\r\n    for (const [piece, state] of Object.entries(boardState)) {\r\n        if (x === state.col && y === state.row) {\r\n            return { piece, state };\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks if there is a piece in the diagonal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece contains data about the currently dragged piece\r\n * @param {boolean} checkForOpponentPiece if true, the check will be on behalf of the opponent\r\n * @returns piece and false if an opponents piece is inbetween the square and the currently dragged piece, piece and true otherwise\r\n */\r\nfunction CheckDiagCollisions(\r\n    x,\r\n    y,\r\n    boardState,\r\n    draggedPiece,\r\n    checkForOpponentPiece = false\r\n) {\r\n    // Get row and col of dragged piece\r\n    const row = draggedPiece.pieceState.row;\r\n    const col = draggedPiece.pieceState.col;\r\n\r\n    const dirX = Math.sign(x - col);\r\n    const dirY = Math.sign(y - row);\r\n    for (let i = 0; i < Math.abs(x - col) + 1; i++) {\r\n        for (const [piece, state] of Object.entries(boardState)) {\r\n            // Dont include collisions with self\r\n            if (piece !== draggedPiece.pieceName) {\r\n                const owner = checkForOpponentPiece\r\n                    ? !state.isOwner\r\n                    : state.isOwner;\r\n                if (\r\n                    col + i * dirX === state.col &&\r\n                    row + i * dirY === state.row &&\r\n                    state.isAlive &&\r\n                    ((i === 0 && !owner) || i !== 0)\r\n                ) {\r\n                    if (i !== Math.abs(x - col)) {\r\n                        // Stops opponents pieces from being taken when hidden behind each other\r\n                        return {\r\n                            piece: piece,\r\n                            collision: true,\r\n                        };\r\n                    }\r\n                    return {\r\n                        piece: piece,\r\n                        collision: owner,\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return { piece: null, collision: false };\r\n}\r\n\r\n/**\r\n * Checks if there is a piece in the vertical and horizontal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece contains data about the currently dragged piece\r\n * @param {boolean} checkForOpponentPiece if true, the check will be on behalf of the opponent\r\n * @returns true and the piece name if an opponents piece is inbetween the square and the currently dragged piece, false and null otherwise\r\n */\r\nfunction CheckStraightCollisions(\r\n    x,\r\n    y,\r\n    boardState,\r\n    draggedPiece,\r\n    checkForOpponentPiece = false\r\n) {\r\n    // Get row and col of dragged piece\r\n    const row = draggedPiece.pieceState.row;\r\n    const col = draggedPiece.pieceState.col;\r\n    // Get change in x and y between dragged piece and square\r\n    const dx = Math.abs(x - col);\r\n    const dy = Math.abs(y - row);\r\n\r\n    // Ignore diagonal moves\r\n    if (dx > 0 && dy > 0) return true;\r\n\r\n    // get direction of move\r\n    const dirX = Math.sign(x - col);\r\n    const dirY = Math.sign(y - row);\r\n\r\n    for (let i = 1; i < Math.max(dx, dy) + 1; i++) {\r\n        for (const [piece, state] of Object.entries(boardState)) {\r\n            // Dont include collisions with self\r\n            if (piece !== draggedPiece.pieceName) {\r\n                if (state.isAlive) {\r\n                    // Move is horizontal if dy = 0, otherwise vertical\r\n                    if (dy === 0) {\r\n                        if (col + i * dirX === state.col && row === state.row) {\r\n                            if (i !== Math.abs(x - col)) {\r\n                                // Stops opponents pieces from being taken when hidden behind each other\r\n                                return {\r\n                                    piece: piece,\r\n                                    collision: true,\r\n                                };\r\n                            }\r\n                            return {\r\n                                piece: piece,\r\n                                collision: checkForOpponentPiece\r\n                                    ? !state.isOwner\r\n                                    : state.isOwner,\r\n                            };\r\n                        }\r\n                    } else {\r\n                        if (row + i * dirY === state.row && col === state.col) {\r\n                            if (i !== Math.abs(y - row)) {\r\n                                // Stops opponents pieces from being taken when hidden behind each other\r\n                                return {\r\n                                    piece: piece,\r\n                                    collision: true,\r\n                                };\r\n                            }\r\n                            return {\r\n                                piece: piece,\r\n                                collision: checkForOpponentPiece\r\n                                    ? !state.isOwner\r\n                                    : state.isOwner,\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return { piece: null, collision: false };\r\n}\r\n\r\n/**\r\n * Checks if a piece at (x,y) on the board is under attack by an opponents piece\r\n * @param {*} x x coordinate of the square currently being checked\r\n * @param {*} y y coordinate of the square currently being checked\r\n * @param {*} boardState current state of the board\r\n * @returns piece name if the piece is under attack, null otherwise\r\n */\r\nfunction CheckIfMoveUnderAttack(x, y, boardState, pieceToMove = null) {\r\n    for (const [piece, state] of Object.entries(boardState)) {\r\n        // King cannot be checked by its own pieces\r\n        if (!state.isOwner) {\r\n            const dx = Math.abs(x - state.col);\r\n            const dy = Math.abs(y - state.row);\r\n\r\n            // Check if the square is under attack from an opponents piece via straight line\r\n            const straightCollisions = CheckStraightCollisions(\r\n                state.col,\r\n                state.row,\r\n                boardState,\r\n                {\r\n                    pieceName: pieceToMove,\r\n                    pieceState: { col: x, row: y },\r\n                }\r\n            );\r\n\r\n            if (straightCollisions.piece && !straightCollisions.collision) {\r\n                const pieceName = straightCollisions.piece.split(\"_\")[0];\r\n                // If the piece can take pieces horizontally or vertically or king is in range,\r\n                // then the move is not valid\r\n                if (\r\n                    pieceName === \"queen\" ||\r\n                    pieceName === \"castle\" ||\r\n                    (pieceName === \"king\" && (dx === 1 || dy === 1))\r\n                ) {\r\n                    //return true;\r\n                    return straightCollisions.piece;\r\n                }\r\n            }\r\n            // Check if the square is under attack from an opponents piece via diagonal line\r\n            const diagCollisions = CheckDiagCollisions(\r\n                state.col,\r\n                state.row,\r\n                boardState,\r\n                {\r\n                    pieceName: pieceToMove,\r\n                    pieceState: { col: x, row: y },\r\n                }\r\n            );\r\n\r\n            if (\r\n                diagCollisions.piece &&\r\n                diagCollisions.piece !== pieceToMove &&\r\n                !diagCollisions.collision\r\n            ) {\r\n                // Dont include collisions with self\r\n                if (diagCollisions.piece === pieceToMove) return null;\r\n\r\n                const pieceName = diagCollisions.piece.split(\"_\")[0];\r\n                // If the piece can move diagonally or the pawn is in range of square,\r\n                // then the move is not valid\r\n                if (\r\n                    pieceName === \"queen\" ||\r\n                    pieceName === \"bishop\" ||\r\n                    (pieceName === \"king\" && dx === 1 && dy === 1) ||\r\n                    (pieceName === \"pawn\" && dx === 1 && y - state.row === 1)\r\n                ) {\r\n                    //return true;\r\n                    return diagCollisions.piece;\r\n                }\r\n            }\r\n\r\n            // Check if square is under attack by a knight\r\n            if (\r\n                piece.split(\"_\")[0] === \"knight\" &&\r\n                ((dx === 2 && dy === 1) || (dx === 1 && dy === 2))\r\n            ) {\r\n                return piece;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Check if the piece at (x,y) on the board is blocking an opponent piece from checking the king\r\n * @param {*} x x coordinate of the square currently being checked\r\n * @param {*} y y coordinate of the square currently being checked\r\n * @param {*} boardState current state of the board\r\n * @param {*} draggedPiece piece being dragged\r\n * @returns name of piece attacking king, if no such piece exists, return null\r\n */\r\nfunction CheckIfPieceIsProtectingKing(x, y, boardState, draggedPiece) {\r\n    // Get players king\r\n    const king = boardState[\"king_w\"].isOwner\r\n        ? boardState[\"king_w\"]\r\n        : boardState[\"king_b\"];\r\n\r\n    // Direction from (x,y) to king\r\n    const dirX = Math.sign(x - king.col);\r\n    const dirY = Math.sign(y - king.row);\r\n\r\n    if (dirX === 0 && dirY === 0) return null;\r\n\r\n    const dx = Math.abs(king.col - x);\r\n    const dy = Math.abs(king.row - y);\r\n\r\n    const getOppositeCoords = (king) => {\r\n        let oppositeX = king.col;\r\n        let oppositeY = king.row;\r\n        // Get the x,y in the opposite direction to the king to the edge of the board\r\n\r\n        while (\r\n            oppositeX <= 7 &&\r\n            oppositeX >= 0 &&\r\n            oppositeY <= 7 &&\r\n            oppositeY >= 0\r\n        ) {\r\n            oppositeX += dirX;\r\n            oppositeY += dirY;\r\n        }\r\n        return [oppositeX, oppositeY];\r\n    };\r\n\r\n    // Check pieces that are directly above or beside the king\r\n    if (dx === 0 || ((dirX === 1 || dirX === -1) && dy === 0)) {\r\n        // Check if piece is inbetween king and opponent piece that can attack king\r\n        const straightCollisions = CheckStraightCollisions(x, y, boardState, {\r\n            pieceState: { col: king.col, row: king.row },\r\n        });\r\n\r\n        // A piece is inbetween the dragged piece and the king,\r\n        // therefore, it is not protecting the king and can be moved\r\n        if (\r\n            straightCollisions.collision &&\r\n            straightCollisions.piece !== draggedPiece\r\n        )\r\n            return null;\r\n\r\n        const [oppositeX, oppositeY] = getOppositeCoords(king);\r\n\r\n        const oppositeStraightCollisions = CheckStraightCollisions(\r\n            oppositeX,\r\n            oppositeY,\r\n            boardState,\r\n            {\r\n                pieceState: { col: x, row: y },\r\n            }\r\n        );\r\n\r\n        if (\r\n            oppositeStraightCollisions.piece &&\r\n            !boardState[oppositeStraightCollisions.piece].isOwner\r\n        ) {\r\n            const pieceName = oppositeStraightCollisions.piece.split(\"_\")[0];\r\n            // If the piece in opposite direction to king is able to attack the king\r\n            // once the dragged piece is moved, then don't allow the piece to be moved\r\n            if (pieceName === \"castle\" || pieceName === \"queen\") {\r\n                // the piece is protecting the king\r\n                return oppositeStraightCollisions.piece;\r\n            }\r\n        }\r\n    } else if (dx === dy) {\r\n        // Check the pieces directly diagonal to the king\r\n        // Check if piece is inbetween king and opponent piece that can attack king\r\n        const diagCollisions = CheckDiagCollisions(x, y, boardState, {\r\n            pieceState: { col: king.col, row: king.row },\r\n        });\r\n\r\n        // A piece is inbetween the dragged piece and the king,\r\n        // therefore, it is not protecting the king and can be moved\r\n        if (diagCollisions.collision && diagCollisions.piece !== draggedPiece)\r\n            return null;\r\n\r\n        const [oppositeX, oppositeY] = getOppositeCoords(king);\r\n\r\n        const oppositeDiagCollisions = CheckDiagCollisions(\r\n            oppositeX,\r\n            oppositeY,\r\n            boardState,\r\n            {\r\n                pieceState: { col: x, row: y },\r\n            }\r\n        );\r\n\r\n        if (\r\n            oppositeDiagCollisions.piece &&\r\n            !boardState[oppositeDiagCollisions.piece].isOwner\r\n        ) {\r\n            const pieceName = oppositeDiagCollisions.piece.split(\"_\")[0];\r\n            // If the piece in opposite direction to king is able to attack the king\r\n            // once the dragged piece is moved, then don't allow the piece to be moved\r\n            const signDx = king.col - x;\r\n            const signDy = king.col - x;\r\n            if (\r\n                pieceName === \"bishop\" ||\r\n                pieceName === \"queen\" ||\r\n                (pieceName === \"pawn\" &&\r\n                    (signDx === 1 || signDx === -1) &&\r\n                    signDy === -1)\r\n            ) {\r\n                // the piece is protecting the king\r\n                return oppositeDiagCollisions.piece;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks if a piece at (x,y) on the board is under attack by an opponents piece\r\n * @param {*} boardState current state of the board\r\n * @returns true if the piece is under attack, false otherwise\r\n */\r\nexport function CheckIfOpponentInCheck(boardState, opponentKing) {\r\n    for (const [piece, state] of Object.entries(boardState)) {\r\n        // King cannot be checked by its own pieces\r\n        if (state.isOwner) {\r\n            const dx = Math.abs(opponentKing.col - state.col);\r\n            const dy = Math.abs(opponentKing.row - state.row);\r\n\r\n            // Check if the square is under attack from an opponents piece via straight line\r\n            const straightCollisions = CheckStraightCollisions(\r\n                state.col,\r\n                state.row,\r\n                boardState,\r\n                {\r\n                    pieceState: {\r\n                        col: opponentKing.col,\r\n                        row: opponentKing.row,\r\n                    },\r\n                },\r\n                true\r\n            );\r\n\r\n            if (straightCollisions.piece && !straightCollisions.collision) {\r\n                const pieceName = straightCollisions.piece.split(\"_\")[0];\r\n                // If the piece can take pieces horizontally or vertically or king is in range,\r\n                // then the move is not valid\r\n                if (\r\n                    pieceName === \"queen\" ||\r\n                    pieceName === \"castle\" ||\r\n                    (pieceName === \"king\" && (dx === 1 || dy === 1))\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n            // Check if the square is under attack from an opponents piece via diagonal line\r\n            const diagCollisions = CheckDiagCollisions(\r\n                state.col,\r\n                state.row,\r\n                boardState,\r\n                {\r\n                    pieceState: {\r\n                        col: opponentKing.col,\r\n                        row: opponentKing.row,\r\n                    },\r\n                },\r\n                true\r\n            );\r\n            if (diagCollisions.piece && !diagCollisions.collision) {\r\n                const pieceName = diagCollisions.piece.split(\"_\")[0];\r\n\r\n                // If the piece can move diagonally or the pawn is in range of square,\r\n                // then the move is not valid\r\n                // negative direction is up the board\r\n                if (\r\n                    pieceName === \"queen\" ||\r\n                    pieceName === \"bishop\" ||\r\n                    (pieceName === \"king\" && dx === 1 && dy === 1) ||\r\n                    (pieceName === \"pawn\" &&\r\n                        dx === 1 &&\r\n                        opponentKing.row - state.row === -1)\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // Check if square is under attack by a knight\r\n            if (\r\n                piece.split(\"_\")[0] === \"knight\" &&\r\n                ((dx === 2 && dy === 1) || (dx === 1 && dy === 2))\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction CheckIfCanCastle(x, y, draggedPiece, boardState) {\r\n    const pieceName = draggedPiece.pieceName.split(\"_\")[0];\r\n    const pieceColour = draggedPiece.pieceName.split(\"_\")[1];\r\n    if (\r\n        pieceName === \"king\" &&\r\n        !draggedPiece.pieceState.hasBeenInCheck &&\r\n        !draggedPiece.pieceState.hasMoved\r\n    ) {\r\n        const castle_1 = boardState[\"castle_\" + pieceColour + \"_1\"];\r\n        const castle_2 = boardState[\"castle_\" + pieceColour + \"_2\"];\r\n        // Ensure move is at correct square, castle hasnt moved and there is no pieces\r\n        // inbetween the king and castle\r\n        if (\r\n            x === 2 &&\r\n            y === 7 &&\r\n            castle_1 &&\r\n            !castle_1.hasMoved &&\r\n            !GetPieceAtSquare(1, 7, boardState) &&\r\n            !GetPieceAtSquare(2, 7, boardState) &&\r\n            !GetPieceAtSquare(3, 7, boardState)\r\n        ) {\r\n            return {\r\n                castleName: \"castle_\" + pieceColour + \"_1\",\r\n                state: castle_1,\r\n            };\r\n        } else if (\r\n            x === 6 &&\r\n            y === 7 &&\r\n            castle_2 &&\r\n            !castle_2.hasMoved &&\r\n            !GetPieceAtSquare(6, 7, boardState) &&\r\n            !GetPieceAtSquare(5, 7, boardState)\r\n        ) {\r\n            return {\r\n                castleName: \"castle_\" + pieceColour + \"_2\",\r\n                state: castle_2,\r\n            };\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction CheckIfCanEnPassant(draggedPiece, boardState) {\r\n    // Only a pawn can en passant\r\n    if (draggedPiece.pieceName.split(\"_\")[0] !== \"pawn\") return null;\r\n\r\n    const pawnOnLeft = GetPieceAtSquare(\r\n        draggedPiece.pieceState.col - 1,\r\n        draggedPiece.pieceState.row,\r\n        boardState\r\n    );\r\n    const pawnOnRight = GetPieceAtSquare(\r\n        draggedPiece.pieceState.col + 1,\r\n        draggedPiece.pieceState.row,\r\n        boardState\r\n    );\r\n\r\n    if (\r\n        pawnOnLeft &&\r\n        pawnOnLeft.state.movedTwoSquaresTurn === boardState[\"turn\"]\r\n    ) {\r\n        return pawnOnLeft;\r\n    }\r\n    if (\r\n        pawnOnRight &&\r\n        pawnOnRight.state.movedTwoSquaresTurn === boardState[\"turn\"]\r\n    ) {\r\n        return pawnOnRight;\r\n    }\r\n    return null;\r\n}\r\n"],"mappings":"ioBAAA;AACA;AACA;AACA;AACA;AACA,G,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAASA,UAAT,CACHC,GADG,CAEHC,GAFG,CAGHC,aAHG,CAIHC,cAJG,CAKHC,YALG,CAMHC,UANG,CAOL,CACE,GAAMC,OAAM,CAAGC,gBAAgB,CAACP,GAAD,CAAMC,GAAN,CAAWI,UAAX,CAA/B,CACA,GAAMG,cAAa,CAAGC,mBAAmB,CAACL,YAAD,CAAeC,UAAf,CAAzC,CAEA;AACA;AACA,GACKC,MAAM,EAAI,IAAV,EAAkB,CAACA,MAAM,CAACI,OAA1B,EAAqCJ,MAAM,CAACK,KAAP,CAAaC,OAAnD,EACCJ,aAAa,EACVA,aAAa,CAACG,KAAd,CAAoBE,GAApB,GAA4Bb,GAD/B,EAEGQ,aAAa,CAACG,KAAd,CAAoBG,GAApB,CAA0B,CAA1B,GAAgCb,GAJxC,CAKE,CACE,GAAMc,YAAW,CAAGT,MAAM,EAAI,IAAV,CAAiBA,MAAjB,CAA0BE,aAA9C,CACA;AACA,MAAOH,WAAU,CAACU,WAAW,CAACC,KAAb,CAAjB,CAEA;AACA,GAAMC,eAAc,CAAGF,WAAW,CAACC,KAAZ,CAAkBE,KAAlB,CAAwB,GAAxB,CAAvB,CACA,GAAMC,cAAa,CAAGF,cAAc,CAAC,CAAD,CAAd,CAAoB,GAApB,CAA0BA,cAAc,CAAC,CAAD,CAA9D,CACA,GAAMG,aAAY,CAAGC,OAAO,CAAC,2BACzBF,aADyB,CAEzB,MAFwB,CAA5B,CAIA,GAAIG,OAAJ,CACA,GAAIL,cAAc,CAAC,CAAD,CAAd,GAAsB,GAA1B,CAA+BK,MAAM,CAAG,OAAT,CAA/B,IACKA,OAAM,CAAG,OAAT,CACL;AACAnB,cAAc,CAAC,SAACoB,SAAD,wCACRA,SADQ,wBAEVD,MAFU,CAED,6BAAIC,SAAS,CAACD,MAAD,CAAb,GAAuBF,YAAvB,GAAqCI,IAArC,EAFC,IAAD,CAAd,CAIH,CAED,GAAMC,KAAI,CAAGpB,UAAU,CAAC,QAAD,CAAV,CAAqBK,OAArB,CAA+B,QAA/B,CAA0C,QAAvD,CAEA,GAAIgB,WAAJ,CACA;AACA,GAAMC,aAAY,CAAGC,gBAAgB,CAAC5B,GAAD,CAAMC,GAAN,CAAWG,YAAX,CAAyBC,UAAzB,CAArC,CACA,GAAIsB,YAAY,GAAK,IAArB,CAA2B,oBACvB,GAAME,aAAY,CAAGF,YAAY,CAAChB,KAAb,CAAmBE,GAAnB,GAA2B,CAA3B,CAA+B,CAA/B,CAAmC,CAAxD,CACA,GAAMiB,WAAU,CAAGD,YAAY,GAAK,CAAjB,CAAqB,CAArB,CAAyB,CAA5C,CACA;AACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eACQH,UAAU,gCACHH,SADG,uDAELI,YAAY,CAACI,UAFR,gCAGC1B,UAAU,CAACsB,YAAY,CAACI,UAAd,CAHX,MAIFlB,GAAG,CAAEgB,YAJH,CAKFG,QAAQ,CAAE,IALR,mCAOLP,IAPK,gCAQCpB,UAAU,CAACoB,IAAD,CARX,MASFZ,GAAG,CAAEiB,UATH,CAUFE,QAAQ,CAAE,IAVR,0CAYA3B,UAAU,CAAC,MAAD,CAAV,CAAqB,CAZrB,kBAAV,CAcH,CACD;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QA9CI,IA+CK,IAAID,YAAY,CAAC6B,SAAb,CAAuBf,KAAvB,CAA6B,GAA7B,EAAkC,CAAlC,IAAyC,MAA7C,CAAqD,oBACtD,GAAMgB,aAAY,CACd,CAAC9B,YAAY,CAAC+B,UAAb,CAAwBH,QAAzB,EACA5B,YAAY,CAAC+B,UAAb,CAAwBrB,GAAxB,CAA8Bb,GAA9B,GAAsC,CAF1C,CAGA;AACA;AACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eACQyB,UAAU,gCACHH,SADG,uDAELnB,YAAY,CAAC6B,SAFR,gCAGC5B,UAAU,CAACD,YAAY,CAAC6B,SAAd,CAHX,MAIFnB,GAAG,CAAEb,GAJH,CAKFY,GAAG,CAAEb,GALH,CAMFgC,QAAQ,CAAE,IANR,CAOFI,mBAAmB,CAAEF,YAAY,CAC3B7B,UAAU,CAAC,MAAD,CAAV,CAAqB,CADM,CAE3B,IATJ,mCAWLoB,IAXK,gCAYCpB,UAAU,CAACoB,IAAD,CAZX,MAaFY,OAAO,CAAE,KAbP,0CAeAhC,UAAU,CAAC,MAAD,CAAV,CAAqB,CAfrB,kBAAV,CAiBH,CAxCI,IAwCE,oBACH;AACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eACQqB,UAAU,gCACHH,SADG,uDAELnB,YAAY,CAAC6B,SAFR,gCAGC5B,UAAU,CAACD,YAAY,CAAC6B,SAAd,CAHX,MAIFnB,GAAG,CAAEb,GAJH,CAKFY,GAAG,CAAEb,GALH,CAMFgC,QAAQ,CAAE,IANR,mCAQLP,IARK,gCASCpB,UAAU,CAACoB,IAAD,CATX,MAUFY,OAAO,CAAE,KAVP,0CAYAhC,UAAU,CAAC,MAAD,CAAV,CAAqB,CAZrB,kBAAV,CAcH,CAEDH,aAAa,CAAC,SAACqB,SAAD,QAAgB,CAC1BG,UAAU,CAAVA,UAD0B,CAAhB,EAAD,CAAb,CAGH,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,SAASY,aAAT,CAAsBtC,GAAtB,CAA2BC,GAA3B,CAAgCG,YAAhC,CAA8CC,UAA9C,CAA0D,CAC7D,GAAMC,OAAM,CAAGC,gBAAgB,CAACP,GAAD,CAAMC,GAAN,CAAWI,UAAX,CAA/B,CAEA;AACA,GAAIC,MAAM,EAAIA,MAAM,CAACK,KAAP,CAAaD,OAAvB,EAAkCJ,MAAM,CAACK,KAAP,CAAaC,OAAnD,CAA4D,MAAO,MAAP,CAE5D;AACA,GAAI2B,GAAE,CAAGC,IAAI,CAACC,GAAL,CAASzC,GAAG,CAAGI,YAAY,CAAC+B,UAAb,CAAwBtB,GAAvC,CAAT,CACA,GAAI6B,GAAE,CAAGF,IAAI,CAACC,GAAL,CAASxC,GAAG,CAAGG,YAAY,CAAC+B,UAAb,CAAwBrB,GAAvC,CAAT,CAEA,GAAMmB,UAAS,CAAG7B,YAAY,CAAC6B,SAAb,CAAuBf,KAAvB,CAA6B,GAA7B,EAAkC,CAAlC,CAAlB,CAEA;AACA;AACA,GAAMyB,kBAAiB,CAAGC,uBAAuB,CAC7C5C,GAD6C,CAE7CC,GAF6C,CAG7CI,UAH6C,CAI7CD,YAJ6C,CAAjD,CAMA;AACA;AACA,GAAMyC,cAAa,CAAGC,mBAAmB,CACrC9C,GADqC,CAErCC,GAFqC,CAGrCI,UAHqC,CAIrCD,YAJqC,CAAzC,CAOA;AACA,GAAM2C,kBAAiB,CAAGC,4BAA4B,CAClDhD,GADkD,CAElDC,GAFkD,CAGlDI,UAHkD,CAIlDD,YAAY,CAAC6B,SAJqC,CAAtD,CAOA;AACA,GAAMR,KAAI,CAAGpB,UAAU,CAAC,QAAD,CAAV,CAAqBK,OAArB,CACPL,UAAU,CAAC,QAAD,CADH,CAEPA,UAAU,CAAC,QAAD,CAFhB,CAIA,GAAI4C,wBAAJ,CAA6BC,qBAA7B,CACA,GAAIzB,IAAI,CAACY,OAAT,CAAkB,CACd;AACAY,uBAAuB,CAAGE,sBAAsB,CAC5C1B,IAAI,CAACZ,GADuC,CAE5CY,IAAI,CAACX,GAFuC,CAG5CT,UAH4C,CAAhD,CAMA,GAAM+C,8BAA6B,CAC/B9C,MAAM,GAAK,IAAX,EAAmBA,MAAM,CAACU,KAAP,GAAiBiC,uBADxC,CAEA;AACAC,qBAAqB,CACjBzB,IAAI,CAACY,OAAL,GACEU,iBAAiB,GAAK,IAAtB,EAA8BK,6BAA/B,EACIL,iBAAiB,GAAK,IAAtB,EAA8BzC,MAAM,GAAK,IAF9C,CADJ,CAIH,CAED,GAAI+C,iBAAJ,CACA,GAAIpB,SAAS,GAAK,MAAlB,CAA0B,CACtB;AACA;AACA,GAAMqB,mBAAkB,CAAGN,4BAA4B,CACnD5C,YAAY,CAAC+B,UAAb,CAAwBtB,GAD2B,CAEnDT,YAAY,CAAC+B,UAAb,CAAwBrB,GAF2B,CAGnDT,UAHmD,CAInDD,YAAY,CAAC6B,SAJsC,CAAvD,CAMA;AACA,GAAMsB,mBAAkB,CACpBJ,sBAAsB,CAClB/C,YAAY,CAAC+B,UAAb,CAAwBtB,GADN,CAElBT,YAAY,CAAC+B,UAAb,CAAwBrB,GAFN,CAGlBT,UAHkB,CAAtB,GAIM,IALV,CAMAgD,gBAAgB,CAAGC,kBAAkB,GAAK,IAAvB,EAA+BC,kBAAlD,CACH,CAED,GAAMC,yBAAwB,CAAG,QAA3BA,yBAA2B,EAAM,CACnC;AACA;AACA,GACIH,gBAAgB,GACd/C,MAAM,EAAIyC,iBAAiB,GAAKzC,MAAM,CAACU,KAAxC,EACGV,MAAM,GAAK,IADd,EAEIA,MAAM,EAAI,CAACA,MAAM,CAACK,KAAP,CAAaC,OAHb,CADpB,CAMI,MAAO,KAAP,CACJ,MAAO,MAAP,CACH,CAXD,CAaA,OAAQqB,SAAR,EACI,IAAK,MAAL,CACI,GAAMwB,gBAAe,CAAGN,sBAAsB,CAC1CnD,GAD0C,CAE1CC,GAF0C,CAG1CI,UAH0C,CAI1CD,YAAY,CAAC6B,SAJ6B,CAA9C,CAMA,GAAMyB,eAAc,CAChBD,eAAe,GAAK,IAApB,EACCnD,MAAM,EAAIA,MAAM,CAACU,KAAP,GAAiByC,eAFhC,CAGA,GAAME,UAAS,CAAG/B,gBAAgB,CAC9B5B,GAD8B,CAE9BC,GAF8B,CAG9BG,YAH8B,CAI9BC,UAJ8B,CAAlC,CAMA,MACI,CAAE,CAACkC,EAAE,GAAK,CAAP,EAAYA,EAAE,GAAK,CAApB,IAA2BG,EAAE,GAAK,CAAP,EAAYA,EAAE,GAAK,CAA9C,CAAD,EACIiB,SAAS,EAAIpB,EAAE,GAAK,CAApB,EAAyBG,EAAE,GAAK,CADrC,GAEAgB,cAHJ,CAMJ,IAAK,QAAL,CACI,GAAIF,wBAAwB,EAA5B,CAAgC,OAChC,GAAIN,qBAAJ,CAA2B,OAC3B,MACI,CAAEX,EAAE,GAAK,CAAP,EAAYG,EAAE,CAAG,CAAlB,EAAyBH,EAAE,CAAG,CAAL,EAAUG,EAAE,GAAK,CAA3C,GACA,CAACC,iBAAiB,CAACiB,SAFvB,CAKJ,IAAK,QAAL,CACI,GAAIJ,wBAAwB,EAA5B,CAAgC,OAChC,GAAIN,qBAAJ,CAA2B,OAC3B,MAAQX,GAAE,GAAK,CAAP,EAAYG,EAAE,GAAK,CAApB,EAA2BH,EAAE,GAAK,CAAP,EAAYG,EAAE,GAAK,CAArD,CAEJ,IAAK,QAAL,CACI,GAAIc,wBAAwB,EAA5B,CAAgC,OAChC,GAAIN,qBAAJ,CAA2B,OAC3B,MACI,EAAEX,EAAE,GAAK,CAAP,EAAYG,EAAE,CAAG,CAAnB,GACA,EAAEH,EAAE,CAAG,CAAL,EAAUG,EAAE,GAAK,CAAnB,CADA,GAECH,EAAE,GAAKG,EAAP,EAAaH,EAAE,GAAKG,EAFrB,GAGA,CAACG,aAAa,CAACe,SAJnB,CAOJ,IAAK,OAAL,CACI,GAAIJ,wBAAwB,EAA5B,CAAgC,OAChC,GAAIN,qBAAJ,CAA2B,OAE3B,MACK,CAAEX,EAAE,GAAK,CAAP,EAAYG,EAAE,CAAG,CAAlB,EAAyBH,EAAE,CAAG,CAAL,EAAUG,EAAE,GAAK,CAA3C,GACG,CAACC,iBAAiB,CAACiB,SADvB,EAEC,CAACrB,EAAE,GAAKG,EAAP,EAAaH,EAAE,GAAKG,EAArB,GAA4B,CAACG,aAAa,CAACe,SAHhD,CAMJ,IAAK,MAAL,CACI,GAAIJ,wBAAwB,EAA5B,CAAgC,OAChC,GAAIN,qBAAJ,CAA2B,OAE3B;AACA,GAAM1C,cAAa,CAAGC,mBAAmB,CAACL,YAAD,CAAeC,UAAf,CAAzC,CAEA;AACAkC,EAAE,CAAGvC,GAAG,CAAGI,YAAY,CAAC+B,UAAb,CAAwBtB,GAAnC,CACA6B,EAAE,CAAGzC,GAAG,CAAGG,YAAY,CAAC+B,UAAb,CAAwBrB,GAAnC,CACA;AACA,GAAI,CAACV,YAAY,CAAC+B,UAAb,CAAwBH,QAA7B,CAAuC,CACnC;AACA,GACIO,EAAE,GAAK,CAAP,GACCG,EAAE,GAAK,CAAC,CAAR,EAAaA,EAAE,GAAK,CAAC,CADtB,GAEA,CAACC,iBAAiB,CAACiB,SAHvB,CAIE,CACE,MAAOtD,OAAM,GAAK,IAAlB,CACH,CACJ,CAED;AACA,GACIE,aAAa,EACbR,GAAG,GAAKQ,aAAa,CAACG,KAAd,CAAoBE,GAD5B,EAEAZ,GAAG,GAAKO,aAAa,CAACG,KAAd,CAAoBG,GAApB,CAA0B,CAHtC,CAKI,MAAO,KAAP,CAEJ,GAAI,CAACyB,EAAE,GAAK,CAAP,EAAYA,EAAE,GAAK,CAAC,CAArB,GAA2BG,EAAE,GAAK,CAAC,CAAnC,EAAwCpC,MAAM,GAAK,IAAvD,CACI;AACA,MAAO,KAAP,CAEJ;AACA,MAAOiC,GAAE,GAAK,CAAP,EAAYG,EAAE,GAAK,CAAC,CAApB,EAAyBpC,MAAM,GAAK,IAA3C,CAEJ,QACI,MAAO,MAAP,CA9FR,CAgGH,CAED;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAASC,iBAAT,CAA0BsD,CAA1B,CAA6BC,CAA7B,CAAgCzD,UAAhC,CAA4C,CACxC,6BAA6B0D,MAAM,CAACC,OAAP,CAAe3D,UAAf,CAA7B,gCAAyD,CAApD,6DAAOW,KAAP,uBAAcL,KAAd,uBACD,GAAIkD,CAAC,GAAKlD,KAAK,CAACE,GAAZ,EAAmBiD,CAAC,GAAKnD,KAAK,CAACG,GAAnC,CAAwC,CACpC,MAAO,CAAEE,KAAK,CAALA,KAAF,CAASL,KAAK,CAALA,KAAT,CAAP,CACH,CACJ,CACD,MAAO,KAAP,CACH,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAASmC,oBAAT,CACIe,CADJ,CAEIC,CAFJ,CAGIzD,UAHJ,CAIID,YAJJ,CAME,IADE6D,sBACF,2DAD0B,KAC1B,CACE;AACA,GAAMnD,IAAG,CAAGV,YAAY,CAAC+B,UAAb,CAAwBrB,GAApC,CACA,GAAMD,IAAG,CAAGT,YAAY,CAAC+B,UAAb,CAAwBtB,GAApC,CAEA,GAAMqD,KAAI,CAAG1B,IAAI,CAAC2B,IAAL,CAAUN,CAAC,CAAGhD,GAAd,CAAb,CACA,GAAMuD,KAAI,CAAG5B,IAAI,CAAC2B,IAAL,CAAUL,CAAC,CAAGhD,GAAd,CAAb,CACA,IAAK,GAAIuD,EAAC,CAAG,CAAb,CAAgBA,CAAC,CAAG7B,IAAI,CAACC,GAAL,CAASoB,CAAC,CAAGhD,GAAb,EAAoB,CAAxC,CAA2CwD,CAAC,EAA5C,CAAgD,CAC5C,+BAA6BN,MAAM,CAACC,OAAP,CAAe3D,UAAf,CAA7B,mCAAyD,CAApD,gEAAOW,KAAP,wBAAcL,KAAd,wBACD;AACA,GAAIK,KAAK,GAAKZ,YAAY,CAAC6B,SAA3B,CAAsC,CAClC,GAAMqC,MAAK,CAAGL,qBAAqB,CAC7B,CAACtD,KAAK,CAACD,OADsB,CAE7BC,KAAK,CAACD,OAFZ,CAGA,GACIG,GAAG,CAAGwD,CAAC,CAAGH,IAAV,GAAmBvD,KAAK,CAACE,GAAzB,EACAC,GAAG,CAAGuD,CAAC,CAAGD,IAAV,GAAmBzD,KAAK,CAACG,GADzB,EAEAH,KAAK,CAACC,OAFN,GAGEyD,CAAC,GAAK,CAAN,EAAW,CAACC,KAAb,EAAuBD,CAAC,GAAK,CAH9B,CADJ,CAKE,CACE,GAAIA,CAAC,GAAK7B,IAAI,CAACC,GAAL,CAASoB,CAAC,CAAGhD,GAAb,CAAV,CAA6B,CACzB;AACA,MAAO,CACHG,KAAK,CAAEA,KADJ,CAEH4C,SAAS,CAAE,IAFR,CAAP,CAIH,CACD,MAAO,CACH5C,KAAK,CAAEA,KADJ,CAEH4C,SAAS,CAAEU,KAFR,CAAP,CAIH,CACJ,CACJ,CACJ,CACD,MAAO,CAAEtD,KAAK,CAAE,IAAT,CAAe4C,SAAS,CAAE,KAA1B,CAAP,CACH,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAAShB,wBAAT,CACIiB,CADJ,CAEIC,CAFJ,CAGIzD,UAHJ,CAIID,YAJJ,CAME,IADE6D,sBACF,2DAD0B,KAC1B,CACE;AACA,GAAMnD,IAAG,CAAGV,YAAY,CAAC+B,UAAb,CAAwBrB,GAApC,CACA,GAAMD,IAAG,CAAGT,YAAY,CAAC+B,UAAb,CAAwBtB,GAApC,CACA;AACA,GAAM0B,GAAE,CAAGC,IAAI,CAACC,GAAL,CAASoB,CAAC,CAAGhD,GAAb,CAAX,CACA,GAAM6B,GAAE,CAAGF,IAAI,CAACC,GAAL,CAASqB,CAAC,CAAGhD,GAAb,CAAX,CAEA;AACA,GAAIyB,EAAE,CAAG,CAAL,EAAUG,EAAE,CAAG,CAAnB,CAAsB,MAAO,KAAP,CAEtB;AACA,GAAMwB,KAAI,CAAG1B,IAAI,CAAC2B,IAAL,CAAUN,CAAC,CAAGhD,GAAd,CAAb,CACA,GAAMuD,KAAI,CAAG5B,IAAI,CAAC2B,IAAL,CAAUL,CAAC,CAAGhD,GAAd,CAAb,CAEA,IAAK,GAAIuD,EAAC,CAAG,CAAb,CAAgBA,CAAC,CAAG7B,IAAI,CAAC+B,GAAL,CAAShC,EAAT,CAAaG,EAAb,EAAmB,CAAvC,CAA0C2B,CAAC,EAA3C,CAA+C,CAC3C,+BAA6BN,MAAM,CAACC,OAAP,CAAe3D,UAAf,CAA7B,mCAAyD,CAApD,gEAAOW,KAAP,wBAAcL,KAAd,wBACD;AACA,GAAIK,KAAK,GAAKZ,YAAY,CAAC6B,SAA3B,CAAsC,CAClC,GAAItB,KAAK,CAACC,OAAV,CAAmB,CACf;AACA,GAAI8B,EAAE,GAAK,CAAX,CAAc,CACV,GAAI7B,GAAG,CAAGwD,CAAC,CAAGH,IAAV,GAAmBvD,KAAK,CAACE,GAAzB,EAAgCC,GAAG,GAAKH,KAAK,CAACG,GAAlD,CAAuD,CACnD,GAAIuD,CAAC,GAAK7B,IAAI,CAACC,GAAL,CAASoB,CAAC,CAAGhD,GAAb,CAAV,CAA6B,CACzB;AACA,MAAO,CACHG,KAAK,CAAEA,KADJ,CAEH4C,SAAS,CAAE,IAFR,CAAP,CAIH,CACD,MAAO,CACH5C,KAAK,CAAEA,KADJ,CAEH4C,SAAS,CAAEK,qBAAqB,CAC1B,CAACtD,KAAK,CAACD,OADmB,CAE1BC,KAAK,CAACD,OAJT,CAAP,CAMH,CACJ,CAhBD,IAgBO,CACH,GAAII,GAAG,CAAGuD,CAAC,CAAGD,IAAV,GAAmBzD,KAAK,CAACG,GAAzB,EAAgCD,GAAG,GAAKF,KAAK,CAACE,GAAlD,CAAuD,CACnD,GAAIwD,CAAC,GAAK7B,IAAI,CAACC,GAAL,CAASqB,CAAC,CAAGhD,GAAb,CAAV,CAA6B,CACzB;AACA,MAAO,CACHE,KAAK,CAAEA,KADJ,CAEH4C,SAAS,CAAE,IAFR,CAAP,CAIH,CACD,MAAO,CACH5C,KAAK,CAAEA,KADJ,CAEH4C,SAAS,CAAEK,qBAAqB,CAC1B,CAACtD,KAAK,CAACD,OADmB,CAE1BC,KAAK,CAACD,OAJT,CAAP,CAMH,CACJ,CACJ,CACJ,CACJ,CACJ,CACD,MAAO,CAAEM,KAAK,CAAE,IAAT,CAAe4C,SAAS,CAAE,KAA1B,CAAP,CACH,CAED;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAAST,uBAAT,CAAgCU,CAAhC,CAAmCC,CAAnC,CAAsCzD,UAAtC,CAAsE,IAApBmE,YAAoB,2DAAN,IAAM,CAClE,+BAA6BT,MAAM,CAACC,OAAP,CAAe3D,UAAf,CAA7B,mCAAyD,CAApD,gEAAOW,KAAP,wBAAcL,KAAd,wBACD;AACA,GAAI,CAACA,KAAK,CAACD,OAAX,CAAoB,CAChB,GAAM6B,GAAE,CAAGC,IAAI,CAACC,GAAL,CAASoB,CAAC,CAAGlD,KAAK,CAACE,GAAnB,CAAX,CACA,GAAM6B,GAAE,CAAGF,IAAI,CAACC,GAAL,CAASqB,CAAC,CAAGnD,KAAK,CAACG,GAAnB,CAAX,CAEA;AACA,GAAM2D,mBAAkB,CAAG7B,uBAAuB,CAC9CjC,KAAK,CAACE,GADwC,CAE9CF,KAAK,CAACG,GAFwC,CAG9CT,UAH8C,CAI9C,CACI4B,SAAS,CAAEuC,WADf,CAEIrC,UAAU,CAAE,CAAEtB,GAAG,CAAEgD,CAAP,CAAU/C,GAAG,CAAEgD,CAAf,CAFhB,CAJ8C,CAAlD,CAUA,GAAIW,kBAAkB,CAACzD,KAAnB,EAA4B,CAACyD,kBAAkB,CAACb,SAApD,CAA+D,CAC3D,GAAM3B,UAAS,CAAGwC,kBAAkB,CAACzD,KAAnB,CAAyBE,KAAzB,CAA+B,GAA/B,EAAoC,CAApC,CAAlB,CACA;AACA;AACA,GACIe,SAAS,GAAK,OAAd,EACAA,SAAS,GAAK,QADd,EAECA,SAAS,GAAK,MAAd,GAAyBM,EAAE,GAAK,CAAP,EAAYG,EAAE,GAAK,CAA5C,CAHL,CAIE,CACE;AACA,MAAO+B,mBAAkB,CAACzD,KAA1B,CACH,CACJ,CACD;AACA,GAAM0D,eAAc,CAAG5B,mBAAmB,CACtCnC,KAAK,CAACE,GADgC,CAEtCF,KAAK,CAACG,GAFgC,CAGtCT,UAHsC,CAItC,CACI4B,SAAS,CAAEuC,WADf,CAEIrC,UAAU,CAAE,CAAEtB,GAAG,CAAEgD,CAAP,CAAU/C,GAAG,CAAEgD,CAAf,CAFhB,CAJsC,CAA1C,CAUA,GACIY,cAAc,CAAC1D,KAAf,EACA0D,cAAc,CAAC1D,KAAf,GAAyBwD,WADzB,EAEA,CAACE,cAAc,CAACd,SAHpB,CAIE,CACE;AACA,GAAIc,cAAc,CAAC1D,KAAf,GAAyBwD,WAA7B,CAA0C,MAAO,KAAP,CAE1C,GAAMvC,WAAS,CAAGyC,cAAc,CAAC1D,KAAf,CAAqBE,KAArB,CAA2B,GAA3B,EAAgC,CAAhC,CAAlB,CACA;AACA;AACA,GACIe,UAAS,GAAK,OAAd,EACAA,UAAS,GAAK,QADd,EAECA,UAAS,GAAK,MAAd,EAAwBM,EAAE,GAAK,CAA/B,EAAoCG,EAAE,GAAK,CAF5C,EAGCT,UAAS,GAAK,MAAd,EAAwBM,EAAE,GAAK,CAA/B,EAAoCuB,CAAC,CAAGnD,KAAK,CAACG,GAAV,GAAkB,CAJ3D,CAKE,CACE;AACA,MAAO4D,eAAc,CAAC1D,KAAtB,CACH,CACJ,CAED;AACA,GACIA,KAAK,CAACE,KAAN,CAAY,GAAZ,EAAiB,CAAjB,IAAwB,QAAxB,GACEqB,EAAE,GAAK,CAAP,EAAYG,EAAE,GAAK,CAApB,EAA2BH,EAAE,GAAK,CAAP,EAAYG,EAAE,GAAK,CAD/C,CADJ,CAGE,CACE,MAAO1B,MAAP,CACH,CACJ,CACJ,CACD,MAAO,KAAP,CACH,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAASgC,6BAAT,CAAsCa,CAAtC,CAAyCC,CAAzC,CAA4CzD,UAA5C,CAAwDD,YAAxD,CAAsE,CAClE;AACA,GAAMqB,KAAI,CAAGpB,UAAU,CAAC,QAAD,CAAV,CAAqBK,OAArB,CACPL,UAAU,CAAC,QAAD,CADH,CAEPA,UAAU,CAAC,QAAD,CAFhB,CAIA;AACA,GAAM6D,KAAI,CAAG1B,IAAI,CAAC2B,IAAL,CAAUN,CAAC,CAAGpC,IAAI,CAACZ,GAAnB,CAAb,CACA,GAAMuD,KAAI,CAAG5B,IAAI,CAAC2B,IAAL,CAAUL,CAAC,CAAGrC,IAAI,CAACX,GAAnB,CAAb,CAEA,GAAIoD,IAAI,GAAK,CAAT,EAAcE,IAAI,GAAK,CAA3B,CAA8B,MAAO,KAAP,CAE9B,GAAM7B,GAAE,CAAGC,IAAI,CAACC,GAAL,CAAShB,IAAI,CAACZ,GAAL,CAAWgD,CAApB,CAAX,CACA,GAAMnB,GAAE,CAAGF,IAAI,CAACC,GAAL,CAAShB,IAAI,CAACX,GAAL,CAAWgD,CAApB,CAAX,CAEA,GAAMa,kBAAiB,CAAG,QAApBA,kBAAoB,CAAClD,IAAD,CAAU,CAChC,GAAImD,UAAS,CAAGnD,IAAI,CAACZ,GAArB,CACA,GAAIgE,UAAS,CAAGpD,IAAI,CAACX,GAArB,CACA;AAEA,MACI8D,SAAS,EAAI,CAAb,EACAA,SAAS,EAAI,CADb,EAEAC,SAAS,EAAI,CAFb,EAGAA,SAAS,EAAI,CAJjB,CAKE,CACED,SAAS,EAAIV,IAAb,CACAW,SAAS,EAAIT,IAAb,CACH,CACD,MAAO,CAACQ,SAAD,CAAYC,SAAZ,CAAP,CACH,CAfD,CAiBA;AACA,GAAItC,EAAE,GAAK,CAAP,EAAa,CAAC2B,IAAI,GAAK,CAAT,EAAcA,IAAI,GAAK,CAAC,CAAzB,GAA+BxB,EAAE,GAAK,CAAvD,CAA2D,CACvD;AACA,GAAM+B,mBAAkB,CAAG7B,uBAAuB,CAACiB,CAAD,CAAIC,CAAJ,CAAOzD,UAAP,CAAmB,CACjE8B,UAAU,CAAE,CAAEtB,GAAG,CAAEY,IAAI,CAACZ,GAAZ,CAAiBC,GAAG,CAAEW,IAAI,CAACX,GAA3B,CADqD,CAAnB,CAAlD,CAIA;AACA;AACA,GACI2D,kBAAkB,CAACb,SAAnB,EACAa,kBAAkB,CAACzD,KAAnB,GAA6BZ,YAFjC,CAII,MAAO,KAAP,CAEJ,uBAA+BuE,iBAAiB,CAAClD,IAAD,CAAhD,0DAAOmD,SAAP,wBAAkBC,SAAlB,wBAEA,GAAMC,2BAA0B,CAAGlC,uBAAuB,CACtDgC,SADsD,CAEtDC,SAFsD,CAGtDxE,UAHsD,CAItD,CACI8B,UAAU,CAAE,CAAEtB,GAAG,CAAEgD,CAAP,CAAU/C,GAAG,CAAEgD,CAAf,CADhB,CAJsD,CAA1D,CASA,GACIgB,0BAA0B,CAAC9D,KAA3B,EACA,CAACX,UAAU,CAACyE,0BAA0B,CAAC9D,KAA5B,CAAV,CAA6CN,OAFlD,CAGE,CACE,GAAMuB,UAAS,CAAG6C,0BAA0B,CAAC9D,KAA3B,CAAiCE,KAAjC,CAAuC,GAAvC,EAA4C,CAA5C,CAAlB,CACA;AACA;AACA,GAAIe,SAAS,GAAK,QAAd,EAA0BA,SAAS,GAAK,OAA5C,CAAqD,CACjD;AACA,MAAO6C,2BAA0B,CAAC9D,KAAlC,CACH,CACJ,CACJ,CArCD,IAqCO,IAAIuB,EAAE,GAAKG,EAAX,CAAe,CAClB;AACA;AACA,GAAMgC,eAAc,CAAG5B,mBAAmB,CAACe,CAAD,CAAIC,CAAJ,CAAOzD,UAAP,CAAmB,CACzD8B,UAAU,CAAE,CAAEtB,GAAG,CAAEY,IAAI,CAACZ,GAAZ,CAAiBC,GAAG,CAAEW,IAAI,CAACX,GAA3B,CAD6C,CAAnB,CAA1C,CAIA;AACA;AACA,GAAI4D,cAAc,CAACd,SAAf,EAA4Bc,cAAc,CAAC1D,KAAf,GAAyBZ,YAAzD,CACI,MAAO,KAAP,CAEJ,wBAA+BuE,iBAAiB,CAAClD,IAAD,CAAhD,2DAAOmD,UAAP,wBAAkBC,UAAlB,wBAEA,GAAME,uBAAsB,CAAGjC,mBAAmB,CAC9C8B,UAD8C,CAE9CC,UAF8C,CAG9CxE,UAH8C,CAI9C,CACI8B,UAAU,CAAE,CAAEtB,GAAG,CAAEgD,CAAP,CAAU/C,GAAG,CAAEgD,CAAf,CADhB,CAJ8C,CAAlD,CASA,GACIiB,sBAAsB,CAAC/D,KAAvB,EACA,CAACX,UAAU,CAAC0E,sBAAsB,CAAC/D,KAAxB,CAAV,CAAyCN,OAF9C,CAGE,CACE,GAAMuB,YAAS,CAAG8C,sBAAsB,CAAC/D,KAAvB,CAA6BE,KAA7B,CAAmC,GAAnC,EAAwC,CAAxC,CAAlB,CACA;AACA;AACA,GAAM8D,OAAM,CAAGvD,IAAI,CAACZ,GAAL,CAAWgD,CAA1B,CACA,GAAMoB,OAAM,CAAGxD,IAAI,CAACZ,GAAL,CAAWgD,CAA1B,CACA,GACI5B,WAAS,GAAK,QAAd,EACAA,WAAS,GAAK,OADd,EAECA,WAAS,GAAK,MAAd,GACI+C,MAAM,GAAK,CAAX,EAAgBA,MAAM,GAAK,CAAC,CADhC,GAEGC,MAAM,GAAK,CAAC,CALpB,CAME,CACE;AACA,MAAOF,uBAAsB,CAAC/D,KAA9B,CACH,CACJ,CACJ,CACD,MAAO,KAAP,CACH,CAED;AACA;AACA;AACA;AACA,GACA,MAAO,SAASkE,uBAAT,CAAgC7E,UAAhC,CAA4C8E,YAA5C,CAA0D,CAC7D,+BAA6BpB,MAAM,CAACC,OAAP,CAAe3D,UAAf,CAA7B,mCAAyD,CAApD,gEAAOW,KAAP,wBAAcL,KAAd,wBACD;AACA,GAAIA,KAAK,CAACD,OAAV,CAAmB,CACf,GAAM6B,GAAE,CAAGC,IAAI,CAACC,GAAL,CAAS0C,YAAY,CAACtE,GAAb,CAAmBF,KAAK,CAACE,GAAlC,CAAX,CACA,GAAM6B,GAAE,CAAGF,IAAI,CAACC,GAAL,CAAS0C,YAAY,CAACrE,GAAb,CAAmBH,KAAK,CAACG,GAAlC,CAAX,CAEA;AACA,GAAM2D,mBAAkB,CAAG7B,uBAAuB,CAC9CjC,KAAK,CAACE,GADwC,CAE9CF,KAAK,CAACG,GAFwC,CAG9CT,UAH8C,CAI9C,CACI8B,UAAU,CAAE,CACRtB,GAAG,CAAEsE,YAAY,CAACtE,GADV,CAERC,GAAG,CAAEqE,YAAY,CAACrE,GAFV,CADhB,CAJ8C,CAU9C,IAV8C,CAAlD,CAaA,GAAI2D,kBAAkB,CAACzD,KAAnB,EAA4B,CAACyD,kBAAkB,CAACb,SAApD,CAA+D,CAC3D,GAAM3B,UAAS,CAAGwC,kBAAkB,CAACzD,KAAnB,CAAyBE,KAAzB,CAA+B,GAA/B,EAAoC,CAApC,CAAlB,CACA;AACA;AACA,GACIe,SAAS,GAAK,OAAd,EACAA,SAAS,GAAK,QADd,EAECA,SAAS,GAAK,MAAd,GAAyBM,EAAE,GAAK,CAAP,EAAYG,EAAE,GAAK,CAA5C,CAHL,CAIE,CACE,MAAO,KAAP,CACH,CACJ,CACD;AACA,GAAMgC,eAAc,CAAG5B,mBAAmB,CACtCnC,KAAK,CAACE,GADgC,CAEtCF,KAAK,CAACG,GAFgC,CAGtCT,UAHsC,CAItC,CACI8B,UAAU,CAAE,CACRtB,GAAG,CAAEsE,YAAY,CAACtE,GADV,CAERC,GAAG,CAAEqE,YAAY,CAACrE,GAFV,CADhB,CAJsC,CAUtC,IAVsC,CAA1C,CAYA,GAAI4D,cAAc,CAAC1D,KAAf,EAAwB,CAAC0D,cAAc,CAACd,SAA5C,CAAuD,CACnD,GAAM3B,YAAS,CAAGyC,cAAc,CAAC1D,KAAf,CAAqBE,KAArB,CAA2B,GAA3B,EAAgC,CAAhC,CAAlB,CAEA;AACA;AACA;AACA,GACIe,WAAS,GAAK,OAAd,EACAA,WAAS,GAAK,QADd,EAECA,WAAS,GAAK,MAAd,EAAwBM,EAAE,GAAK,CAA/B,EAAoCG,EAAE,GAAK,CAF5C,EAGCT,WAAS,GAAK,MAAd,EACGM,EAAE,GAAK,CADV,EAEG4C,YAAY,CAACrE,GAAb,CAAmBH,KAAK,CAACG,GAAzB,GAAiC,CAAC,CAN1C,CAOE,CACE,MAAO,KAAP,CACH,CACJ,CAED;AACA,GACIE,KAAK,CAACE,KAAN,CAAY,GAAZ,EAAiB,CAAjB,IAAwB,QAAxB,GACEqB,EAAE,GAAK,CAAP,EAAYG,EAAE,GAAK,CAApB,EAA2BH,EAAE,GAAK,CAAP,EAAYG,EAAE,GAAK,CAD/C,CADJ,CAGE,CACE,MAAO,KAAP,CACH,CACJ,CACJ,CACD,MAAO,MAAP,CACH,CAED,QAASd,iBAAT,CAA0BiC,CAA1B,CAA6BC,CAA7B,CAAgC1D,YAAhC,CAA8CC,UAA9C,CAA0D,CACtD,GAAM4B,UAAS,CAAG7B,YAAY,CAAC6B,SAAb,CAAuBf,KAAvB,CAA6B,GAA7B,EAAkC,CAAlC,CAAlB,CACA,GAAMkE,YAAW,CAAGhF,YAAY,CAAC6B,SAAb,CAAuBf,KAAvB,CAA6B,GAA7B,EAAkC,CAAlC,CAApB,CACA,GACIe,SAAS,GAAK,MAAd,EACA,CAAC7B,YAAY,CAAC+B,UAAb,CAAwBkD,cADzB,EAEA,CAACjF,YAAY,CAAC+B,UAAb,CAAwBH,QAH7B,CAIE,CACE,GAAMsD,SAAQ,CAAGjF,UAAU,CAAC,UAAY+E,WAAZ,CAA0B,IAA3B,CAA3B,CACA,GAAMG,SAAQ,CAAGlF,UAAU,CAAC,UAAY+E,WAAZ,CAA0B,IAA3B,CAA3B,CACA;AACA;AACA,GACIvB,CAAC,GAAK,CAAN,EACAC,CAAC,GAAK,CADN,EAEAwB,QAFA,EAGA,CAACA,QAAQ,CAACtD,QAHV,EAIA,CAACzB,gBAAgB,CAAC,CAAD,CAAI,CAAJ,CAAOF,UAAP,CAJjB,EAKA,CAACE,gBAAgB,CAAC,CAAD,CAAI,CAAJ,CAAOF,UAAP,CALjB,EAMA,CAACE,gBAAgB,CAAC,CAAD,CAAI,CAAJ,CAAOF,UAAP,CAPrB,CAQE,CACE,MAAO,CACH0B,UAAU,CAAE,UAAYqD,WAAZ,CAA0B,IADnC,CAEHzE,KAAK,CAAE2E,QAFJ,CAAP,CAIH,CAbD,IAaO,IACHzB,CAAC,GAAK,CAAN,EACAC,CAAC,GAAK,CADN,EAEAyB,QAFA,EAGA,CAACA,QAAQ,CAACvD,QAHV,EAIA,CAACzB,gBAAgB,CAAC,CAAD,CAAI,CAAJ,CAAOF,UAAP,CAJjB,EAKA,CAACE,gBAAgB,CAAC,CAAD,CAAI,CAAJ,CAAOF,UAAP,CANd,CAOL,CACE,MAAO,CACH0B,UAAU,CAAE,UAAYqD,WAAZ,CAA0B,IADnC,CAEHzE,KAAK,CAAE4E,QAFJ,CAAP,CAIH,CACJ,CACD,MAAO,KAAP,CACH,CAED,QAAS9E,oBAAT,CAA6BL,YAA7B,CAA2CC,UAA3C,CAAuD,CACnD;AACA,GAAID,YAAY,CAAC6B,SAAb,CAAuBf,KAAvB,CAA6B,GAA7B,EAAkC,CAAlC,IAAyC,MAA7C,CAAqD,MAAO,KAAP,CAErD,GAAMsE,WAAU,CAAGjF,gBAAgB,CAC/BH,YAAY,CAAC+B,UAAb,CAAwBtB,GAAxB,CAA8B,CADC,CAE/BT,YAAY,CAAC+B,UAAb,CAAwBrB,GAFO,CAG/BT,UAH+B,CAAnC,CAKA,GAAMoF,YAAW,CAAGlF,gBAAgB,CAChCH,YAAY,CAAC+B,UAAb,CAAwBtB,GAAxB,CAA8B,CADE,CAEhCT,YAAY,CAAC+B,UAAb,CAAwBrB,GAFQ,CAGhCT,UAHgC,CAApC,CAMA,GACImF,UAAU,EACVA,UAAU,CAAC7E,KAAX,CAAiByB,mBAAjB,GAAyC/B,UAAU,CAAC,MAAD,CAFvD,CAGE,CACE,MAAOmF,WAAP,CACH,CACD,GACIC,WAAW,EACXA,WAAW,CAAC9E,KAAZ,CAAkByB,mBAAlB,GAA0C/B,UAAU,CAAC,MAAD,CAFxD,CAGE,CACE,MAAOoF,YAAP,CACH,CACD,MAAO,KAAP,CACH"},"metadata":{},"sourceType":"module"}