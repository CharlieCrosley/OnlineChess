[{"C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\index.js":"1","C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\App.js":"2","C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\pages\\Chess.js":"3","C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\pages\\GameElements.js":"4","C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\components\\Board.js":"5","C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\components\\BoardSquare.js":"6","C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\components\\Constants.js":"7","C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\components\\ChessElements.js":"8","C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\components\\Game.js":"9","C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\pages\\RoomJoin.js":"10","C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\components\\Piece.js":"11","C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\components\\GameOver.js":"12","C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\components\\GameOverElements.js":"13"},{"size":240,"mtime":1664219221881,"results":"14","hashOfConfig":"15"},{"size":604,"mtime":1665343541036,"results":"16","hashOfConfig":"15"},{"size":18162,"mtime":1665693643288,"results":"17","hashOfConfig":"15"},{"size":1828,"mtime":1665583900254,"results":"18","hashOfConfig":"15"},{"size":2382,"mtime":1665156216595,"results":"19","hashOfConfig":"15"},{"size":1610,"mtime":1665431184464,"results":"20","hashOfConfig":"15"},{"size":53,"mtime":1664381744698,"results":"21","hashOfConfig":"15"},{"size":1591,"mtime":1664732240193,"results":"22","hashOfConfig":"15"},{"size":30947,"mtime":1665588417209,"results":"23","hashOfConfig":"15"},{"size":1746,"mtime":1665528841573,"results":"24","hashOfConfig":"15"},{"size":902,"mtime":1665431195841,"results":"25","hashOfConfig":"15"},{"size":1368,"mtime":1665172132406,"results":"26","hashOfConfig":"15"},{"size":3067,"mtime":1665528300810,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","suppressedMessages":"30","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},"1oo7czs",{"filePath":"32","messages":"33","suppressedMessages":"34","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"35","messages":"36","suppressedMessages":"37","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38"},{"filePath":"39","messages":"40","suppressedMessages":"41","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"42","messages":"43","suppressedMessages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"45","messages":"46","suppressedMessages":"47","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"48","messages":"49","suppressedMessages":"50","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"51","messages":"52","suppressedMessages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"54","messages":"55","suppressedMessages":"56","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"57","messages":"58","suppressedMessages":"59","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"60","messages":"61","suppressedMessages":"62","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"63","messages":"64","suppressedMessages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"66","messages":"67","suppressedMessages":"68","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},"C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\index.js",[],[],[],"C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\App.js",[],[],"C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\pages\\Chess.js",["69","70","71","72","73","74"],[],"import React, { useState, useEffect } from \"react\";\r\nimport useWebSocket from \"react-use-websocket\";\r\nimport { useLocation, useNavigate } from \"react-router-dom\";\r\nimport {\r\n    Container,\r\n    GameContainer,\r\n    GamePlayer,\r\n    Player,\r\n    TakenPieces,\r\n    Buttons,\r\n    PlayerName,\r\n    PlayerData,\r\n    RoomNumber,\r\n    Timer,\r\n} from \"./GameElements\";\r\nimport Board from \"../components/Board\";\r\nimport { CheckIfOpponentInCheck, CanMovePiece } from \"../components/Game\";\r\nimport GameOver from \"../components/GameOver\";\r\nimport { Button } from \"../components/GameOverElements\";\r\nimport { useTimer } from \"react-timer-hook\";\r\n\r\nconst Chess = () => {\r\n    const location = useLocation();\r\n\r\n    const [start, setStart] = useState(false);\r\n    const [winner, setWinner] = useState(null);\r\n    const [room] = useState(location.state.room);\r\n    // Capitalise name\r\n    const [name] = useState(\r\n        location.state.name.charAt(0).toUpperCase() +\r\n            location.state.name.slice(1)\r\n    );\r\n    const [opponentName, setOpponentName] = useState(null);\r\n    const [playerColour, setPlayerColour] = useState(\"white\");\r\n    const [takenPieces, setTakenPieces] = useState({\r\n        white: [],\r\n        black: [],\r\n    });\r\n    const [isTurn, setIsTurn] = useState(true);\r\n\r\n    // Sets initial piece positions ensuring that players colour is always at bottom\r\n    const [boardState, setBoardState] = useState(\r\n        initBoardState(playerColour === \"white\", getBoardRotation(playerColour))\r\n    );\r\n    const [prevBoardState, setPrevBoardState] = useState(null);\r\n\r\n    const [audio] = useState({\r\n        check: new Audio(require(\"../assets/sounds/check.mp3\")),\r\n        move: new Audio(require(\"../assets/sounds/move.mp3\")),\r\n        capture: new Audio(require(\"../assets/sounds/capture.ogg\")),\r\n        end: new Audio(require(\"../assets/sounds/game_end.mp3\")),\r\n    });\r\n\r\n    const opponentColour = playerColour === \"white\" ? \"black\" : \"white\";\r\n\r\n    const getNewTimer = () => {\r\n        const time = new Date();\r\n        time.setSeconds(time.getSeconds() + 600);\r\n        return time;\r\n    };\r\n\r\n    const timer = useTimer({\r\n        expiryTimestamp: getNewTimer(),\r\n        autoStart: false,\r\n        onExpire: () => {\r\n            outOfTime(playerColour === \"white\" ? \"black\" : \"white\");\r\n            timer.pause();\r\n        },\r\n    });\r\n\r\n    const opponentTimer = useTimer({\r\n        expiryTimestamp: getNewTimer(),\r\n        autoStart: false,\r\n        onExpire: () => {\r\n            outOfTime(playerColour);\r\n            opponentTimer.pause();\r\n        },\r\n    });\r\n\r\n    const outOfTime = (winnerColour) => {\r\n        sendMessage(\r\n            JSON.stringify({\r\n                type: \"send_message\",\r\n                message: { winnerColour: winnerColour },\r\n                event: \"END\",\r\n            })\r\n        );\r\n    };\r\n\r\n    const { sendMessage } = useWebSocket(\r\n        \"ws://127.0.0.1:8000/ws/\" + room + \"/\",\r\n        {\r\n            onOpen: () => {\r\n                sendMessage(\r\n                    JSON.stringify({\r\n                        type: \"send_message\",\r\n                        message: {\r\n                            opponentName: name,\r\n                        },\r\n                        event: \"JOIN\",\r\n                    })\r\n                );\r\n            },\r\n            onMessage: (e) => {\r\n                const dataFromServer = JSON.parse(e.data);\r\n                switch (dataFromServer.payload.event) {\r\n                    case \"JOIN\":\r\n                        if (\r\n                            dataFromServer.payload.message.opponentName === name\r\n                        )\r\n                            break;\r\n                        setOpponentName(\r\n                            dataFromServer.payload.message.opponentName\r\n                        );\r\n\r\n                        sendMessage(\r\n                            JSON.stringify({\r\n                                type: \"send_message\",\r\n                                message: {\r\n                                    opponentName: name,\r\n                                    opponentColour: playerColour,\r\n                                },\r\n                                event: \"JOIN_RESPONSE\",\r\n                            })\r\n                        );\r\n                        if (playerColour === \"white\") timer.start();\r\n                        else opponentTimer.start();\r\n                        break;\r\n\r\n                    // Message received from player already in the room after joining\r\n                    case \"JOIN_RESPONSE\":\r\n                        setStart(true);\r\n                        if (\r\n                            dataFromServer.payload.message.opponentName === name\r\n                        )\r\n                            break;\r\n\r\n                        // Start whites timer\r\n                        if (playerColour === \"white\") timer.start();\r\n                        else opponentTimer.start();\r\n\r\n                        setPlayerColour(\"black\");\r\n                        setIsTurn(false);\r\n                        setOpponentName(\r\n                            dataFromServer.payload.message.opponentName\r\n                        );\r\n                        break;\r\n\r\n                    case \"END\":\r\n                        // If a player receives the end message, they won\r\n                        setWinner(\r\n                            dataFromServer.payload.message.winnerColour ===\r\n                                playerColour\r\n                        );\r\n                        break;\r\n\r\n                    case \"MOVE\":\r\n                        // Ensure that the message is not from self\r\n                        if (\r\n                            dataFromServer.payload.message.opponent &&\r\n                            dataFromServer.payload.message.opponent.colour !==\r\n                                playerColour\r\n                        ) {\r\n                            const flippedBoard = flipBoard(\r\n                                dataFromServer.payload.message.boardState\r\n                            );\r\n                            // Make sure that the board state has changed\r\n                            // Board must be flipped since the opponent sees it from the other side\r\n                            if (\r\n                                JSON.stringify(flippedBoard) !==\r\n                                JSON.stringify(boardState)\r\n                            ) {\r\n                                playMoveAudio(flippedBoard);\r\n                                setBoardState(flippedBoard);\r\n\r\n                                setTakenPieces(\r\n                                    dataFromServer.payload.message.takenPieces\r\n                                );\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    case \"RESTART\":\r\n                        // Reset state and swap colour\r\n                        setWinner(null);\r\n                        setTakenPieces({\r\n                            white: [],\r\n                            black: [],\r\n                        });\r\n                        setPlayerColour(opponentColour);\r\n                        setIsTurn(opponentColour === \"white\");\r\n                        timer.restart(getNewTimer(), playerColour === \"white\");\r\n                        opponentTimer.restart(\r\n                            getNewTimer(),\r\n                            playerColour !== \"white\"\r\n                        );\r\n                        break;\r\n                }\r\n            },\r\n        }\r\n    );\r\n\r\n    const playMoveAudio = (newBoard) => {\r\n        if (prevBoardState === null) return;\r\n        // Pieces are removed from board state when taken\r\n        // If there is a change in the number of pieces, one has been taken\r\n        if (Object.keys(newBoard).length !== Object.keys(prevBoardState).length)\r\n            audio.capture.play();\r\n        // If no piece has been taken, play the normal move sound\r\n        else audio.move.play();\r\n    };\r\n\r\n    const handleCheckmate = () => {\r\n        // Update the kings check state\r\n        let opponentKing, playerKing;\r\n        if (boardState[\"king_w\"].isOwner) {\r\n            opponentKing = boardState[\"king_b\"];\r\n            playerKing = boardState[\"king_w\"];\r\n        } else {\r\n            opponentKing = boardState[\"king_w\"];\r\n            playerKing = boardState[\"king_b\"];\r\n        }\r\n\r\n        if (CheckIfOpponentInCheck(boardState, opponentKing)) {\r\n            audio.check.play();\r\n            opponentKing.inCheck = true;\r\n            // disables castling after check\r\n            opponentKing.hasBeenInCheck = true;\r\n        } else {\r\n            opponentKing.inCheck = false;\r\n        }\r\n        // This state will be updated when on the opponents side and sent to the player\r\n        if (playerKing.inCheck) {\r\n            audio.check.play();\r\n        }\r\n    };\r\n\r\n    const checkForGameOver = () => {\r\n        for (let y = 0; y < 8; y++) {\r\n            for (let x = 0; x < 8; x++) {\r\n                for (const [piece, state] of Object.entries(boardState)) {\r\n                    // If a piece can be moved, the game is not over\r\n                    if (\r\n                        state.isOwner &&\r\n                        state.isAlive &&\r\n                        CanMovePiece(\r\n                            x,\r\n                            y,\r\n                            { pieceName: piece, pieceState: state },\r\n                            boardState\r\n                        )\r\n                    )\r\n                        return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n\r\n    useEffect(() => {\r\n        // Send the current board state to the websocket group\r\n        // Only send message if the board state has changed to avoid infintite loop of sending\r\n        playMoveAudio(boardState);\r\n        handleCheckmate();\r\n\r\n        if (prevBoardState) {\r\n            sendMessage(\r\n                JSON.stringify({\r\n                    type: \"send_message\",\r\n                    message: {\r\n                        boardState,\r\n                        takenPieces,\r\n                        opponent: { name: name, colour: playerColour },\r\n                    },\r\n                    event: \"MOVE\",\r\n                })\r\n            );\r\n\r\n            // True if there are no possible moves, meaning the opponent won\r\n            if (checkForGameOver()) {\r\n                // Tell the other player that they won\r\n                sendMessage(\r\n                    JSON.stringify({\r\n                        type: \"send_message\",\r\n                        message: { winnerColour: opponentColour },\r\n                        event: \"END\",\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        // Swap turns\r\n        setIsTurn((prev) => !prev);\r\n        // Toggle timers\r\n        if (start) {\r\n            if (isTurn) {\r\n                timer.resume();\r\n                opponentTimer.pause();\r\n            } else {\r\n                opponentTimer.resume();\r\n                timer.pause();\r\n            }\r\n        }\r\n\r\n        setPrevBoardState({ ...boardState });\r\n    }, [boardState]);\r\n\r\n    useEffect(() => {\r\n        // Reset the board the the colour is swapped\r\n        // Dont do this when first joining a room\r\n        if (prevBoardState !== null) {\r\n            setPrevBoardState(null);\r\n            setBoardState(\r\n                initBoardState(\r\n                    playerColour === \"white\",\r\n                    getBoardRotation(playerColour)\r\n                )\r\n            );\r\n        }\r\n    }, [playerColour]);\r\n\r\n    const restartGame = () => {\r\n        // Tell the group to restart game and switch sides\r\n        sendMessage(\r\n            JSON.stringify({\r\n                type: \"send_message\",\r\n                message: null,\r\n                event: \"RESTART\",\r\n            })\r\n        );\r\n    };\r\n\r\n    const navigate = useNavigate();\r\n\r\n    const exitRoom = () => {\r\n        // Return to room join page\r\n        navigate(\"/join\");\r\n    };\r\n\r\n    return (\r\n        <Container>\r\n            <Buttons>\r\n                <Button\r\n                    style={{ marginBottom: \"20px\" }}\r\n                    colour={\"rgb(120, 210, 33)\"}\r\n                    onClick={restartGame}\r\n                >\r\n                    Swap\r\n                </Button>\r\n                <Button colour={\"rgb(198, 34, 34)\"} onClick={exitRoom}>\r\n                    Exit\r\n                </Button>\r\n            </Buttons>\r\n            <GameContainer>\r\n                <RoomNumber>Room {room}</RoomNumber>\r\n\r\n                <Player>\r\n                    <PlayerData>\r\n                        <PlayerName>{opponentName}</PlayerName>\r\n                        <TakenPieces>\r\n                            {takenPieces[playerColour].map((piecePath, i) => {\r\n                                return <img key={i} src={piecePath} />;\r\n                            })}\r\n                        </TakenPieces>\r\n                    </PlayerData>\r\n                    <Timer>\r\n                        <span>{opponentTimer.minutes}</span>:\r\n                        <span>\r\n                            {opponentTimer.seconds < 10\r\n                                ? \"0\" + opponentTimer.seconds\r\n                                : opponentTimer.seconds}\r\n                        </span>\r\n                    </Timer>\r\n                </Player>\r\n                <GamePlayer>\r\n                    <Board\r\n                        boardState={boardState}\r\n                        setBoardState={setBoardState}\r\n                        setTakenPieces={setTakenPieces}\r\n                        isTurn={isTurn}\r\n                    />\r\n                    <GameOver\r\n                        show={winner !== null}\r\n                        winner={winner}\r\n                        restartGame={restartGame}\r\n                        exitRoom={exitRoom}\r\n                    />\r\n                </GamePlayer>\r\n                <Player>\r\n                    <PlayerData>\r\n                        <PlayerName>{name}</PlayerName>\r\n                        <TakenPieces>\r\n                            {takenPieces[opponentColour].map((piecePath, i) => {\r\n                                return <img key={i} src={piecePath} />;\r\n                            })}\r\n                        </TakenPieces>\r\n                    </PlayerData>\r\n\r\n                    <Timer>\r\n                        <span>{timer.minutes}</span>:\r\n                        <span>\r\n                            {timer.seconds < 10\r\n                                ? \"0\" + timer.seconds\r\n                                : timer.seconds}\r\n                        </span>\r\n                    </Timer>\r\n                </Player>\r\n            </GameContainer>\r\n        </Container>\r\n    );\r\n};\r\n\r\nexport default Chess;\r\n\r\nconst getBoardRotation = (colour) => {\r\n    if (colour === \"white\") return { white: [7, 6], black: [0, 1] };\r\n    else if (colour === \"black\") return { white: [0, 1], black: [7, 6] };\r\n    throw \"Colour must be black or white\";\r\n};\r\n\r\nconst flipBoard = (boardState) => {\r\n    for (const [key, state] of Object.entries(boardState)) {\r\n        if (key !== \"turn\") {\r\n            state.row = 7 - state.row;\r\n            state.isOwner = !state.isOwner;\r\n        }\r\n    }\r\n    return boardState;\r\n};\r\n\r\nexport const initBoardState = (isWhite, boardRotation) => {\r\n    const pieceNames = [\r\n        \"castle_w_1\",\r\n        \"knight_w_1\",\r\n        \"bishop_w_1\",\r\n        \"queen_w\",\r\n        \"king_w\",\r\n        \"bishop_w_2\",\r\n        \"knight_w_2\",\r\n        \"castle_w_2\",\r\n        \"pawn_w_1\",\r\n        \"pawn_w_2\",\r\n        \"pawn_w_3\",\r\n        \"pawn_w_4\",\r\n        \"pawn_w_5\",\r\n        \"pawn_w_6\",\r\n        \"pawn_w_7\",\r\n        \"pawn_w_8\",\r\n        \"castle_b_1\",\r\n        \"knight_b_1\",\r\n        \"bishop_b_1\",\r\n        \"queen_b\",\r\n        \"king_b\",\r\n        \"bishop_b_2\",\r\n        \"knight_b_2\",\r\n        \"castle_b_2\",\r\n        \"pawn_b_1\",\r\n        \"pawn_b_2\",\r\n        \"pawn_b_3\",\r\n        \"pawn_b_4\",\r\n        \"pawn_b_5\",\r\n        \"pawn_b_6\",\r\n        \"pawn_b_7\",\r\n        \"pawn_b_8\",\r\n    ];\r\n    const boardState = {};\r\n    for (let i = 0; i < 32; i++) {\r\n        const pieceName = pieceNames[i].split(\"_\")[0];\r\n        // First 16 elements in  pieces array are white rest are black\r\n        // Each 8 elements in array is a row\r\n        if (i < 16) {\r\n            let row;\r\n            if (i < 8) row = boardRotation.white[0];\r\n            else row = boardRotation.white[1];\r\n            const properties = {\r\n                row: row,\r\n                col: i % 8,\r\n                isOwner: isWhite,\r\n                isAlive: true,\r\n            };\r\n            if (pieceName === \"king\") {\r\n                properties[\"inCheck\"] = false;\r\n                // Used to disable castling\r\n                properties[\"hasBeenInCheck\"] = false;\r\n                properties[\"hasMoved\"] = false;\r\n            } else if (pieceName === \"castle\") {\r\n                properties[\"hasMoved\"] = false;\r\n            } else if (pieceName === \"pawn\") {\r\n                // Used for en passant since en passant can only happen on the same turn\r\n                properties[\"movedTwoSquaresTurn\"] = null;\r\n                properties[\"hasMoved\"] = false;\r\n            }\r\n\r\n            boardState[pieceNames[i]] = properties;\r\n        } else {\r\n            let row;\r\n            if (i < 24) row = boardRotation.black[0];\r\n            else row = boardRotation.black[1];\r\n            const properties = {\r\n                row: row,\r\n                col: i % 8,\r\n                isOwner: !isWhite,\r\n                isAlive: true,\r\n            };\r\n            if (pieceName === \"king\") {\r\n                properties[\"inCheck\"] = false;\r\n                // Used to disable castling\r\n                properties[\"hasBeenInCheck\"] = false;\r\n                properties[\"hasMoved\"] = false;\r\n            } else if (pieceName === \"castle\" || pieceName === \"pawn\") {\r\n                properties[\"hasMoved\"] = false;\r\n            }\r\n\r\n            boardState[pieceNames[i]] = properties;\r\n        }\r\n    }\r\n    boardState[\"turn\"] = 0;\r\n    return boardState;\r\n};\r\n","C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\pages\\GameElements.js",[],[],"C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\components\\Board.js",[],[],"C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\components\\BoardSquare.js",[],[],"C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\components\\Constants.js",[],[],"C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\components\\ChessElements.js",[],[],"C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\components\\Game.js",[],[],"C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\pages\\RoomJoin.js",[],[],"C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\components\\Piece.js",[],[],"C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\components\\GameOver.js",[],[],"C:\\Users\\charl\\Documents\\Code\\Web Dev\\Chess-Online\\chessproject\\frontend\\src\\components\\GameOverElements.js",[],[],{"ruleId":"75","severity":1,"message":"76","line":106,"column":17,"nodeType":"77","messageId":"78","endLine":198,"endColumn":18},{"ruleId":"79","severity":1,"message":"80","line":306,"column":8,"nodeType":"81","endLine":306,"endColumn":20,"suggestions":"82"},{"ruleId":"79","severity":1,"message":"83","line":320,"column":8,"nodeType":"81","endLine":320,"endColumn":22,"suggestions":"84"},{"ruleId":"85","severity":1,"message":"86","line":362,"column":40,"nodeType":"87","endLine":362,"endColumn":71},{"ruleId":"85","severity":1,"message":"86","line":394,"column":40,"nodeType":"87","endLine":394,"endColumn":71},{"ruleId":"88","severity":1,"message":"89","line":418,"column":5,"nodeType":"90","messageId":"91","endLine":418,"endColumn":43},"default-case","Expected a default case.","SwitchStatement","missingDefaultCase","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'checkForGameOver', 'handleCheckmate', 'isTurn', 'name', 'opponentColour', 'opponentTimer', 'playMoveAudio', 'playerColour', 'prevBoardState', 'sendMessage', 'start', 'takenPieces', and 'timer'. Either include them or remove the dependency array.","ArrayExpression",["92"],"React Hook useEffect has a missing dependency: 'prevBoardState'. Either include it or remove the dependency array.",["93"],"jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object",{"desc":"94","fix":"95"},{"desc":"96","fix":"97"},"Update the dependencies array to be: [boardState, checkForGameOver, handleCheckmate, isTurn, name, opponentColour, opponentTimer, playMoveAudio, playerColour, prevBoardState, sendMessage, start, takenPieces, timer]",{"range":"98","text":"99"},"Update the dependencies array to be: [playerColour, prevBoardState]",{"range":"100","text":"101"},[11174,11186],"[boardState, checkForGameOver, handleCheckmate, isTurn, name, opponentColour, opponentTimer, playMoveAudio, playerColour, prevBoardState, sendMessage, start, takenPieces, timer]",[11611,11625],"[playerColour, prevBoardState]"]