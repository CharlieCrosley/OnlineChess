{"ast":null,"code":"import _defineProperty from\"C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";import _slicedToArray from\"C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import React,{useState}from\"react\";import useWebSocket,{ReadyState}from\"react-use-websocket\";import{useLocation}from\"react-router-dom\";import{GameContainer,GamePlayer,Player,TakenPieces}from\"./GameElements\";import Board from\"../components/Board\";import{initBoardState}from\"../components/BoardState\";import{useEffect}from\"react\";import{jsxs as _jsxs}from\"react/jsx-runtime\";import{jsx as _jsx}from\"react/jsx-runtime\";var Chess=function Chess(){var _ReadyState$CONNECTIN;//console.log(window.location.href.split(\"/\")[4]);\n//const roomNumber = window.location.href.split(\"/\")[4]\n//const playerName = window.location.href.split(\"/\")[4]\nvar location=useLocation();var _useState=useState(location.state.room),_useState2=_slicedToArray(_useState,2),room=_useState2[0],setRoom=_useState2[1];var _useState3=useState(location.state.name),_useState4=_slicedToArray(_useState3,2),name=_useState4[0],setName=_useState4[1];var _useState5=useState(null),_useState6=_slicedToArray(_useState5,2),opponentName=_useState6[0],setOpponentName=_useState6[1];var _useState7=useState(location.state.colour),_useState8=_slicedToArray(_useState7,2),playerColour=_useState8[0],setColour=_useState8[1];var _useState9=useState({white:[],black:[]}),_useState10=_slicedToArray(_useState9,2),takenPieces=_useState10[0],setTakenPieces=_useState10[1];var boardRotation=getBoardRotation(playerColour);var isWhite=playerColour===\"white\";// Sets initial piece positions ensuring that players colour is always at bottom\nvar _useState11=useState(initBoardState(isWhite,boardRotation)),_useState12=_slicedToArray(_useState11,2),boardState=_useState12[0],setBoardState=_useState12[1];var _useState13=useState(null),_useState14=_slicedToArray(_useState13,2),prevBoardState=_useState14[0],setPrevBoardState=_useState14[1];var _useWebSocket=useWebSocket(\"ws://127.0.0.1:8000/ws/\"+room+\"/\",{onOpen:function onOpen(){console.log(\"Connected!\");sendMessage(JSON.stringify({type:\"send_message\",message:{opponentName:name},event:\"START\"}));},onClose:function onClose(){console.log(\"Disconnected!\");},onMessage:function onMessage(e){var dataFromServer=JSON.parse(e.data);//console.log(\"receive\");\n//console.log(dataFromServer.payload.event);\nswitch(dataFromServer.payload.event){case\"START\":/* setOpponentName(\r\n                            dataFromServer.payload.message.opponentName\r\n                        ); */if(dataFromServer.payload.message.boardState){setBoardState(flipBoard(dataFromServer.payload.message.boardState));setTakenPieces(dataFromServer.payload.message.takenPieces);setOpponentName(dataFromServer.payload.message.opponent.name);}case\"MOVE\":if(dataFromServer.payload.message.opponent.colour!==playerColour){setBoardState(flipBoard(dataFromServer.payload.message.boardState));setTakenPieces(dataFromServer.payload.message.takenPieces);setOpponentName(dataFromServer.payload.message.opponent.name);}}}}),sendMessage=_useWebSocket.sendMessage,readyState=_useWebSocket.readyState;var connectionStatus=(_ReadyState$CONNECTIN={},_defineProperty(_ReadyState$CONNECTIN,ReadyState.CONNECTING,\"Connecting\"),_defineProperty(_ReadyState$CONNECTIN,ReadyState.OPEN,\"Open\"),_defineProperty(_ReadyState$CONNECTIN,ReadyState.CLOSING,\"Closing\"),_defineProperty(_ReadyState$CONNECTIN,ReadyState.CLOSED,\"Closed\"),_defineProperty(_ReadyState$CONNECTIN,ReadyState.UNINSTANTIATED,\"Uninstantiated\"),_ReadyState$CONNECTIN)[readyState];useEffect(function(){// Send the current board state to the websocket group\n// Only send message if the board state has changed to avoid infintite loop of sending\n//console.log(false);\nif(JSON.stringify(prevBoardState)!==JSON.stringify(boardState)){//console.log(true);\nsetPrevBoardState(boardState);sendMessage(JSON.stringify({type:\"send_message\",message:{boardState:boardState,takenPieces:takenPieces,opponent:{name:name,colour:playerColour}},event:\"MOVE\"}));}},[boardState]);var opponentColour=playerColour===\"white\"?\"black\":\"white\";return/*#__PURE__*/_jsx(GameContainer,{children:/*#__PURE__*/_jsxs(GamePlayer,{children:[/*#__PURE__*/_jsxs(\"div\",{style:{color:\"white\"},children:[\"The WebSocket is currently \",connectionStatus]}),/*#__PURE__*/_jsxs(Player,{children:[/*#__PURE__*/_jsx(\"div\",{children:opponentName}),/*#__PURE__*/_jsx(TakenPieces,{children:takenPieces[playerColour].map(function(piecePath,i){return/*#__PURE__*/_jsx(\"img\",{src:piecePath},i);})})]}),/*#__PURE__*/_jsx(Board,{boardState:boardState,setBoardState:setBoardState,setTakenPieces:setTakenPieces}),/*#__PURE__*/_jsxs(Player,{children:[/*#__PURE__*/_jsx(\"div\",{children:name}),/*#__PURE__*/_jsx(TakenPieces,{children:takenPieces[opponentColour].map(function(piecePath,i){return/*#__PURE__*/_jsx(\"img\",{src:piecePath},i);})})]})]})});};export default Chess;var getBoardRotation=function getBoardRotation(colour){if(colour===\"white\")return{white:[7,6],black:[0,1]};else if(colour===\"black\")return{white:[0,1],black:[7,6]};throw\"Colour must be black or white\";};var flipBoard=function flipBoard(boardState){for(var _i=0,_Object$entries=Object.entries(boardState);_i<_Object$entries.length;_i++){var _Object$entries$_i=_slicedToArray(_Object$entries[_i],2),_=_Object$entries$_i[0],state=_Object$entries$_i[1];state.row=7-state.row;state.isOwner=!state.isOwner;}return boardState;};/* var roomCode = document.getElementById(\"game_board\").getAttribute(\"room_code\");\r\nvar char_choice = document\r\n    .getElementById(\"game_board\")\r\n    .getAttribute(\"char_choice\");\r\n\r\nvar connectionString =\r\n    \"ws://\" + window.location.host + \"/ws/play/\" + roomCode + \"/\";\r\nvar gameSocket = new WebSocket(connectionString);\r\n\r\nlet myturn = true;\r\n\r\nfunction make_move(index, player) {\r\n    index = parseInt(index);\r\n    let data = {\r\n        event: \"MOVE\",\r\n        message: {\r\n            index: index,\r\n            player: player,\r\n        },\r\n    };\r\n\r\n    if (gameBoard[index] == -1) {\r\n        moveCount++;\r\n        if (player == \"X\") gameBoard[index] = 1;\r\n        else if (player == \"O\") gameBoard[index] = 0;\r\n        else {\r\n            alert(\"Invalid character choice\");\r\n            return false;\r\n        }\r\n        gameSocket.send(JSON.stringify(data));\r\n    }\r\n\r\n    elementArray[index].innerHTML = player;\r\n    const win = checkWinner();\r\n    if (myturn) {\r\n        if (win) {\r\n            data = {\r\n                event: \"END\",\r\n                message: `${player} is a winner. Play again?`,\r\n            };\r\n            gameSocket.send(JSON.stringify(data));\r\n        } else if (!win && moveCount == 9) {\r\n            data = {\r\n                event: \"END\",\r\n                message: \"It's a draw. Play again?\",\r\n            };\r\n            gameSocket.send(JSON.stringify(data));\r\n        }\r\n    }\r\n}\r\n\r\nfunction connect() {\r\n    gameSocket.onopen = function open() {\r\n        console.log(\"WebSockets connection created.\");\r\n        gameSocket.send(\r\n            JSON.stringify({\r\n                event: \"START\",\r\n                message: \"\",\r\n            })\r\n        );\r\n    };\r\n\r\n    gameSocket.onclose = function (e) {\r\n        console.log(\r\n            \"Socket is closed. Reconnect will be attempted in 1 second.\",\r\n            e.reason\r\n        );\r\n        setTimeout(function () {\r\n            connect();\r\n        }, 1000);\r\n    };\r\n    // Sending the info about the room\r\n    gameSocket.onmessage = function (e) {\r\n        let data = JSON.parse(e.data);\r\n        data = data[\"payload\"];\r\n        let message = data[\"message\"];\r\n        let event = data[\"event\"];\r\n        switch (event) {\r\n            case \"START\":\r\n                //reset();\r\n                break;\r\n            case \"END\":\r\n                alert(message);\r\n                //reset();\r\n                break;\r\n            case \"MOVE\":\r\n                if (message[\"player\"] != char_choice) {\r\n                    make_move(message[\"index\"], message[\"player\"]);\r\n                    myturn = true;\r\n                    document.getElementById(\"alert_move\").style.display =\r\n                        \"inline\";\r\n                }\r\n                break;\r\n            default:\r\n                console.log(\"No event\");\r\n        }\r\n    };\r\n\r\n    if (gameSocket.readyState == WebSocket.OPEN) {\r\n        gameSocket.onopen();\r\n    }\r\n}\r\n\r\nconnect(); */","map":{"version":3,"names":["React","useState","useWebSocket","ReadyState","useLocation","GameContainer","GamePlayer","Player","TakenPieces","Board","initBoardState","useEffect","Chess","location","state","room","setRoom","name","setName","opponentName","setOpponentName","colour","playerColour","setColour","white","black","takenPieces","setTakenPieces","boardRotation","getBoardRotation","isWhite","boardState","setBoardState","prevBoardState","setPrevBoardState","onOpen","console","log","sendMessage","JSON","stringify","type","message","event","onClose","onMessage","e","dataFromServer","parse","data","payload","flipBoard","opponent","readyState","connectionStatus","CONNECTING","OPEN","CLOSING","CLOSED","UNINSTANTIATED","opponentColour","color","map","piecePath","i","Object","entries","_","row","isOwner"],"sources":["C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/src/pages/Chess.js"],"sourcesContent":["import React, { useState } from \"react\";\r\nimport useWebSocket, { ReadyState } from \"react-use-websocket\";\r\nimport { useLocation } from \"react-router-dom\";\r\nimport { GameContainer, GamePlayer, Player, TakenPieces } from \"./GameElements\";\r\nimport Board from \"../components/Board\";\r\nimport { initBoardState } from \"../components/BoardState\";\r\nimport { useEffect } from \"react\";\r\n\r\nconst Chess = () => {\r\n    //console.log(window.location.href.split(\"/\")[4]);\r\n    //const roomNumber = window.location.href.split(\"/\")[4]\r\n    //const playerName = window.location.href.split(\"/\")[4]\r\n\r\n    const location = useLocation();\r\n\r\n    const [room, setRoom] = useState(location.state.room);\r\n    const [name, setName] = useState(location.state.name);\r\n    const [opponentName, setOpponentName] = useState(null);\r\n    const [playerColour, setColour] = useState(location.state.colour);\r\n    const [takenPieces, setTakenPieces] = useState({ white: [], black: [] });\r\n\r\n    const boardRotation = getBoardRotation(playerColour);\r\n    const isWhite = playerColour === \"white\";\r\n    // Sets initial piece positions ensuring that players colour is always at bottom\r\n    const [boardState, setBoardState] = useState(\r\n        initBoardState(isWhite, boardRotation)\r\n    );\r\n    const [prevBoardState, setPrevBoardState] = useState(null);\r\n\r\n    const { sendMessage, readyState } = useWebSocket(\r\n        \"ws://127.0.0.1:8000/ws/\" + room + \"/\",\r\n        {\r\n            onOpen: () => {\r\n                console.log(\"Connected!\");\r\n                sendMessage(\r\n                    JSON.stringify({\r\n                        type: \"send_message\",\r\n                        message: { opponentName: name },\r\n                        event: \"START\",\r\n                    })\r\n                );\r\n            },\r\n            onClose: () => {\r\n                console.log(\"Disconnected!\");\r\n            },\r\n            onMessage: (e) => {\r\n                const dataFromServer = JSON.parse(e.data);\r\n                //console.log(\"receive\");\r\n                //console.log(dataFromServer.payload.event);\r\n                switch (dataFromServer.payload.event) {\r\n                    case \"START\":\r\n                        /* setOpponentName(\r\n                            dataFromServer.payload.message.opponentName\r\n                        ); */\r\n                        if (dataFromServer.payload.message.boardState) {\r\n                            setBoardState(\r\n                                flipBoard(\r\n                                    dataFromServer.payload.message.boardState\r\n                                )\r\n                            );\r\n\r\n                            setTakenPieces(\r\n                                dataFromServer.payload.message.takenPieces\r\n                            );\r\n                            setOpponentName(\r\n                                dataFromServer.payload.message.opponent.name\r\n                            );\r\n                        }\r\n\r\n                    case \"MOVE\":\r\n                        if (\r\n                            dataFromServer.payload.message.opponent.colour !==\r\n                            playerColour\r\n                        ) {\r\n                            setBoardState(\r\n                                flipBoard(\r\n                                    dataFromServer.payload.message.boardState\r\n                                )\r\n                            );\r\n\r\n                            setTakenPieces(\r\n                                dataFromServer.payload.message.takenPieces\r\n                            );\r\n                            setOpponentName(\r\n                                dataFromServer.payload.message.opponent.name\r\n                            );\r\n                        }\r\n                }\r\n            },\r\n        }\r\n    );\r\n\r\n    const connectionStatus = {\r\n        [ReadyState.CONNECTING]: \"Connecting\",\r\n        [ReadyState.OPEN]: \"Open\",\r\n        [ReadyState.CLOSING]: \"Closing\",\r\n        [ReadyState.CLOSED]: \"Closed\",\r\n        [ReadyState.UNINSTANTIATED]: \"Uninstantiated\",\r\n    }[readyState];\r\n\r\n    useEffect(() => {\r\n        // Send the current board state to the websocket group\r\n        // Only send message if the board state has changed to avoid infintite loop of sending\r\n        //console.log(false);\r\n        if (JSON.stringify(prevBoardState) !== JSON.stringify(boardState)) {\r\n            //console.log(true);\r\n            setPrevBoardState(boardState);\r\n            sendMessage(\r\n                JSON.stringify({\r\n                    type: \"send_message\",\r\n                    message: {\r\n                        boardState,\r\n                        takenPieces,\r\n                        opponent: { name: name, colour: playerColour },\r\n                    },\r\n                    event: \"MOVE\",\r\n                })\r\n            );\r\n        }\r\n    }, [boardState]);\r\n\r\n    const opponentColour = playerColour === \"white\" ? \"black\" : \"white\";\r\n\r\n    return (\r\n        <GameContainer>\r\n            <GamePlayer>\r\n                <div style={{ color: \"white\" }}>\r\n                    The WebSocket is currently {connectionStatus}\r\n                </div>\r\n                <Player>\r\n                    <div>{opponentName}</div>\r\n                    <TakenPieces>\r\n                        {takenPieces[playerColour].map((piecePath, i) => {\r\n                            return <img key={i} src={piecePath} />;\r\n                        })}\r\n                    </TakenPieces>\r\n                </Player>\r\n                <Board\r\n                    boardState={boardState}\r\n                    setBoardState={setBoardState}\r\n                    setTakenPieces={setTakenPieces}\r\n                />\r\n                <Player>\r\n                    <div>{name}</div>\r\n                    <TakenPieces>\r\n                        {takenPieces[opponentColour].map((piecePath, i) => {\r\n                            return <img key={i} src={piecePath} />;\r\n                        })}\r\n                    </TakenPieces>\r\n                </Player>\r\n            </GamePlayer>\r\n        </GameContainer>\r\n    );\r\n};\r\n\r\nexport default Chess;\r\n\r\nconst getBoardRotation = (colour) => {\r\n    if (colour === \"white\") return { white: [7, 6], black: [0, 1] };\r\n    else if (colour === \"black\") return { white: [0, 1], black: [7, 6] };\r\n    throw \"Colour must be black or white\";\r\n};\r\n\r\nconst flipBoard = (boardState) => {\r\n    for (const [_, state] of Object.entries(boardState)) {\r\n        state.row = 7 - state.row;\r\n        state.isOwner = !state.isOwner;\r\n    }\r\n    return boardState;\r\n};\r\n\r\n/* var roomCode = document.getElementById(\"game_board\").getAttribute(\"room_code\");\r\nvar char_choice = document\r\n    .getElementById(\"game_board\")\r\n    .getAttribute(\"char_choice\");\r\n\r\nvar connectionString =\r\n    \"ws://\" + window.location.host + \"/ws/play/\" + roomCode + \"/\";\r\nvar gameSocket = new WebSocket(connectionString);\r\n\r\nlet myturn = true;\r\n\r\nfunction make_move(index, player) {\r\n    index = parseInt(index);\r\n    let data = {\r\n        event: \"MOVE\",\r\n        message: {\r\n            index: index,\r\n            player: player,\r\n        },\r\n    };\r\n\r\n    if (gameBoard[index] == -1) {\r\n        moveCount++;\r\n        if (player == \"X\") gameBoard[index] = 1;\r\n        else if (player == \"O\") gameBoard[index] = 0;\r\n        else {\r\n            alert(\"Invalid character choice\");\r\n            return false;\r\n        }\r\n        gameSocket.send(JSON.stringify(data));\r\n    }\r\n\r\n    elementArray[index].innerHTML = player;\r\n    const win = checkWinner();\r\n    if (myturn) {\r\n        if (win) {\r\n            data = {\r\n                event: \"END\",\r\n                message: `${player} is a winner. Play again?`,\r\n            };\r\n            gameSocket.send(JSON.stringify(data));\r\n        } else if (!win && moveCount == 9) {\r\n            data = {\r\n                event: \"END\",\r\n                message: \"It's a draw. Play again?\",\r\n            };\r\n            gameSocket.send(JSON.stringify(data));\r\n        }\r\n    }\r\n}\r\n\r\nfunction connect() {\r\n    gameSocket.onopen = function open() {\r\n        console.log(\"WebSockets connection created.\");\r\n        gameSocket.send(\r\n            JSON.stringify({\r\n                event: \"START\",\r\n                message: \"\",\r\n            })\r\n        );\r\n    };\r\n\r\n    gameSocket.onclose = function (e) {\r\n        console.log(\r\n            \"Socket is closed. Reconnect will be attempted in 1 second.\",\r\n            e.reason\r\n        );\r\n        setTimeout(function () {\r\n            connect();\r\n        }, 1000);\r\n    };\r\n    // Sending the info about the room\r\n    gameSocket.onmessage = function (e) {\r\n        let data = JSON.parse(e.data);\r\n        data = data[\"payload\"];\r\n        let message = data[\"message\"];\r\n        let event = data[\"event\"];\r\n        switch (event) {\r\n            case \"START\":\r\n                //reset();\r\n                break;\r\n            case \"END\":\r\n                alert(message);\r\n                //reset();\r\n                break;\r\n            case \"MOVE\":\r\n                if (message[\"player\"] != char_choice) {\r\n                    make_move(message[\"index\"], message[\"player\"]);\r\n                    myturn = true;\r\n                    document.getElementById(\"alert_move\").style.display =\r\n                        \"inline\";\r\n                }\r\n                break;\r\n            default:\r\n                console.log(\"No event\");\r\n        }\r\n    };\r\n\r\n    if (gameSocket.readyState == WebSocket.OPEN) {\r\n        gameSocket.onopen();\r\n    }\r\n}\r\n\r\nconnect(); */\r\n"],"mappings":"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CAAG,QAAnBA,iBAAmB,CAACR,MAAD,CAAY,CACjC,GAAIA,MAAM,GAAK,OAAf,CAAwB,MAAO,CAAEG,KAAK,CAAE,CAAC,CAAD,CAAI,CAAJ,CAAT,CAAiBC,KAAK,CAAE,CAAC,CAAD,CAAI,CAAJ,CAAxB,CAAP,CAAxB,IACK,IAAIJ,MAAM,GAAK,OAAf,CAAwB,MAAO,CAAEG,KAAK,CAAE,CAAC,CAAD,CAAI,CAAJ,CAAT,CAAiBC,KAAK,CAAE,CAAC,CAAD,CAAI,CAAJ,CAAxB,CAAP,CAC7B,KAAM,+BAAN,CACH,CAJD,CAMA,GAAM0B,UAAS,CAAG,QAAZA,UAAY,CAACpB,UAAD,CAAgB,CAC9B,6BAAyBkC,MAAM,CAACC,OAAP,CAAenC,UAAf,CAAzB,gCAAqD,CAAhD,6DAAOoC,CAAP,uBAAUrD,KAAV,uBACDA,KAAK,CAACsD,GAAN,CAAY,EAAItD,KAAK,CAACsD,GAAtB,CACAtD,KAAK,CAACuD,OAAN,CAAgB,CAACvD,KAAK,CAACuD,OAAvB,CACH,CACD,MAAOtC,WAAP,CACH,CAND,CAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}