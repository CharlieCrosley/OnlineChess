{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\charl\\\\Documents\\\\Code\\\\Web Dev\\\\Chess-Online\\\\chessproject\\\\frontend\\\\src\\\\pages\\\\Chess.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect } from \"react\";\nimport useWebSocket from \"react-use-websocket\";\nimport { useLocation, useNavigate } from \"react-router-dom\";\nimport { Container, GameContainer, GamePlayer, Player, TakenPieces, Buttons, PlayerName, PlayerData, RoomNumber, Timer } from \"./GameElements\";\nimport Board from \"../components/Board\";\nimport { CheckIfOpponentInCheck, CanMovePiece } from \"../components/Game\";\nimport GameOver from \"../components/GameOver\";\nimport { Button } from \"../components/GameOverElements\";\nimport { useTimer } from \"react-timer-hook\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst Chess = () => {\n  _s();\n\n  const location = useLocation();\n  const [start, setStart] = useState(false);\n  const [winner, setWinner] = useState(null);\n  const [room] = useState(location.state.room); // Capitalise name\n\n  const [name] = useState(location.state.name.charAt(0).toUpperCase() + location.state.name.slice(1));\n  const [opponentName, setOpponentName] = useState(null);\n  const [playerColour, setPlayerColour] = useState(\"white\");\n  const [takenPieces, setTakenPieces] = useState({\n    white: [require(\"../assets/images/pieces/queen_b.png\"), require(\"../assets/images/pieces/king_b.png\"), require(\"../assets/images/pieces/pawn_b.png\")],\n    black: [require(\"../assets/images/pieces/queen_w.png\"), require(\"../assets/images/pieces/king_w.png\"), require(\"../assets/images/pieces/pawn_w.png\")]\n  });\n  const [isTurn, setIsTurn] = useState(true); // Sets initial piece positions ensuring that players colour is always at bottom\n\n  const [boardState, setBoardState] = useState(initBoardState(playerColour === \"white\", getBoardRotation(playerColour)));\n  const [prevBoardState, setPrevBoardState] = useState(null);\n  const [audio] = useState({\n    check: new Audio(require(\"../assets/sounds/check.mp3\")),\n    move: new Audio(require(\"../assets/sounds/move.mp3\")),\n    capture: new Audio(require(\"../assets/sounds/capture.ogg\")),\n    end: new Audio(require(\"../assets/sounds/game_end.mp3\"))\n  });\n  const opponentColour = playerColour === \"white\" ? \"black\" : \"white\";\n\n  const getNewTimer = () => {\n    const time = new Date();\n    time.setSeconds(time.getSeconds() + 600);\n    return time;\n  };\n\n  const timer = useTimer({\n    expiryTimestamp: getNewTimer(),\n    autoStart: false,\n    onExpire: () => {\n      outOfTime(playerColour === \"white\" ? \"black\" : \"white\");\n      timer.pause();\n    }\n  });\n  const opponentTimer = useTimer({\n    expiryTimestamp: getNewTimer(),\n    autoStart: false,\n    onExpire: () => {\n      outOfTime(playerColour);\n      opponentTimer.pause();\n    }\n  });\n\n  const outOfTime = winnerColour => {\n    sendMessage(JSON.stringify({\n      type: \"send_message\",\n      message: {\n        winnerColour: winnerColour\n      },\n      event: \"END\"\n    }));\n  };\n\n  const {\n    sendMessage\n  } = useWebSocket(\"ws://127.0.0.1:8000/ws/\" + room + \"/\", {\n    onOpen: () => {\n      sendMessage(JSON.stringify({\n        type: \"send_message\",\n        message: {\n          opponentName: name\n        },\n        event: \"JOIN\"\n      }));\n    },\n    onMessage: e => {\n      const dataFromServer = JSON.parse(e.data);\n\n      switch (dataFromServer.payload.event) {\n        case \"JOIN\":\n          if (dataFromServer.payload.message.opponentName === name) break;\n          setOpponentName(dataFromServer.payload.message.opponentName);\n          sendMessage(JSON.stringify({\n            type: \"send_message\",\n            message: {\n              opponentName: name,\n              opponentColour: playerColour\n            },\n            event: \"JOIN_RESPONSE\"\n          }));\n          if (playerColour === \"white\") timer.start();else opponentTimer.start();\n          break;\n        // Message received from player already in the room after joining\n\n        case \"JOIN_RESPONSE\":\n          setStart(true);\n          if (dataFromServer.payload.message.opponentName === name) break; // Start whites timer\n\n          if (playerColour === \"white\") timer.start();else opponentTime.start();\n          setPlayerColour(\"black\");\n          setIsTurn(false);\n          setOpponentName(dataFromServer.payload.message.opponentName);\n          break;\n\n        case \"END\":\n          // If a player receives the end message, they won\n          setWinner(dataFromServer.payload.message.winnerColour === playerColour);\n          break;\n\n        case \"MOVE\":\n          // Ensure that the message is not from self\n          if (dataFromServer.payload.message.opponent && dataFromServer.payload.message.opponent.colour !== playerColour) {\n            const flippedBoard = flipBoard(dataFromServer.payload.message.boardState); // Make sure that the board state has changed\n            // Board must be flipped since the opponent sees it from the other side\n\n            if (JSON.stringify(flippedBoard) !== JSON.stringify(boardState)) {\n              playMoveAudio(flippedBoard);\n              setBoardState(flippedBoard);\n              setTakenPieces(dataFromServer.payload.message.takenPieces);\n            }\n          }\n\n          break;\n\n        case \"RESTART\":\n          // Reset state and swap colour\n          setWinner(null);\n          setTakenPieces({\n            white: [],\n            black: []\n          });\n          setPlayerColour(opponentColour);\n          setIsTurn(opponentColour === \"white\");\n          timer.restart(getNewTimer(), playerColour === \"white\");\n          opponentTimer.restart(getNewTimer(), playerColour !== \"white\");\n          break;\n      }\n    }\n  });\n  useEffect(() => {\n    // Reset the board the the colour is swapped\n    // Dont do this when first joining a room\n    if (prevBoardState !== null) {\n      setPrevBoardState(null);\n      setBoardState(initBoardState(playerColour === \"white\", getBoardRotation(playerColour)));\n    }\n  }, [playerColour]);\n\n  const playMoveAudio = newBoard => {\n    if (prevBoardState === null) return; // Pieces are removed from board state when taken\n    // If there is a change in the number of pieces, one has been taken\n\n    if (Object.keys(newBoard).length !== Object.keys(prevBoardState).length) audio.capture.play(); // If no piece has been taken, play the normal move sound\n    else audio.move.play();\n  };\n\n  const handleCheckmate = () => {\n    // Update the kings check state\n    let opponentKing, playerKing;\n\n    if (boardState[\"king_w\"].isOwner) {\n      opponentKing = boardState[\"king_b\"];\n      playerKing = boardState[\"king_w\"];\n    } else {\n      opponentKing = boardState[\"king_w\"];\n      playerKing = boardState[\"king_b\"];\n    }\n\n    if (CheckIfOpponentInCheck(boardState, opponentKing)) {\n      audio.check.play();\n      opponentKing.inCheck = true; // disables castling after check\n\n      opponentKing.hasBeenInCheck = true;\n    } else {\n      opponentKing.inCheck = false;\n    } // This state will be updated when on the opponents side and sent to the player\n\n\n    if (playerKing.inCheck) {\n      audio.check.play();\n    }\n  };\n\n  const checkForGameOver = () => {\n    for (let y = 0; y < 8; y++) {\n      for (let x = 0; x < 8; x++) {\n        for (const [piece, state] of Object.entries(boardState)) {\n          // If a piece can be moved, the game is not over\n          if (state.isOwner && state.isAlive && CanMovePiece(x, y, {\n            pieceName: piece,\n            pieceState: state\n          }, boardState)) return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  useEffect(() => {\n    // Send the current board state to the websocket group\n    // Only send message if the board state has changed to avoid infintite loop of sending\n    playMoveAudio(boardState);\n    handleCheckmate();\n\n    if (prevBoardState) {\n      sendMessage(JSON.stringify({\n        type: \"send_message\",\n        message: {\n          boardState,\n          takenPieces,\n          opponent: {\n            name: name,\n            colour: playerColour\n          }\n        },\n        event: \"MOVE\"\n      })); // True if there are no possible moves, meaning the opponent won\n\n      if (checkForGameOver()) {\n        // Tell the other player that they won\n        sendMessage(JSON.stringify({\n          type: \"send_message\",\n          message: {\n            winnerColour: opponentColour\n          },\n          event: \"END\"\n        }));\n      }\n    } // Swap turns\n\n\n    setIsTurn(prev => !prev); // Toggle timers\n\n    if (start) {\n      if (isTurn) {\n        timer.resume();\n        opponentTimer.pause();\n      } else {\n        opponentTimer.resume();\n        timer.pause();\n      }\n    }\n\n    setPrevBoardState({ ...boardState\n    });\n  }, [boardState]);\n\n  const restartGame = () => {\n    // Tell the group to restart game and switch sides\n    sendMessage(JSON.stringify({\n      type: \"send_message\",\n      message: null,\n      event: \"RESTART\"\n    }));\n  };\n\n  const navigate = useNavigate();\n\n  const exitRoom = () => {\n    // Return to room join page\n    navigate(\"/join\");\n  };\n\n  return /*#__PURE__*/_jsxDEV(Container, {\n    children: [/*#__PURE__*/_jsxDEV(Buttons, {\n      children: [/*#__PURE__*/_jsxDEV(Button, {\n        style: {\n          marginBottom: \"20px\"\n        },\n        colour: \"rgb(120, 210, 33)\",\n        onClick: restartGame,\n        children: \"Swap\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 351,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Button, {\n        colour: \"rgb(198, 34, 34)\",\n        onClick: exitRoom,\n        children: \"Exit\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 358,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 350,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(GameContainer, {\n      children: [/*#__PURE__*/_jsxDEV(RoomNumber, {\n        children: [\"Room \", room]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 363,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Player, {\n        children: [/*#__PURE__*/_jsxDEV(PlayerData, {\n          children: [/*#__PURE__*/_jsxDEV(PlayerName, {\n            children: opponentName\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 367,\n            columnNumber: 25\n          }, this), /*#__PURE__*/_jsxDEV(TakenPieces, {\n            children: takenPieces[playerColour].map((piecePath, i) => {\n              return /*#__PURE__*/_jsxDEV(\"img\", {\n                src: piecePath\n              }, i, false, {\n                fileName: _jsxFileName,\n                lineNumber: 370,\n                columnNumber: 40\n              }, this);\n            })\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 368,\n            columnNumber: 25\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 366,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(Timer, {\n          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n            children: opponentTimer.minutes\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 375,\n            columnNumber: 25\n          }, this), \":\", /*#__PURE__*/_jsxDEV(\"span\", {\n            children: opponentTimer.seconds\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 376,\n            columnNumber: 25\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 374,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 365,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(GamePlayer, {\n        children: [/*#__PURE__*/_jsxDEV(Board, {\n          boardState: boardState,\n          setBoardState: setBoardState,\n          setTakenPieces: setTakenPieces,\n          isTurn: isTurn\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 380,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(GameOver, {\n          show: winner !== null,\n          winner: winner,\n          restartGame: restartGame,\n          exitRoom: exitRoom\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 386,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 379,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Player, {\n        children: [/*#__PURE__*/_jsxDEV(PlayerData, {\n          children: [/*#__PURE__*/_jsxDEV(PlayerName, {\n            children: name\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 395,\n            columnNumber: 25\n          }, this), /*#__PURE__*/_jsxDEV(TakenPieces, {\n            children: takenPieces[opponentColour].map((piecePath, i) => {\n              return /*#__PURE__*/_jsxDEV(\"img\", {\n                src: piecePath\n              }, i, false, {\n                fileName: _jsxFileName,\n                lineNumber: 398,\n                columnNumber: 40\n              }, this);\n            })\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 396,\n            columnNumber: 25\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 394,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(Timer, {\n          children: [/*#__PURE__*/_jsxDEV(\"span\", {\n            children: timer.minutes\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 404,\n            columnNumber: 25\n          }, this), \":\", /*#__PURE__*/_jsxDEV(\"span\", {\n            children: timer.seconds\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 405,\n            columnNumber: 25\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 403,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 393,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 362,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 349,\n    columnNumber: 9\n  }, this);\n};\n\n_s(Chess, \"VqV6AM6Cbk4G0ii/H8ucMaYOhD8=\", false, function () {\n  return [useLocation, useTimer, useTimer, useWebSocket, useNavigate];\n});\n\n_c = Chess;\nexport default Chess;\n\nconst getBoardRotation = colour => {\n  if (colour === \"white\") return {\n    white: [7, 6],\n    black: [0, 1]\n  };else if (colour === \"black\") return {\n    white: [0, 1],\n    black: [7, 6]\n  };\n  throw \"Colour must be black or white\";\n};\n\nconst flipBoard = boardState => {\n  for (const [key, state] of Object.entries(boardState)) {\n    if (key !== \"turn\") {\n      state.row = 7 - state.row;\n      state.isOwner = !state.isOwner;\n    }\n  }\n\n  return boardState;\n};\n\nexport const initBoardState = (isWhite, boardRotation) => {\n  const pieceNames = [\"castle_w_1\", \"knight_w_1\", \"bishop_w_1\", \"queen_w\", \"king_w\", \"bishop_w_2\", \"knight_w_2\", \"castle_w_2\", \"pawn_w_1\", \"pawn_w_2\", \"pawn_w_3\", \"pawn_w_4\", \"pawn_w_5\", \"pawn_w_6\", \"pawn_w_7\", \"pawn_w_8\", \"castle_b_1\", \"knight_b_1\", \"bishop_b_1\", \"queen_b\", \"king_b\", \"bishop_b_2\", \"knight_b_2\", \"castle_b_2\", \"pawn_b_1\", \"pawn_b_2\", \"pawn_b_3\", \"pawn_b_4\", \"pawn_b_5\", \"pawn_b_6\", \"pawn_b_7\", \"pawn_b_8\"];\n  const boardState = {};\n\n  for (let i = 0; i < 32; i++) {\n    const pieceName = pieceNames[i].split(\"_\")[0]; // First 16 elements in  pieces array are white rest are black\n    // Each 8 elements in array is a row\n\n    if (i < 16) {\n      let row;\n      if (i < 8) row = boardRotation.white[0];else row = boardRotation.white[1];\n      const properties = {\n        row: row,\n        col: i % 8,\n        isOwner: isWhite,\n        isAlive: true\n      };\n\n      if (pieceName === \"king\") {\n        properties[\"inCheck\"] = false; // Used to disable castling\n\n        properties[\"hasBeenInCheck\"] = false;\n        properties[\"hasMoved\"] = false;\n      } else if (pieceName === \"castle\") {\n        properties[\"hasMoved\"] = false;\n      } else if (pieceName === \"pawn\") {\n        // Used for en passant since en passant can only happen on the same turn\n        properties[\"movedTwoSquaresTurn\"] = null;\n        properties[\"hasMoved\"] = false;\n      }\n\n      boardState[pieceNames[i]] = properties;\n    } else {\n      let row;\n      if (i < 24) row = boardRotation.black[0];else row = boardRotation.black[1];\n      const properties = {\n        row: row,\n        col: i % 8,\n        isOwner: !isWhite,\n        isAlive: true\n      };\n\n      if (pieceName === \"king\") {\n        properties[\"inCheck\"] = false; // Used to disable castling\n\n        properties[\"hasBeenInCheck\"] = false;\n        properties[\"hasMoved\"] = false;\n      } else if (pieceName === \"castle\" || pieceName === \"pawn\") {\n        properties[\"hasMoved\"] = false;\n      }\n\n      boardState[pieceNames[i]] = properties;\n    }\n  }\n\n  boardState[\"turn\"] = 0;\n  return boardState;\n};\n\nvar _c;\n\n$RefreshReg$(_c, \"Chess\");","map":{"version":3,"names":["React","useState","useEffect","useWebSocket","useLocation","useNavigate","Container","GameContainer","GamePlayer","Player","TakenPieces","Buttons","PlayerName","PlayerData","RoomNumber","Timer","Board","CheckIfOpponentInCheck","CanMovePiece","GameOver","Button","useTimer","Chess","location","start","setStart","winner","setWinner","room","state","name","charAt","toUpperCase","slice","opponentName","setOpponentName","playerColour","setPlayerColour","takenPieces","setTakenPieces","white","require","black","isTurn","setIsTurn","boardState","setBoardState","initBoardState","getBoardRotation","prevBoardState","setPrevBoardState","audio","check","Audio","move","capture","end","opponentColour","getNewTimer","time","Date","setSeconds","getSeconds","timer","expiryTimestamp","autoStart","onExpire","outOfTime","pause","opponentTimer","winnerColour","sendMessage","JSON","stringify","type","message","event","onOpen","onMessage","e","dataFromServer","parse","data","payload","opponentTime","opponent","colour","flippedBoard","flipBoard","playMoveAudio","restart","newBoard","Object","keys","length","play","handleCheckmate","opponentKing","playerKing","isOwner","inCheck","hasBeenInCheck","checkForGameOver","y","x","piece","entries","isAlive","pieceName","pieceState","prev","resume","restartGame","navigate","exitRoom","marginBottom","map","piecePath","i","minutes","seconds","key","row","isWhite","boardRotation","pieceNames","split","properties","col"],"sources":["C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/src/pages/Chess.js"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\r\nimport useWebSocket from \"react-use-websocket\";\r\nimport { useLocation, useNavigate } from \"react-router-dom\";\r\nimport {\r\n    Container,\r\n    GameContainer,\r\n    GamePlayer,\r\n    Player,\r\n    TakenPieces,\r\n    Buttons,\r\n    PlayerName,\r\n    PlayerData,\r\n    RoomNumber,\r\n    Timer,\r\n} from \"./GameElements\";\r\nimport Board from \"../components/Board\";\r\nimport { CheckIfOpponentInCheck, CanMovePiece } from \"../components/Game\";\r\nimport GameOver from \"../components/GameOver\";\r\nimport { Button } from \"../components/GameOverElements\";\r\nimport { useTimer } from \"react-timer-hook\";\r\n\r\nconst Chess = () => {\r\n    const location = useLocation();\r\n\r\n    const [start, setStart] = useState(false);\r\n    const [winner, setWinner] = useState(null);\r\n    const [room] = useState(location.state.room);\r\n    // Capitalise name\r\n    const [name] = useState(\r\n        location.state.name.charAt(0).toUpperCase() +\r\n            location.state.name.slice(1)\r\n    );\r\n    const [opponentName, setOpponentName] = useState(null);\r\n    const [playerColour, setPlayerColour] = useState(\"white\");\r\n    const [takenPieces, setTakenPieces] = useState({\r\n        white: [\r\n            require(\"../assets/images/pieces/queen_b.png\"),\r\n            require(\"../assets/images/pieces/king_b.png\"),\r\n            require(\"../assets/images/pieces/pawn_b.png\"),\r\n        ],\r\n        black: [\r\n            require(\"../assets/images/pieces/queen_w.png\"),\r\n            require(\"../assets/images/pieces/king_w.png\"),\r\n            require(\"../assets/images/pieces/pawn_w.png\"),\r\n        ],\r\n    });\r\n    const [isTurn, setIsTurn] = useState(true);\r\n\r\n    // Sets initial piece positions ensuring that players colour is always at bottom\r\n    const [boardState, setBoardState] = useState(\r\n        initBoardState(playerColour === \"white\", getBoardRotation(playerColour))\r\n    );\r\n    const [prevBoardState, setPrevBoardState] = useState(null);\r\n\r\n    const [audio] = useState({\r\n        check: new Audio(require(\"../assets/sounds/check.mp3\")),\r\n        move: new Audio(require(\"../assets/sounds/move.mp3\")),\r\n        capture: new Audio(require(\"../assets/sounds/capture.ogg\")),\r\n        end: new Audio(require(\"../assets/sounds/game_end.mp3\")),\r\n    });\r\n\r\n    const opponentColour = playerColour === \"white\" ? \"black\" : \"white\";\r\n\r\n    const getNewTimer = () => {\r\n        const time = new Date();\r\n        time.setSeconds(time.getSeconds() + 600);\r\n        return time;\r\n    };\r\n\r\n    const timer = useTimer({\r\n        expiryTimestamp: getNewTimer(),\r\n        autoStart: false,\r\n        onExpire: () => {\r\n            outOfTime(playerColour === \"white\" ? \"black\" : \"white\");\r\n            timer.pause();\r\n        },\r\n    });\r\n\r\n    const opponentTimer = useTimer({\r\n        expiryTimestamp: getNewTimer(),\r\n        autoStart: false,\r\n        onExpire: () => {\r\n            outOfTime(playerColour);\r\n            opponentTimer.pause();\r\n        },\r\n    });\r\n\r\n    const outOfTime = (winnerColour) => {\r\n        sendMessage(\r\n            JSON.stringify({\r\n                type: \"send_message\",\r\n                message: { winnerColour: winnerColour },\r\n                event: \"END\",\r\n            })\r\n        );\r\n    };\r\n\r\n    const { sendMessage } = useWebSocket(\r\n        \"ws://127.0.0.1:8000/ws/\" + room + \"/\",\r\n        {\r\n            onOpen: () => {\r\n                sendMessage(\r\n                    JSON.stringify({\r\n                        type: \"send_message\",\r\n                        message: {\r\n                            opponentName: name,\r\n                        },\r\n                        event: \"JOIN\",\r\n                    })\r\n                );\r\n            },\r\n            onMessage: (e) => {\r\n                const dataFromServer = JSON.parse(e.data);\r\n                switch (dataFromServer.payload.event) {\r\n                    case \"JOIN\":\r\n                        if (\r\n                            dataFromServer.payload.message.opponentName === name\r\n                        )\r\n                            break;\r\n                        setOpponentName(\r\n                            dataFromServer.payload.message.opponentName\r\n                        );\r\n\r\n                        sendMessage(\r\n                            JSON.stringify({\r\n                                type: \"send_message\",\r\n                                message: {\r\n                                    opponentName: name,\r\n                                    opponentColour: playerColour,\r\n                                },\r\n                                event: \"JOIN_RESPONSE\",\r\n                            })\r\n                        );\r\n                        if (playerColour === \"white\") timer.start();\r\n                        else opponentTimer.start();\r\n                        break;\r\n\r\n                    // Message received from player already in the room after joining\r\n                    case \"JOIN_RESPONSE\":\r\n                        setStart(true);\r\n                        if (\r\n                            dataFromServer.payload.message.opponentName === name\r\n                        )\r\n                            break;\r\n\r\n                        // Start whites timer\r\n                        if (playerColour === \"white\") timer.start();\r\n                        else opponentTime.start();\r\n\r\n                        setPlayerColour(\"black\");\r\n                        setIsTurn(false);\r\n                        setOpponentName(\r\n                            dataFromServer.payload.message.opponentName\r\n                        );\r\n                        break;\r\n\r\n                    case \"END\":\r\n                        // If a player receives the end message, they won\r\n                        setWinner(\r\n                            dataFromServer.payload.message.winnerColour ===\r\n                                playerColour\r\n                        );\r\n                        break;\r\n\r\n                    case \"MOVE\":\r\n                        // Ensure that the message is not from self\r\n                        if (\r\n                            dataFromServer.payload.message.opponent &&\r\n                            dataFromServer.payload.message.opponent.colour !==\r\n                                playerColour\r\n                        ) {\r\n                            const flippedBoard = flipBoard(\r\n                                dataFromServer.payload.message.boardState\r\n                            );\r\n                            // Make sure that the board state has changed\r\n                            // Board must be flipped since the opponent sees it from the other side\r\n                            if (\r\n                                JSON.stringify(flippedBoard) !==\r\n                                JSON.stringify(boardState)\r\n                            ) {\r\n                                playMoveAudio(flippedBoard);\r\n                                setBoardState(flippedBoard);\r\n\r\n                                setTakenPieces(\r\n                                    dataFromServer.payload.message.takenPieces\r\n                                );\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    case \"RESTART\":\r\n                        // Reset state and swap colour\r\n                        setWinner(null);\r\n                        setTakenPieces({\r\n                            white: [],\r\n                            black: [],\r\n                        });\r\n                        setPlayerColour(opponentColour);\r\n                        setIsTurn(opponentColour === \"white\");\r\n                        timer.restart(getNewTimer(), playerColour === \"white\");\r\n                        opponentTimer.restart(\r\n                            getNewTimer(),\r\n                            playerColour !== \"white\"\r\n                        );\r\n                        break;\r\n                }\r\n            },\r\n        }\r\n    );\r\n\r\n    useEffect(() => {\r\n        // Reset the board the the colour is swapped\r\n        // Dont do this when first joining a room\r\n        if (prevBoardState !== null) {\r\n            setPrevBoardState(null);\r\n            setBoardState(\r\n                initBoardState(\r\n                    playerColour === \"white\",\r\n                    getBoardRotation(playerColour)\r\n                )\r\n            );\r\n        }\r\n    }, [playerColour]);\r\n\r\n    const playMoveAudio = (newBoard) => {\r\n        if (prevBoardState === null) return;\r\n        // Pieces are removed from board state when taken\r\n        // If there is a change in the number of pieces, one has been taken\r\n        if (Object.keys(newBoard).length !== Object.keys(prevBoardState).length)\r\n            audio.capture.play();\r\n        // If no piece has been taken, play the normal move sound\r\n        else audio.move.play();\r\n    };\r\n\r\n    const handleCheckmate = () => {\r\n        // Update the kings check state\r\n        let opponentKing, playerKing;\r\n        if (boardState[\"king_w\"].isOwner) {\r\n            opponentKing = boardState[\"king_b\"];\r\n            playerKing = boardState[\"king_w\"];\r\n        } else {\r\n            opponentKing = boardState[\"king_w\"];\r\n            playerKing = boardState[\"king_b\"];\r\n        }\r\n\r\n        if (CheckIfOpponentInCheck(boardState, opponentKing)) {\r\n            audio.check.play();\r\n            opponentKing.inCheck = true;\r\n            // disables castling after check\r\n            opponentKing.hasBeenInCheck = true;\r\n        } else {\r\n            opponentKing.inCheck = false;\r\n        }\r\n        // This state will be updated when on the opponents side and sent to the player\r\n        if (playerKing.inCheck) {\r\n            audio.check.play();\r\n        }\r\n    };\r\n\r\n    const checkForGameOver = () => {\r\n        for (let y = 0; y < 8; y++) {\r\n            for (let x = 0; x < 8; x++) {\r\n                for (const [piece, state] of Object.entries(boardState)) {\r\n                    // If a piece can be moved, the game is not over\r\n                    if (\r\n                        state.isOwner &&\r\n                        state.isAlive &&\r\n                        CanMovePiece(\r\n                            x,\r\n                            y,\r\n                            { pieceName: piece, pieceState: state },\r\n                            boardState\r\n                        )\r\n                    )\r\n                        return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n\r\n    useEffect(() => {\r\n        // Send the current board state to the websocket group\r\n        // Only send message if the board state has changed to avoid infintite loop of sending\r\n        playMoveAudio(boardState);\r\n        handleCheckmate();\r\n\r\n        if (prevBoardState) {\r\n            sendMessage(\r\n                JSON.stringify({\r\n                    type: \"send_message\",\r\n                    message: {\r\n                        boardState,\r\n                        takenPieces,\r\n                        opponent: { name: name, colour: playerColour },\r\n                    },\r\n                    event: \"MOVE\",\r\n                })\r\n            );\r\n\r\n            // True if there are no possible moves, meaning the opponent won\r\n            if (checkForGameOver()) {\r\n                // Tell the other player that they won\r\n                sendMessage(\r\n                    JSON.stringify({\r\n                        type: \"send_message\",\r\n                        message: { winnerColour: opponentColour },\r\n                        event: \"END\",\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        // Swap turns\r\n        setIsTurn((prev) => !prev);\r\n        // Toggle timers\r\n        if (start) {\r\n            if (isTurn) {\r\n                timer.resume();\r\n                opponentTimer.pause();\r\n            } else {\r\n                opponentTimer.resume();\r\n                timer.pause();\r\n            }\r\n        }\r\n\r\n        setPrevBoardState({ ...boardState });\r\n    }, [boardState]);\r\n\r\n    const restartGame = () => {\r\n        // Tell the group to restart game and switch sides\r\n        sendMessage(\r\n            JSON.stringify({\r\n                type: \"send_message\",\r\n                message: null,\r\n                event: \"RESTART\",\r\n            })\r\n        );\r\n    };\r\n\r\n    const navigate = useNavigate();\r\n\r\n    const exitRoom = () => {\r\n        // Return to room join page\r\n        navigate(\"/join\");\r\n    };\r\n\r\n    return (\r\n        <Container>\r\n            <Buttons>\r\n                <Button\r\n                    style={{ marginBottom: \"20px\" }}\r\n                    colour={\"rgb(120, 210, 33)\"}\r\n                    onClick={restartGame}\r\n                >\r\n                    Swap\r\n                </Button>\r\n                <Button colour={\"rgb(198, 34, 34)\"} onClick={exitRoom}>\r\n                    Exit\r\n                </Button>\r\n            </Buttons>\r\n            <GameContainer>\r\n                <RoomNumber>Room {room}</RoomNumber>\r\n\r\n                <Player>\r\n                    <PlayerData>\r\n                        <PlayerName>{opponentName}</PlayerName>\r\n                        <TakenPieces>\r\n                            {takenPieces[playerColour].map((piecePath, i) => {\r\n                                return <img key={i} src={piecePath} />;\r\n                            })}\r\n                        </TakenPieces>\r\n                    </PlayerData>\r\n                    <Timer>\r\n                        <span>{opponentTimer.minutes}</span>:\r\n                        <span>{opponentTimer.seconds}</span>\r\n                    </Timer>\r\n                </Player>\r\n                <GamePlayer>\r\n                    <Board\r\n                        boardState={boardState}\r\n                        setBoardState={setBoardState}\r\n                        setTakenPieces={setTakenPieces}\r\n                        isTurn={isTurn}\r\n                    />\r\n                    <GameOver\r\n                        show={winner !== null}\r\n                        winner={winner}\r\n                        restartGame={restartGame}\r\n                        exitRoom={exitRoom}\r\n                    />\r\n                </GamePlayer>\r\n                <Player>\r\n                    <PlayerData>\r\n                        <PlayerName>{name}</PlayerName>\r\n                        <TakenPieces>\r\n                            {takenPieces[opponentColour].map((piecePath, i) => {\r\n                                return <img key={i} src={piecePath} />;\r\n                            })}\r\n                        </TakenPieces>\r\n                    </PlayerData>\r\n\r\n                    <Timer>\r\n                        <span>{timer.minutes}</span>:\r\n                        <span>{timer.seconds}</span>\r\n                    </Timer>\r\n                </Player>\r\n            </GameContainer>\r\n        </Container>\r\n    );\r\n};\r\n\r\nexport default Chess;\r\n\r\nconst getBoardRotation = (colour) => {\r\n    if (colour === \"white\") return { white: [7, 6], black: [0, 1] };\r\n    else if (colour === \"black\") return { white: [0, 1], black: [7, 6] };\r\n    throw \"Colour must be black or white\";\r\n};\r\n\r\nconst flipBoard = (boardState) => {\r\n    for (const [key, state] of Object.entries(boardState)) {\r\n        if (key !== \"turn\") {\r\n            state.row = 7 - state.row;\r\n            state.isOwner = !state.isOwner;\r\n        }\r\n    }\r\n    return boardState;\r\n};\r\n\r\nexport const initBoardState = (isWhite, boardRotation) => {\r\n    const pieceNames = [\r\n        \"castle_w_1\",\r\n        \"knight_w_1\",\r\n        \"bishop_w_1\",\r\n        \"queen_w\",\r\n        \"king_w\",\r\n        \"bishop_w_2\",\r\n        \"knight_w_2\",\r\n        \"castle_w_2\",\r\n        \"pawn_w_1\",\r\n        \"pawn_w_2\",\r\n        \"pawn_w_3\",\r\n        \"pawn_w_4\",\r\n        \"pawn_w_5\",\r\n        \"pawn_w_6\",\r\n        \"pawn_w_7\",\r\n        \"pawn_w_8\",\r\n        \"castle_b_1\",\r\n        \"knight_b_1\",\r\n        \"bishop_b_1\",\r\n        \"queen_b\",\r\n        \"king_b\",\r\n        \"bishop_b_2\",\r\n        \"knight_b_2\",\r\n        \"castle_b_2\",\r\n        \"pawn_b_1\",\r\n        \"pawn_b_2\",\r\n        \"pawn_b_3\",\r\n        \"pawn_b_4\",\r\n        \"pawn_b_5\",\r\n        \"pawn_b_6\",\r\n        \"pawn_b_7\",\r\n        \"pawn_b_8\",\r\n    ];\r\n    const boardState = {};\r\n    for (let i = 0; i < 32; i++) {\r\n        const pieceName = pieceNames[i].split(\"_\")[0];\r\n        // First 16 elements in  pieces array are white rest are black\r\n        // Each 8 elements in array is a row\r\n        if (i < 16) {\r\n            let row;\r\n            if (i < 8) row = boardRotation.white[0];\r\n            else row = boardRotation.white[1];\r\n            const properties = {\r\n                row: row,\r\n                col: i % 8,\r\n                isOwner: isWhite,\r\n                isAlive: true,\r\n            };\r\n            if (pieceName === \"king\") {\r\n                properties[\"inCheck\"] = false;\r\n                // Used to disable castling\r\n                properties[\"hasBeenInCheck\"] = false;\r\n                properties[\"hasMoved\"] = false;\r\n            } else if (pieceName === \"castle\") {\r\n                properties[\"hasMoved\"] = false;\r\n            } else if (pieceName === \"pawn\") {\r\n                // Used for en passant since en passant can only happen on the same turn\r\n                properties[\"movedTwoSquaresTurn\"] = null;\r\n                properties[\"hasMoved\"] = false;\r\n            }\r\n\r\n            boardState[pieceNames[i]] = properties;\r\n        } else {\r\n            let row;\r\n            if (i < 24) row = boardRotation.black[0];\r\n            else row = boardRotation.black[1];\r\n            const properties = {\r\n                row: row,\r\n                col: i % 8,\r\n                isOwner: !isWhite,\r\n                isAlive: true,\r\n            };\r\n            if (pieceName === \"king\") {\r\n                properties[\"inCheck\"] = false;\r\n                // Used to disable castling\r\n                properties[\"hasBeenInCheck\"] = false;\r\n                properties[\"hasMoved\"] = false;\r\n            } else if (pieceName === \"castle\" || pieceName === \"pawn\") {\r\n                properties[\"hasMoved\"] = false;\r\n            }\r\n\r\n            boardState[pieceNames[i]] = properties;\r\n        }\r\n    }\r\n    boardState[\"turn\"] = 0;\r\n    return boardState;\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}