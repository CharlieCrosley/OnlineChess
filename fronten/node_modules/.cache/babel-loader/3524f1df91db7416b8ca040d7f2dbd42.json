{"ast":null,"code":"/**\r\n * Callback for setting the board state\r\n *\r\n * @callback setBoardState\r\n * @param {Object} board An dictionary representing the current board state\r\n */\n\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {setBoardState} setBoardState sets a new state of the board\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\nexport function MovePiece(toX, toY, setBoardState, setTakenPieces, draggedPiece, boardState) {\n  const square = GetPieceAtSquare(toX, toY, boardState);\n  const enPassantPawn = CheckIfCanEnPassant(draggedPiece, boardState); // check if piece on square\n  // Ensure piece on square is not owned and is alive before taking\n\n  if (square != null && !square.isOwner && square.state.isAlive || enPassantPawn && enPassantPawn.state.col === toX && enPassantPawn.state.row - 1 === toY) {\n    const pieceToTake = square != null ? square : enPassantPawn; // Remove piece from board\n\n    delete boardState[pieceToTake.piece]; // Track what pieces are taken so that they can be rendered under player name\n\n    const pieceNameSplit = pieceToTake.piece.split(\"_\");\n    const piecePathName = pieceNameSplit[0] + \"_\" + pieceNameSplit[1];\n\n    const pieceImgPath = require(\"../assets/images/pieces/\" + piecePathName + \".png\");\n\n    let colour;\n    if (pieceNameSplit[1] === \"w\") colour = \"white\";else colour = \"black\"; // Sort the array of pieces so that matching pieces appear next to eachother\n\n    setTakenPieces(prevState => ({ ...prevState,\n      [colour]: [...prevState[colour], pieceImgPath].sort()\n    }));\n  }\n\n  const king = boardState[\"king_w\"].isOwner ? \"king_w\" : \"king_b\";\n  let newBoardState; // Gets the castle if castling\n\n  const castleToMove = CheckIfCanCastle(toX, toY, draggedPiece, boardState); // Update state of the moved piece\n\n  newBoardState = { ...boardState,\n    [draggedPiece.pieceName]: { ...boardState[draggedPiece.pieceName],\n      row: toY,\n      col: toX,\n      hasMoved: true\n    },\n    turn: boardState[\"turn\"] + 1\n  };\n\n  if (draggedPiece.pieceName.split(\"_\")[0] === \"pawn\") {\n    // If the pawn moved two squares then it can be taken via en passant\n    // en passant can only happen on the same turn\n    const justMovedTwo = !draggedPiece.pieceState.hasMoved && draggedPiece.pieceState.row - toY === 2;\n    newBoardState[draggedPiece.pieceName] = { ...newBoardState[draggedPiece.pieceName],\n      movedTwoSquaresTurn: justMovedTwo ? boardState[\"turn\"] + 1 : null\n    };\n  } else if (castleToMove !== null) {\n    const newCastleCol = castleToMove.state.col === 7 ? 5 : 3;\n    const newKingCol = newCastleCol === 5 ? 6 : 2; // Moves the king and castle when castling\n    // Moving a piece will always take king out of check\n\n    newBoardState[castleToMove.castleName] = { ...newBoardState[castleToMove.castleName],\n      col: newCastleCol,\n      hasMoved: true\n    };\n    newBoardState[king] = { ...newBoardState[king],\n      col: newKingCol,\n      hasMoved: true\n    };\n  }\n\n  newBoardState[king] = { ...newBoardState[king],\n    inCheck: false\n  };\n  setBoardState(newBoardState);\n}\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\n\n_c = MovePiece;\nexport function CanMovePiece(toX, toY, draggedPiece, boardState) {\n  const square = GetPieceAtSquare(toX, toY, boardState); // if a friendly piece is in a square, don't allow this piece to be moved there\n\n  if (square && square.state.isOwner && square.state.isAlive) return false; // calculate the difference between the new square and the piece being dragged\n\n  let dx = Math.abs(toX - draggedPiece.pieceState.col);\n  let dy = Math.abs(toY - draggedPiece.pieceState.row);\n  const pieceName = draggedPiece.pieceName.split(\"_\")[0]; // Check the row and column of the piece to see if the movement should be blocked\n  // by another piece\n\n  const straightCollision = CheckStraightCollisions(toX, toY, boardState, draggedPiece); // Check the diagonal of the piece to see if the movement should be blocked\n  // by another piece\n\n  const diagCollision = CheckDiagCollisions(toX, toY, boardState, draggedPiece); // Checks if the move will block the piece attacking the king\n\n  const pieceCheckingKing = CheckIfPieceIsProtectingKing(toX, toY, boardState, draggedPiece.pieceName); // Get the players king\n\n  const king = boardState[\"king_w\"].isOwner ? boardState[\"king_w\"] : boardState[\"king_b\"];\n  let piecePuttingKingInCheck, cantMoveToProtectKing;\n\n  if (king.inCheck) {\n    // Gets the piece that is putting the king in check\n    piecePuttingKingInCheck = CheckIfMoveUnderAttack(king.col, king.row, boardState);\n    const pieceAttackingKingNotAtSquare = square !== null && square.piece !== piecePuttingKingInCheck; // Move must protect king if king is in check\n\n    cantMoveToProtectKing = king.inCheck && (pieceCheckingKing === null && pieceAttackingKingNotAtSquare || pieceCheckingKing === null && square === null);\n  }\n\n  let isProtectingKing;\n\n  if (pieceName !== \"king\") {\n    // Check if the piece is defending the king\n    // Get the piece that is attacking the king if true\n    const pieceAttackingKing = CheckIfPieceIsProtectingKing(draggedPiece.pieceState.col, draggedPiece.pieceState.row, boardState, draggedPiece.pieceName); // Check if the piece is currently under attack\n\n    const isPieceUnderAttack = CheckIfMoveUnderAttack(draggedPiece.pieceState.col, draggedPiece.pieceState.row, boardState) !== null;\n    isProtectingKing = pieceAttackingKing !== null && isPieceUnderAttack;\n  }\n\n  const cantMoveWhilstProtecting = () => {\n    // Dont allow the pawn to move if its protecting king unless it can take the piece\n    // and ensure that the piece is alive before taking\n    if (isProtectingKing && (square && pieceCheckingKing !== square.piece || square === null || square && !square.state.isAlive)) return true;\n    return false;\n  };\n\n  switch (pieceName) {\n    case \"king\":\n      const moveUnderAttack = CheckIfMoveUnderAttack(toX, toY, boardState, draggedPiece.pieceName);\n      const moveNotInCheck = moveUnderAttack === null || square && square.piece === moveUnderAttack;\n      const canCastle = CheckIfCanCastle(toX, toY, draggedPiece, boardState);\n      return ((dx === 1 || dx === 0) && (dy === 1 || dy === 0) || canCastle && dx === 2 && dy === 0) && moveNotInCheck;\n\n    case \"castle\":\n      if (cantMoveWhilstProtecting()) return;\n      if (cantMoveToProtectKing) return;\n      return (dx === 0 && dy > 0 || dx > 0 && dy === 0) && !straightCollision.collision;\n\n    case \"knight\":\n      if (cantMoveWhilstProtecting()) return;\n      if (cantMoveToProtectKing) return;\n      return dx === 2 && dy === 1 || dx === 1 && dy === 2;\n\n    case \"bishop\":\n      if (cantMoveWhilstProtecting()) return;\n      if (cantMoveToProtectKing) return;\n      return !(dx === 0 && dy > 0) && !(dx > 0 && dy === 0) && (dx === dy || dx === dy) && !diagCollision.collision;\n\n    case \"queen\":\n      if (cantMoveWhilstProtecting()) return;\n      if (cantMoveToProtectKing) return;\n      return (dx === 0 && dy > 0 || dx > 0 && dy === 0) && !straightCollision.collision || (dx === dy || dx === dy) && !diagCollision.collision;\n\n    case \"pawn\":\n      if (cantMoveWhilstProtecting()) return;\n      if (cantMoveToProtectKing) return; // Gets the pawn that can be taken via en passant\n\n      const enPassantPawn = CheckIfCanEnPassant(draggedPiece, boardState); // Recalculate dx/dy with direction\n\n      dx = toX - draggedPiece.pieceState.col;\n      dy = toY - draggedPiece.pieceState.row; // Allow pawn to move 2 squares on first move\n\n      if (!draggedPiece.pieceState.hasMoved) {\n        // Negative direction moves up the board (player always at bottom)\n        if (dx === 0 && (dy === -1 || dy === -2) && !straightCollision.collision) {\n          return square === null;\n        }\n      } // Allow pawn to take opponents pawn via en passant\n\n\n      if (enPassantPawn && toX === enPassantPawn.state.col && toY === enPassantPawn.state.row - 1) return true;\n      if ((dx === 1 || dx === -1) && dy === -1 && square !== null) // Allow pawn to take opponents pieces diagonal by 1 square\n        return true; // Allow pawn to move forward by 1 square\n\n      return dx === 0 && dy === -1 && square === null;\n\n    default:\n      return false;\n  }\n}\n/**\r\n * Checks if the current square is empty\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @returns piece name and state if square is not empty, null otherwise\r\n */\n\n_c2 = CanMovePiece;\n\nfunction GetPieceAtSquare(x, y, boardState) {\n  for (const [piece, state] of Object.entries(boardState)) {\n    if (x === state.col && y === state.row) {\n      return {\n        piece,\n        state\n      };\n    }\n  }\n\n  return null;\n}\n/**\r\n * Checks if there is a piece in the diagonal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece contains data about the currently dragged piece\r\n * @param {boolean} checkForOpponentPiece if true, the check will be on behalf of the opponent\r\n * @returns piece and false if an opponents piece is inbetween the square and the currently dragged piece, piece and true otherwise\r\n */\n\n\n_c3 = GetPieceAtSquare;\n\nfunction CheckDiagCollisions(x, y, boardState, draggedPiece) {\n  let checkForOpponentPiece = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  // Get row and col of dragged piece\n  const row = draggedPiece.pieceState.row;\n  const col = draggedPiece.pieceState.col;\n  const dirX = Math.sign(x - col);\n  const dirY = Math.sign(y - row);\n\n  for (let i = 0; i < Math.abs(x - col) + 1; i++) {\n    for (const [piece, state] of Object.entries(boardState)) {\n      // Dont include collisions with self\n      if (piece !== draggedPiece.pieceName) {\n        const owner = checkForOpponentPiece ? !state.isOwner : state.isOwner;\n\n        if (col + i * dirX === state.col && row + i * dirY === state.row && state.isAlive && (i === 0 && !owner || i !== 0)) {\n          if (i !== Math.abs(x - col)) {\n            // Stops opponents pieces from being taken when hidden behind each other\n            return {\n              piece: piece,\n              collision: true\n            };\n          }\n\n          return {\n            piece: piece,\n            collision: owner\n          };\n        }\n      }\n    }\n  }\n\n  return {\n    piece: null,\n    collision: false\n  };\n}\n/**\r\n * Checks if there is a piece in the vertical and horizontal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece contains data about the currently dragged piece\r\n * @param {boolean} checkForOpponentPiece if true, the check will be on behalf of the opponent\r\n * @returns true and the piece name if an opponents piece is inbetween the square and the currently dragged piece, false and null otherwise\r\n */\n\n\n_c4 = CheckDiagCollisions;\n\nfunction CheckStraightCollisions(x, y, boardState, draggedPiece) {\n  let checkForOpponentPiece = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  // Get row and col of dragged piece\n  const row = draggedPiece.pieceState.row;\n  const col = draggedPiece.pieceState.col; // Get change in x and y between dragged piece and square\n\n  const dx = Math.abs(x - col);\n  const dy = Math.abs(y - row); // Ignore diagonal moves\n\n  if (dx > 0 && dy > 0) return true; // get direction of move\n\n  const dirX = Math.sign(x - col);\n  const dirY = Math.sign(y - row);\n\n  for (let i = 1; i < Math.max(dx, dy) + 1; i++) {\n    for (const [piece, state] of Object.entries(boardState)) {\n      // Dont include collisions with self\n      if (piece !== draggedPiece.pieceName) {\n        if (state.isAlive) {\n          // Move is horizontal if dy = 0, otherwise vertical\n          if (dy === 0) {\n            if (col + i * dirX === state.col && row === state.row) {\n              if (i !== Math.abs(x - col)) {\n                // Stops opponents pieces from being taken when hidden behind each other\n                return {\n                  piece: piece,\n                  collision: true\n                };\n              }\n\n              return {\n                piece: piece,\n                collision: checkForOpponentPiece ? !state.isOwner : state.isOwner\n              };\n            }\n          } else {\n            if (row + i * dirY === state.row && col === state.col) {\n              if (i !== Math.abs(y - row)) {\n                // Stops opponents pieces from being taken when hidden behind each other\n                return {\n                  piece: piece,\n                  collision: true\n                };\n              }\n\n              return {\n                piece: piece,\n                collision: checkForOpponentPiece ? !state.isOwner : state.isOwner\n              };\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    piece: null,\n    collision: false\n  };\n}\n/**\r\n * Checks if a piece at (x,y) on the board is under attack by an opponents piece\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {string} pieceToMove the name of the piece to move\r\n * @returns piece name if the piece is under attack, null otherwise\r\n */\n\n\n_c5 = CheckStraightCollisions;\n\nfunction CheckIfMoveUnderAttack(x, y, boardState) {\n  let pieceToMove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  for (const [piece, state] of Object.entries(boardState)) {\n    // King cannot be checked by its own pieces\n    if (!state.isOwner) {\n      const dx = Math.abs(x - state.col);\n      const dy = Math.abs(y - state.row); // Check if the square is under attack from an opponents piece via straight line\n\n      const straightCollisions = CheckStraightCollisions(state.col, state.row, boardState, {\n        pieceName: pieceToMove,\n        pieceState: {\n          col: x,\n          row: y\n        }\n      });\n\n      if (straightCollisions.piece && !straightCollisions.collision) {\n        const pieceName = straightCollisions.piece.split(\"_\")[0]; // If the piece can take pieces horizontally or vertically or king is in range,\n        // then the move is not valid\n\n        if (pieceName === \"queen\" || pieceName === \"castle\" || pieceName === \"king\" && (dx === 1 || dy === 1)) {\n          //return true;\n          return straightCollisions.piece;\n        }\n      } // Check if the square is under attack from an opponents piece via diagonal line\n\n\n      const diagCollisions = CheckDiagCollisions(state.col, state.row, boardState, {\n        pieceName: pieceToMove,\n        pieceState: {\n          col: x,\n          row: y\n        }\n      });\n\n      if (diagCollisions.piece && diagCollisions.piece !== pieceToMove && !diagCollisions.collision) {\n        // Dont include collisions with self\n        if (diagCollisions.piece === pieceToMove) return null;\n        const pieceName = diagCollisions.piece.split(\"_\")[0]; // If the piece can move diagonally or the pawn is in range of square,\n        // then the move is not valid\n\n        if (pieceName === \"queen\" || pieceName === \"bishop\" || pieceName === \"king\" && dx === 1 && dy === 1 || pieceName === \"pawn\" && dx === 1 && y - state.row === 1) {\n          //return true;\n          return diagCollisions.piece;\n        }\n      } // Check if square is under attack by a knight\n\n\n      if (piece.split(\"_\")[0] === \"knight\" && (dx === 2 && dy === 1 || dx === 1 && dy === 2)) {\n        return piece;\n      }\n    }\n  }\n\n  return null;\n}\n/**\r\n * Check if the piece at (x,y) on the board is blocking an opponent piece from checking the king\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece piece being dragged\r\n * @returns name of piece attacking king, if no such piece exists, return null\r\n */\n\n\n_c6 = CheckIfMoveUnderAttack;\n\nfunction CheckIfPieceIsProtectingKing(x, y, boardState, draggedPiece) {\n  // Get players king\n  const king = boardState[\"king_w\"].isOwner ? boardState[\"king_w\"] : boardState[\"king_b\"]; // Direction from (x,y) to king\n\n  const dirX = Math.sign(x - king.col);\n  const dirY = Math.sign(y - king.row);\n  if (dirX === 0 && dirY === 0) return null;\n  const dx = Math.abs(king.col - x);\n  const dy = Math.abs(king.row - y);\n\n  const getOppositeCoords = king => {\n    let oppositeX = king.col;\n    let oppositeY = king.row; // Get the x,y in the opposite direction to the king to the edge of the board\n\n    while (oppositeX <= 7 && oppositeX >= 0 && oppositeY <= 7 && oppositeY >= 0) {\n      oppositeX += dirX;\n      oppositeY += dirY;\n    }\n\n    return [oppositeX, oppositeY];\n  }; // Check pieces that are directly above or beside the king\n\n\n  if (dx === 0 || (dirX === 1 || dirX === -1) && dy === 0) {\n    // Check if piece is inbetween king and opponent piece that can attack king\n    const straightCollisions = CheckStraightCollisions(x, y, boardState, {\n      pieceState: {\n        col: king.col,\n        row: king.row\n      }\n    }); // A piece is inbetween the dragged piece and the king,\n    // therefore, it is not protecting the king and can be moved\n\n    if (straightCollisions.collision && straightCollisions.piece !== draggedPiece) return null;\n    const [oppositeX, oppositeY] = getOppositeCoords(king);\n    const oppositeStraightCollisions = CheckStraightCollisions(oppositeX, oppositeY, boardState, {\n      pieceState: {\n        col: x,\n        row: y\n      }\n    });\n\n    if (oppositeStraightCollisions.piece && !boardState[oppositeStraightCollisions.piece].isOwner) {\n      const pieceName = oppositeStraightCollisions.piece.split(\"_\")[0]; // If the piece in opposite direction to king is able to attack the king\n      // once the dragged piece is moved, then don't allow the piece to be moved\n\n      if (pieceName === \"castle\" || pieceName === \"queen\") {\n        // the piece is protecting the king\n        return oppositeStraightCollisions.piece;\n      }\n    }\n  } else if (dx === dy) {\n    // Check the pieces directly diagonal to the king\n    // Check if piece is inbetween king and opponent piece that can attack king\n    const diagCollisions = CheckDiagCollisions(x, y, boardState, {\n      pieceState: {\n        col: king.col,\n        row: king.row\n      }\n    }); // A piece is inbetween the dragged piece and the king,\n    // therefore, it is not protecting the king and can be moved\n\n    if (diagCollisions.collision && diagCollisions.piece !== draggedPiece) return null;\n    const [oppositeX, oppositeY] = getOppositeCoords(king);\n    const oppositeDiagCollisions = CheckDiagCollisions(oppositeX, oppositeY, boardState, {\n      pieceState: {\n        col: x,\n        row: y\n      }\n    });\n\n    if (oppositeDiagCollisions.piece && !boardState[oppositeDiagCollisions.piece].isOwner) {\n      const pieceName = oppositeDiagCollisions.piece.split(\"_\")[0]; // If the piece in opposite direction to king is able to attack the king\n      // once the dragged piece is moved, then don't allow the piece to be moved\n\n      const signDx = king.col - x;\n      const signDy = king.col - x;\n\n      if (pieceName === \"bishop\" || pieceName === \"queen\" || pieceName === \"pawn\" && (signDx === 1 || signDx === -1) && signDy === -1) {\n        // the piece is protecting the king\n        return oppositeDiagCollisions.piece;\n      }\n    }\n  }\n\n  return null;\n}\n/**\r\n * Checks if the opponent king is in check\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} opponentKing the opponents kings state\r\n * @returns true if the opponents king is in check, otherwise false\r\n */\n\n\n_c7 = CheckIfPieceIsProtectingKing;\nexport function CheckIfOpponentInCheck(boardState, opponentKing) {\n  for (const [piece, state] of Object.entries(boardState)) {\n    // King cannot be checked by its own pieces\n    if (state.isOwner) {\n      const dx = Math.abs(opponentKing.col - state.col);\n      const dy = Math.abs(opponentKing.row - state.row); // Check if the square is under attack from an opponents piece via straight line\n\n      const straightCollisions = CheckStraightCollisions(state.col, state.row, boardState, {\n        pieceState: {\n          col: opponentKing.col,\n          row: opponentKing.row\n        }\n      }, true);\n\n      if (straightCollisions.piece && !straightCollisions.collision) {\n        const pieceName = straightCollisions.piece.split(\"_\")[0]; // If the piece can take pieces horizontally or vertically or king is in range,\n        // then the move is not valid\n\n        if (pieceName === \"queen\" || pieceName === \"castle\" || pieceName === \"king\" && (dx === 1 || dy === 1)) {\n          return true;\n        }\n      } // Check if the square is under attack from an opponents piece via diagonal line\n\n\n      const diagCollisions = CheckDiagCollisions(state.col, state.row, boardState, {\n        pieceState: {\n          col: opponentKing.col,\n          row: opponentKing.row\n        }\n      }, true);\n\n      if (diagCollisions.piece && !diagCollisions.collision) {\n        const pieceName = diagCollisions.piece.split(\"_\")[0]; // If the piece can move diagonally or the pawn is in range of square,\n        // then the move is not valid\n        // negative direction is up the board\n\n        if (pieceName === \"queen\" || pieceName === \"bishop\" || pieceName === \"king\" && dx === 1 && dy === 1 || pieceName === \"pawn\" && dx === 1 && opponentKing.row - state.row === -1) {\n          return true;\n        }\n      } // Check if square is under attack by a knight\n\n\n      if (piece.split(\"_\")[0] === \"knight\" && (dx === 2 && dy === 1 || dx === 1 && dy === 2)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n/**\r\n * Checks if the king can castle\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {Object} draggedPiece\r\n * @param {Object} boardState\r\n * @returns the castle name and state if player can castle else null\r\n */\n\n_c8 = CheckIfOpponentInCheck;\n\nfunction CheckIfCanCastle(x, y, draggedPiece, boardState) {\n  const pieceName = draggedPiece.pieceName.split(\"_\")[0];\n  const pieceColour = draggedPiece.pieceName.split(\"_\")[1];\n\n  if (pieceName === \"king\" && !draggedPiece.pieceState.hasBeenInCheck && !draggedPiece.pieceState.hasMoved) {\n    const castle_1 = boardState[\"castle_\" + pieceColour + \"_1\"];\n    const castle_2 = boardState[\"castle_\" + pieceColour + \"_2\"]; // Ensure move is at correct square, castle hasnt moved and there is no pieces\n    // inbetween the king and castle\n\n    if (x === 2 && y === 7 && castle_1 && !castle_1.hasMoved && !GetPieceAtSquare(1, 7, boardState) && !GetPieceAtSquare(2, 7, boardState) && !GetPieceAtSquare(3, 7, boardState)) {\n      return {\n        castleName: \"castle_\" + pieceColour + \"_1\",\n        state: castle_1\n      };\n    } else if (x === 6 && y === 7 && castle_2 && !castle_2.hasMoved && !GetPieceAtSquare(6, 7, boardState) && !GetPieceAtSquare(5, 7, boardState)) {\n      return {\n        castleName: \"castle_\" + pieceColour + \"_2\",\n        state: castle_2\n      };\n    }\n  }\n\n  return null;\n}\n/**\r\n * Check if the pawn can take another pawn via en passant\r\n * @param {Object} draggedPiece\r\n * @param {Object} boardState\r\n * @returns the pawn that can be taken if en passant is possible, otherwise null\r\n */\n\n\n_c9 = CheckIfCanCastle;\n\nfunction CheckIfCanEnPassant(draggedPiece, boardState) {\n  // Only a pawn can en passant\n  if (draggedPiece.pieceName.split(\"_\")[0] !== \"pawn\") return null;\n  const pawnOnLeft = GetPieceAtSquare(draggedPiece.pieceState.col - 1, draggedPiece.pieceState.row, boardState);\n  const pawnOnRight = GetPieceAtSquare(draggedPiece.pieceState.col + 1, draggedPiece.pieceState.row, boardState);\n\n  if (pawnOnLeft && pawnOnLeft.state.movedTwoSquaresTurn === boardState[\"turn\"]) {\n    return pawnOnLeft;\n  }\n\n  if (pawnOnRight && pawnOnRight.state.movedTwoSquaresTurn === boardState[\"turn\"]) {\n    return pawnOnRight;\n  }\n\n  return null;\n}\n\n_c10 = CheckIfCanEnPassant;\n\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10;\n\n$RefreshReg$(_c, \"MovePiece\");\n$RefreshReg$(_c2, \"CanMovePiece\");\n$RefreshReg$(_c3, \"GetPieceAtSquare\");\n$RefreshReg$(_c4, \"CheckDiagCollisions\");\n$RefreshReg$(_c5, \"CheckStraightCollisions\");\n$RefreshReg$(_c6, \"CheckIfMoveUnderAttack\");\n$RefreshReg$(_c7, \"CheckIfPieceIsProtectingKing\");\n$RefreshReg$(_c8, \"CheckIfOpponentInCheck\");\n$RefreshReg$(_c9, \"CheckIfCanCastle\");\n$RefreshReg$(_c10, \"CheckIfCanEnPassant\");","map":{"version":3,"names":["MovePiece","toX","toY","setBoardState","setTakenPieces","draggedPiece","boardState","square","GetPieceAtSquare","enPassantPawn","CheckIfCanEnPassant","isOwner","state","isAlive","col","row","pieceToTake","piece","pieceNameSplit","split","piecePathName","pieceImgPath","require","colour","prevState","sort","king","newBoardState","castleToMove","CheckIfCanCastle","pieceName","hasMoved","turn","justMovedTwo","pieceState","movedTwoSquaresTurn","newCastleCol","newKingCol","castleName","inCheck","CanMovePiece","dx","Math","abs","dy","straightCollision","CheckStraightCollisions","diagCollision","CheckDiagCollisions","pieceCheckingKing","CheckIfPieceIsProtectingKing","piecePuttingKingInCheck","cantMoveToProtectKing","CheckIfMoveUnderAttack","pieceAttackingKingNotAtSquare","isProtectingKing","pieceAttackingKing","isPieceUnderAttack","cantMoveWhilstProtecting","moveUnderAttack","moveNotInCheck","canCastle","collision","x","y","Object","entries","checkForOpponentPiece","dirX","sign","dirY","i","owner","max","pieceToMove","straightCollisions","diagCollisions","getOppositeCoords","oppositeX","oppositeY","oppositeStraightCollisions","oppositeDiagCollisions","signDx","signDy","CheckIfOpponentInCheck","opponentKing","pieceColour","hasBeenInCheck","castle_1","castle_2","pawnOnLeft","pawnOnRight"],"sources":["C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/src/components/Game.js"],"sourcesContent":["/**\r\n * Callback for setting the board state\r\n *\r\n * @callback setBoardState\r\n * @param {Object} board An dictionary representing the current board state\r\n */\r\n\r\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {setBoardState} setBoardState sets a new state of the board\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\r\nexport function MovePiece(\r\n    toX,\r\n    toY,\r\n    setBoardState,\r\n    setTakenPieces,\r\n    draggedPiece,\r\n    boardState\r\n) {\r\n    const square = GetPieceAtSquare(toX, toY, boardState);\r\n    const enPassantPawn = CheckIfCanEnPassant(draggedPiece, boardState);\r\n\r\n    // check if piece on square\r\n    // Ensure piece on square is not owned and is alive before taking\r\n    if (\r\n        (square != null && !square.isOwner && square.state.isAlive) ||\r\n        (enPassantPawn &&\r\n            enPassantPawn.state.col === toX &&\r\n            enPassantPawn.state.row - 1 === toY)\r\n    ) {\r\n        const pieceToTake = square != null ? square : enPassantPawn;\r\n        // Remove piece from board\r\n        delete boardState[pieceToTake.piece];\r\n\r\n        // Track what pieces are taken so that they can be rendered under player name\r\n        const pieceNameSplit = pieceToTake.piece.split(\"_\");\r\n        const piecePathName = pieceNameSplit[0] + \"_\" + pieceNameSplit[1];\r\n        const pieceImgPath = require(\"../assets/images/pieces/\" +\r\n            piecePathName +\r\n            \".png\");\r\n\r\n        let colour;\r\n        if (pieceNameSplit[1] === \"w\") colour = \"white\";\r\n        else colour = \"black\";\r\n        // Sort the array of pieces so that matching pieces appear next to eachother\r\n        setTakenPieces((prevState) => ({\r\n            ...prevState,\r\n            [colour]: [...prevState[colour], pieceImgPath].sort(),\r\n        }));\r\n    }\r\n\r\n    const king = boardState[\"king_w\"].isOwner ? \"king_w\" : \"king_b\";\r\n\r\n    let newBoardState;\r\n    // Gets the castle if castling\r\n    const castleToMove = CheckIfCanCastle(toX, toY, draggedPiece, boardState);\r\n    // Update state of the moved piece\r\n    newBoardState = {\r\n        ...boardState,\r\n        [draggedPiece.pieceName]: {\r\n            ...boardState[draggedPiece.pieceName],\r\n            row: toY,\r\n            col: toX,\r\n            hasMoved: true,\r\n        },\r\n        turn: boardState[\"turn\"] + 1,\r\n    };\r\n\r\n    if (draggedPiece.pieceName.split(\"_\")[0] === \"pawn\") {\r\n        // If the pawn moved two squares then it can be taken via en passant\r\n        // en passant can only happen on the same turn\r\n        const justMovedTwo =\r\n            !draggedPiece.pieceState.hasMoved &&\r\n            draggedPiece.pieceState.row - toY === 2;\r\n        newBoardState[draggedPiece.pieceName] = {\r\n            ...newBoardState[draggedPiece.pieceName],\r\n            movedTwoSquaresTurn: justMovedTwo ? boardState[\"turn\"] + 1 : null,\r\n        };\r\n    } else if (castleToMove !== null) {\r\n        const newCastleCol = castleToMove.state.col === 7 ? 5 : 3;\r\n        const newKingCol = newCastleCol === 5 ? 6 : 2;\r\n        // Moves the king and castle when castling\r\n        // Moving a piece will always take king out of check\r\n        newBoardState[castleToMove.castleName] = {\r\n            ...newBoardState[castleToMove.castleName],\r\n            col: newCastleCol,\r\n            hasMoved: true,\r\n        };\r\n        newBoardState[king] = {\r\n            ...newBoardState[king],\r\n            col: newKingCol,\r\n            hasMoved: true,\r\n        };\r\n    }\r\n    newBoardState[king] = {\r\n        ...newBoardState[king],\r\n        inCheck: false,\r\n    };\r\n\r\n    setBoardState(newBoardState);\r\n}\r\n\r\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\r\nexport function CanMovePiece(toX, toY, draggedPiece, boardState) {\r\n    const square = GetPieceAtSquare(toX, toY, boardState);\r\n\r\n    // if a friendly piece is in a square, don't allow this piece to be moved there\r\n    if (square && square.state.isOwner && square.state.isAlive) return false;\r\n\r\n    // calculate the difference between the new square and the piece being dragged\r\n    let dx = Math.abs(toX - draggedPiece.pieceState.col);\r\n    let dy = Math.abs(toY - draggedPiece.pieceState.row);\r\n\r\n    const pieceName = draggedPiece.pieceName.split(\"_\")[0];\r\n\r\n    // Check the row and column of the piece to see if the movement should be blocked\r\n    // by another piece\r\n    const straightCollision = CheckStraightCollisions(\r\n        toX,\r\n        toY,\r\n        boardState,\r\n        draggedPiece\r\n    );\r\n    // Check the diagonal of the piece to see if the movement should be blocked\r\n    // by another piece\r\n    const diagCollision = CheckDiagCollisions(\r\n        toX,\r\n        toY,\r\n        boardState,\r\n        draggedPiece\r\n    );\r\n\r\n    // Checks if the move will block the piece attacking the king\r\n    const pieceCheckingKing = CheckIfPieceIsProtectingKing(\r\n        toX,\r\n        toY,\r\n        boardState,\r\n        draggedPiece.pieceName\r\n    );\r\n\r\n    // Get the players king\r\n    const king = boardState[\"king_w\"].isOwner\r\n        ? boardState[\"king_w\"]\r\n        : boardState[\"king_b\"];\r\n\r\n    let piecePuttingKingInCheck, cantMoveToProtectKing;\r\n    if (king.inCheck) {\r\n        // Gets the piece that is putting the king in check\r\n        piecePuttingKingInCheck = CheckIfMoveUnderAttack(\r\n            king.col,\r\n            king.row,\r\n            boardState\r\n        );\r\n\r\n        const pieceAttackingKingNotAtSquare =\r\n            square !== null && square.piece !== piecePuttingKingInCheck;\r\n        // Move must protect king if king is in check\r\n        cantMoveToProtectKing =\r\n            king.inCheck &&\r\n            ((pieceCheckingKing === null && pieceAttackingKingNotAtSquare) ||\r\n                (pieceCheckingKing === null && square === null));\r\n    }\r\n\r\n    let isProtectingKing;\r\n    if (pieceName !== \"king\") {\r\n        // Check if the piece is defending the king\r\n        // Get the piece that is attacking the king if true\r\n        const pieceAttackingKing = CheckIfPieceIsProtectingKing(\r\n            draggedPiece.pieceState.col,\r\n            draggedPiece.pieceState.row,\r\n            boardState,\r\n            draggedPiece.pieceName\r\n        );\r\n        // Check if the piece is currently under attack\r\n        const isPieceUnderAttack =\r\n            CheckIfMoveUnderAttack(\r\n                draggedPiece.pieceState.col,\r\n                draggedPiece.pieceState.row,\r\n                boardState\r\n            ) !== null;\r\n        isProtectingKing = pieceAttackingKing !== null && isPieceUnderAttack;\r\n    }\r\n\r\n    const cantMoveWhilstProtecting = () => {\r\n        // Dont allow the pawn to move if its protecting king unless it can take the piece\r\n        // and ensure that the piece is alive before taking\r\n        if (\r\n            isProtectingKing &&\r\n            ((square && pieceCheckingKing !== square.piece) ||\r\n                square === null ||\r\n                (square && !square.state.isAlive))\r\n        )\r\n            return true;\r\n        return false;\r\n    };\r\n\r\n    switch (pieceName) {\r\n        case \"king\":\r\n            const moveUnderAttack = CheckIfMoveUnderAttack(\r\n                toX,\r\n                toY,\r\n                boardState,\r\n                draggedPiece.pieceName\r\n            );\r\n            const moveNotInCheck =\r\n                moveUnderAttack === null ||\r\n                (square && square.piece === moveUnderAttack);\r\n            const canCastle = CheckIfCanCastle(\r\n                toX,\r\n                toY,\r\n                draggedPiece,\r\n                boardState\r\n            );\r\n            return (\r\n                (((dx === 1 || dx === 0) && (dy === 1 || dy === 0)) ||\r\n                    (canCastle && dx === 2 && dy === 0)) &&\r\n                moveNotInCheck\r\n            );\r\n\r\n        case \"castle\":\r\n            if (cantMoveWhilstProtecting()) return;\r\n            if (cantMoveToProtectKing) return;\r\n            return (\r\n                ((dx === 0 && dy > 0) || (dx > 0 && dy === 0)) &&\r\n                !straightCollision.collision\r\n            );\r\n\r\n        case \"knight\":\r\n            if (cantMoveWhilstProtecting()) return;\r\n            if (cantMoveToProtectKing) return;\r\n            return (dx === 2 && dy === 1) || (dx === 1 && dy === 2);\r\n\r\n        case \"bishop\":\r\n            if (cantMoveWhilstProtecting()) return;\r\n            if (cantMoveToProtectKing) return;\r\n            return (\r\n                !(dx === 0 && dy > 0) &&\r\n                !(dx > 0 && dy === 0) &&\r\n                (dx === dy || dx === dy) &&\r\n                !diagCollision.collision\r\n            );\r\n\r\n        case \"queen\":\r\n            if (cantMoveWhilstProtecting()) return;\r\n            if (cantMoveToProtectKing) return;\r\n\r\n            return (\r\n                (((dx === 0 && dy > 0) || (dx > 0 && dy === 0)) &&\r\n                    !straightCollision.collision) ||\r\n                ((dx === dy || dx === dy) && !diagCollision.collision)\r\n            );\r\n\r\n        case \"pawn\":\r\n            if (cantMoveWhilstProtecting()) return;\r\n            if (cantMoveToProtectKing) return;\r\n\r\n            // Gets the pawn that can be taken via en passant\r\n            const enPassantPawn = CheckIfCanEnPassant(draggedPiece, boardState);\r\n\r\n            // Recalculate dx/dy with direction\r\n            dx = toX - draggedPiece.pieceState.col;\r\n            dy = toY - draggedPiece.pieceState.row;\r\n            // Allow pawn to move 2 squares on first move\r\n            if (!draggedPiece.pieceState.hasMoved) {\r\n                // Negative direction moves up the board (player always at bottom)\r\n                if (\r\n                    dx === 0 &&\r\n                    (dy === -1 || dy === -2) &&\r\n                    !straightCollision.collision\r\n                ) {\r\n                    return square === null;\r\n                }\r\n            }\r\n\r\n            // Allow pawn to take opponents pawn via en passant\r\n            if (\r\n                enPassantPawn &&\r\n                toX === enPassantPawn.state.col &&\r\n                toY === enPassantPawn.state.row - 1\r\n            )\r\n                return true;\r\n\r\n            if ((dx === 1 || dx === -1) && dy === -1 && square !== null)\r\n                // Allow pawn to take opponents pieces diagonal by 1 square\r\n                return true;\r\n\r\n            // Allow pawn to move forward by 1 square\r\n            return dx === 0 && dy === -1 && square === null;\r\n\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if the current square is empty\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @returns piece name and state if square is not empty, null otherwise\r\n */\r\nfunction GetPieceAtSquare(x, y, boardState) {\r\n    for (const [piece, state] of Object.entries(boardState)) {\r\n        if (x === state.col && y === state.row) {\r\n            return { piece, state };\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks if there is a piece in the diagonal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece contains data about the currently dragged piece\r\n * @param {boolean} checkForOpponentPiece if true, the check will be on behalf of the opponent\r\n * @returns piece and false if an opponents piece is inbetween the square and the currently dragged piece, piece and true otherwise\r\n */\r\nfunction CheckDiagCollisions(\r\n    x,\r\n    y,\r\n    boardState,\r\n    draggedPiece,\r\n    checkForOpponentPiece = false\r\n) {\r\n    // Get row and col of dragged piece\r\n    const row = draggedPiece.pieceState.row;\r\n    const col = draggedPiece.pieceState.col;\r\n\r\n    const dirX = Math.sign(x - col);\r\n    const dirY = Math.sign(y - row);\r\n    for (let i = 0; i < Math.abs(x - col) + 1; i++) {\r\n        for (const [piece, state] of Object.entries(boardState)) {\r\n            // Dont include collisions with self\r\n            if (piece !== draggedPiece.pieceName) {\r\n                const owner = checkForOpponentPiece\r\n                    ? !state.isOwner\r\n                    : state.isOwner;\r\n                if (\r\n                    col + i * dirX === state.col &&\r\n                    row + i * dirY === state.row &&\r\n                    state.isAlive &&\r\n                    ((i === 0 && !owner) || i !== 0)\r\n                ) {\r\n                    if (i !== Math.abs(x - col)) {\r\n                        // Stops opponents pieces from being taken when hidden behind each other\r\n                        return {\r\n                            piece: piece,\r\n                            collision: true,\r\n                        };\r\n                    }\r\n                    return {\r\n                        piece: piece,\r\n                        collision: owner,\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return { piece: null, collision: false };\r\n}\r\n\r\n/**\r\n * Checks if there is a piece in the vertical and horizontal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece contains data about the currently dragged piece\r\n * @param {boolean} checkForOpponentPiece if true, the check will be on behalf of the opponent\r\n * @returns true and the piece name if an opponents piece is inbetween the square and the currently dragged piece, false and null otherwise\r\n */\r\nfunction CheckStraightCollisions(\r\n    x,\r\n    y,\r\n    boardState,\r\n    draggedPiece,\r\n    checkForOpponentPiece = false\r\n) {\r\n    // Get row and col of dragged piece\r\n    const row = draggedPiece.pieceState.row;\r\n    const col = draggedPiece.pieceState.col;\r\n    // Get change in x and y between dragged piece and square\r\n    const dx = Math.abs(x - col);\r\n    const dy = Math.abs(y - row);\r\n\r\n    // Ignore diagonal moves\r\n    if (dx > 0 && dy > 0) return true;\r\n\r\n    // get direction of move\r\n    const dirX = Math.sign(x - col);\r\n    const dirY = Math.sign(y - row);\r\n\r\n    for (let i = 1; i < Math.max(dx, dy) + 1; i++) {\r\n        for (const [piece, state] of Object.entries(boardState)) {\r\n            // Dont include collisions with self\r\n            if (piece !== draggedPiece.pieceName) {\r\n                if (state.isAlive) {\r\n                    // Move is horizontal if dy = 0, otherwise vertical\r\n                    if (dy === 0) {\r\n                        if (col + i * dirX === state.col && row === state.row) {\r\n                            if (i !== Math.abs(x - col)) {\r\n                                // Stops opponents pieces from being taken when hidden behind each other\r\n                                return {\r\n                                    piece: piece,\r\n                                    collision: true,\r\n                                };\r\n                            }\r\n                            return {\r\n                                piece: piece,\r\n                                collision: checkForOpponentPiece\r\n                                    ? !state.isOwner\r\n                                    : state.isOwner,\r\n                            };\r\n                        }\r\n                    } else {\r\n                        if (row + i * dirY === state.row && col === state.col) {\r\n                            if (i !== Math.abs(y - row)) {\r\n                                // Stops opponents pieces from being taken when hidden behind each other\r\n                                return {\r\n                                    piece: piece,\r\n                                    collision: true,\r\n                                };\r\n                            }\r\n                            return {\r\n                                piece: piece,\r\n                                collision: checkForOpponentPiece\r\n                                    ? !state.isOwner\r\n                                    : state.isOwner,\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return { piece: null, collision: false };\r\n}\r\n\r\n/**\r\n * Checks if a piece at (x,y) on the board is under attack by an opponents piece\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {string} pieceToMove the name of the piece to move\r\n * @returns piece name if the piece is under attack, null otherwise\r\n */\r\nfunction CheckIfMoveUnderAttack(x, y, boardState, pieceToMove = null) {\r\n    for (const [piece, state] of Object.entries(boardState)) {\r\n        // King cannot be checked by its own pieces\r\n        if (!state.isOwner) {\r\n            const dx = Math.abs(x - state.col);\r\n            const dy = Math.abs(y - state.row);\r\n\r\n            // Check if the square is under attack from an opponents piece via straight line\r\n            const straightCollisions = CheckStraightCollisions(\r\n                state.col,\r\n                state.row,\r\n                boardState,\r\n                {\r\n                    pieceName: pieceToMove,\r\n                    pieceState: { col: x, row: y },\r\n                }\r\n            );\r\n\r\n            if (straightCollisions.piece && !straightCollisions.collision) {\r\n                const pieceName = straightCollisions.piece.split(\"_\")[0];\r\n                // If the piece can take pieces horizontally or vertically or king is in range,\r\n                // then the move is not valid\r\n                if (\r\n                    pieceName === \"queen\" ||\r\n                    pieceName === \"castle\" ||\r\n                    (pieceName === \"king\" && (dx === 1 || dy === 1))\r\n                ) {\r\n                    //return true;\r\n                    return straightCollisions.piece;\r\n                }\r\n            }\r\n            // Check if the square is under attack from an opponents piece via diagonal line\r\n            const diagCollisions = CheckDiagCollisions(\r\n                state.col,\r\n                state.row,\r\n                boardState,\r\n                {\r\n                    pieceName: pieceToMove,\r\n                    pieceState: { col: x, row: y },\r\n                }\r\n            );\r\n\r\n            if (\r\n                diagCollisions.piece &&\r\n                diagCollisions.piece !== pieceToMove &&\r\n                !diagCollisions.collision\r\n            ) {\r\n                // Dont include collisions with self\r\n                if (diagCollisions.piece === pieceToMove) return null;\r\n\r\n                const pieceName = diagCollisions.piece.split(\"_\")[0];\r\n                // If the piece can move diagonally or the pawn is in range of square,\r\n                // then the move is not valid\r\n                if (\r\n                    pieceName === \"queen\" ||\r\n                    pieceName === \"bishop\" ||\r\n                    (pieceName === \"king\" && dx === 1 && dy === 1) ||\r\n                    (pieceName === \"pawn\" && dx === 1 && y - state.row === 1)\r\n                ) {\r\n                    //return true;\r\n                    return diagCollisions.piece;\r\n                }\r\n            }\r\n\r\n            // Check if square is under attack by a knight\r\n            if (\r\n                piece.split(\"_\")[0] === \"knight\" &&\r\n                ((dx === 2 && dy === 1) || (dx === 1 && dy === 2))\r\n            ) {\r\n                return piece;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Check if the piece at (x,y) on the board is blocking an opponent piece from checking the king\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} draggedPiece piece being dragged\r\n * @returns name of piece attacking king, if no such piece exists, return null\r\n */\r\nfunction CheckIfPieceIsProtectingKing(x, y, boardState, draggedPiece) {\r\n    // Get players king\r\n    const king = boardState[\"king_w\"].isOwner\r\n        ? boardState[\"king_w\"]\r\n        : boardState[\"king_b\"];\r\n\r\n    // Direction from (x,y) to king\r\n    const dirX = Math.sign(x - king.col);\r\n    const dirY = Math.sign(y - king.row);\r\n\r\n    if (dirX === 0 && dirY === 0) return null;\r\n\r\n    const dx = Math.abs(king.col - x);\r\n    const dy = Math.abs(king.row - y);\r\n\r\n    const getOppositeCoords = (king) => {\r\n        let oppositeX = king.col;\r\n        let oppositeY = king.row;\r\n        // Get the x,y in the opposite direction to the king to the edge of the board\r\n\r\n        while (\r\n            oppositeX <= 7 &&\r\n            oppositeX >= 0 &&\r\n            oppositeY <= 7 &&\r\n            oppositeY >= 0\r\n        ) {\r\n            oppositeX += dirX;\r\n            oppositeY += dirY;\r\n        }\r\n        return [oppositeX, oppositeY];\r\n    };\r\n\r\n    // Check pieces that are directly above or beside the king\r\n    if (dx === 0 || ((dirX === 1 || dirX === -1) && dy === 0)) {\r\n        // Check if piece is inbetween king and opponent piece that can attack king\r\n        const straightCollisions = CheckStraightCollisions(x, y, boardState, {\r\n            pieceState: { col: king.col, row: king.row },\r\n        });\r\n\r\n        // A piece is inbetween the dragged piece and the king,\r\n        // therefore, it is not protecting the king and can be moved\r\n        if (\r\n            straightCollisions.collision &&\r\n            straightCollisions.piece !== draggedPiece\r\n        )\r\n            return null;\r\n\r\n        const [oppositeX, oppositeY] = getOppositeCoords(king);\r\n\r\n        const oppositeStraightCollisions = CheckStraightCollisions(\r\n            oppositeX,\r\n            oppositeY,\r\n            boardState,\r\n            {\r\n                pieceState: { col: x, row: y },\r\n            }\r\n        );\r\n\r\n        if (\r\n            oppositeStraightCollisions.piece &&\r\n            !boardState[oppositeStraightCollisions.piece].isOwner\r\n        ) {\r\n            const pieceName = oppositeStraightCollisions.piece.split(\"_\")[0];\r\n            // If the piece in opposite direction to king is able to attack the king\r\n            // once the dragged piece is moved, then don't allow the piece to be moved\r\n            if (pieceName === \"castle\" || pieceName === \"queen\") {\r\n                // the piece is protecting the king\r\n                return oppositeStraightCollisions.piece;\r\n            }\r\n        }\r\n    } else if (dx === dy) {\r\n        // Check the pieces directly diagonal to the king\r\n        // Check if piece is inbetween king and opponent piece that can attack king\r\n        const diagCollisions = CheckDiagCollisions(x, y, boardState, {\r\n            pieceState: { col: king.col, row: king.row },\r\n        });\r\n\r\n        // A piece is inbetween the dragged piece and the king,\r\n        // therefore, it is not protecting the king and can be moved\r\n        if (diagCollisions.collision && diagCollisions.piece !== draggedPiece)\r\n            return null;\r\n\r\n        const [oppositeX, oppositeY] = getOppositeCoords(king);\r\n\r\n        const oppositeDiagCollisions = CheckDiagCollisions(\r\n            oppositeX,\r\n            oppositeY,\r\n            boardState,\r\n            {\r\n                pieceState: { col: x, row: y },\r\n            }\r\n        );\r\n\r\n        if (\r\n            oppositeDiagCollisions.piece &&\r\n            !boardState[oppositeDiagCollisions.piece].isOwner\r\n        ) {\r\n            const pieceName = oppositeDiagCollisions.piece.split(\"_\")[0];\r\n            // If the piece in opposite direction to king is able to attack the king\r\n            // once the dragged piece is moved, then don't allow the piece to be moved\r\n            const signDx = king.col - x;\r\n            const signDy = king.col - x;\r\n            if (\r\n                pieceName === \"bishop\" ||\r\n                pieceName === \"queen\" ||\r\n                (pieceName === \"pawn\" &&\r\n                    (signDx === 1 || signDx === -1) &&\r\n                    signDy === -1)\r\n            ) {\r\n                // the piece is protecting the king\r\n                return oppositeDiagCollisions.piece;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks if the opponent king is in check\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} opponentKing the opponents kings state\r\n * @returns true if the opponents king is in check, otherwise false\r\n */\r\nexport function CheckIfOpponentInCheck(boardState, opponentKing) {\r\n    for (const [piece, state] of Object.entries(boardState)) {\r\n        // King cannot be checked by its own pieces\r\n        if (state.isOwner) {\r\n            const dx = Math.abs(opponentKing.col - state.col);\r\n            const dy = Math.abs(opponentKing.row - state.row);\r\n\r\n            // Check if the square is under attack from an opponents piece via straight line\r\n            const straightCollisions = CheckStraightCollisions(\r\n                state.col,\r\n                state.row,\r\n                boardState,\r\n                {\r\n                    pieceState: {\r\n                        col: opponentKing.col,\r\n                        row: opponentKing.row,\r\n                    },\r\n                },\r\n                true\r\n            );\r\n\r\n            if (straightCollisions.piece && !straightCollisions.collision) {\r\n                const pieceName = straightCollisions.piece.split(\"_\")[0];\r\n                // If the piece can take pieces horizontally or vertically or king is in range,\r\n                // then the move is not valid\r\n                if (\r\n                    pieceName === \"queen\" ||\r\n                    pieceName === \"castle\" ||\r\n                    (pieceName === \"king\" && (dx === 1 || dy === 1))\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n            // Check if the square is under attack from an opponents piece via diagonal line\r\n            const diagCollisions = CheckDiagCollisions(\r\n                state.col,\r\n                state.row,\r\n                boardState,\r\n                {\r\n                    pieceState: {\r\n                        col: opponentKing.col,\r\n                        row: opponentKing.row,\r\n                    },\r\n                },\r\n                true\r\n            );\r\n            if (diagCollisions.piece && !diagCollisions.collision) {\r\n                const pieceName = diagCollisions.piece.split(\"_\")[0];\r\n\r\n                // If the piece can move diagonally or the pawn is in range of square,\r\n                // then the move is not valid\r\n                // negative direction is up the board\r\n                if (\r\n                    pieceName === \"queen\" ||\r\n                    pieceName === \"bishop\" ||\r\n                    (pieceName === \"king\" && dx === 1 && dy === 1) ||\r\n                    (pieceName === \"pawn\" &&\r\n                        dx === 1 &&\r\n                        opponentKing.row - state.row === -1)\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            // Check if square is under attack by a knight\r\n            if (\r\n                piece.split(\"_\")[0] === \"knight\" &&\r\n                ((dx === 2 && dy === 1) || (dx === 1 && dy === 2))\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Checks if the king can castle\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {Object} draggedPiece\r\n * @param {Object} boardState\r\n * @returns the castle name and state if player can castle else null\r\n */\r\nfunction CheckIfCanCastle(x, y, draggedPiece, boardState) {\r\n    const pieceName = draggedPiece.pieceName.split(\"_\")[0];\r\n    const pieceColour = draggedPiece.pieceName.split(\"_\")[1];\r\n    if (\r\n        pieceName === \"king\" &&\r\n        !draggedPiece.pieceState.hasBeenInCheck &&\r\n        !draggedPiece.pieceState.hasMoved\r\n    ) {\r\n        const castle_1 = boardState[\"castle_\" + pieceColour + \"_1\"];\r\n        const castle_2 = boardState[\"castle_\" + pieceColour + \"_2\"];\r\n        // Ensure move is at correct square, castle hasnt moved and there is no pieces\r\n        // inbetween the king and castle\r\n        if (\r\n            x === 2 &&\r\n            y === 7 &&\r\n            castle_1 &&\r\n            !castle_1.hasMoved &&\r\n            !GetPieceAtSquare(1, 7, boardState) &&\r\n            !GetPieceAtSquare(2, 7, boardState) &&\r\n            !GetPieceAtSquare(3, 7, boardState)\r\n        ) {\r\n            return {\r\n                castleName: \"castle_\" + pieceColour + \"_1\",\r\n                state: castle_1,\r\n            };\r\n        } else if (\r\n            x === 6 &&\r\n            y === 7 &&\r\n            castle_2 &&\r\n            !castle_2.hasMoved &&\r\n            !GetPieceAtSquare(6, 7, boardState) &&\r\n            !GetPieceAtSquare(5, 7, boardState)\r\n        ) {\r\n            return {\r\n                castleName: \"castle_\" + pieceColour + \"_2\",\r\n                state: castle_2,\r\n            };\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Check if the pawn can take another pawn via en passant\r\n * @param {Object} draggedPiece\r\n * @param {Object} boardState\r\n * @returns the pawn that can be taken if en passant is possible, otherwise null\r\n */\r\nfunction CheckIfCanEnPassant(draggedPiece, boardState) {\r\n    // Only a pawn can en passant\r\n    if (draggedPiece.pieceName.split(\"_\")[0] !== \"pawn\") return null;\r\n\r\n    const pawnOnLeft = GetPieceAtSquare(\r\n        draggedPiece.pieceState.col - 1,\r\n        draggedPiece.pieceState.row,\r\n        boardState\r\n    );\r\n    const pawnOnRight = GetPieceAtSquare(\r\n        draggedPiece.pieceState.col + 1,\r\n        draggedPiece.pieceState.row,\r\n        boardState\r\n    );\r\n\r\n    if (\r\n        pawnOnLeft &&\r\n        pawnOnLeft.state.movedTwoSquaresTurn === boardState[\"turn\"]\r\n    ) {\r\n        return pawnOnLeft;\r\n    }\r\n    if (\r\n        pawnOnRight &&\r\n        pawnOnRight.state.movedTwoSquaresTurn === boardState[\"turn\"]\r\n    ) {\r\n        return pawnOnRight;\r\n    }\r\n    return null;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}