{"ast":null,"code":"import _slicedToArray from\"C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import _defineProperty from\"C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";import _toConsumableArray from\"C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import _objectSpread from\"C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";/**\r\n * Callback for setting the board state\r\n *\r\n * @callback setBoardState\r\n * @param {Object} board An dictionary representing the current board state\r\n */ /**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {setBoardState} setBoardState sets a new state of the board\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */export function movePiece(toX,toY,setBoardState,setTakenPieces,item,boardState){var square=squareIsEmpty(toX,toY,boardState);if(square!=null){if(!square.isOwner){boardState[square.piece].isAlive=false;// Track what pieces are taken so that they can be rendered under player name\nvar pieceNameSplit=square.piece.split(\"_\");var piecePathName=pieceNameSplit[0]+\"_\"+pieceNameSplit[1];var pieceImgPath=require(\"../assets/images/pieces/\"+piecePathName+\".png\");var colour;if(pieceNameSplit[1]===\"w\")colour=\"white\";else colour=\"black\";// Sort the array of pieces so that matching pieces appear next to eachother\nsetTakenPieces(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},colour,[].concat(_toConsumableArray(prevState[colour]),[pieceImgPath]).sort()));});}}// Update state of the moved piece\nsetBoardState(function(prevState){return _objectSpread(_objectSpread({},prevState),{},_defineProperty({},item.pieceName,{row:toY,col:toX,hasMoved:true,isOwner:true,isAlive:true}));});}/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} monitor contains data about the currently dragged piece\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */export function canMovePiece(toX,toY,item,boardState,monitor){var square=squareIsEmpty(toX,toY,boardState);if(square&&(square.state.isOwner||square.state.isAlive))return false;var dx=Math.abs(toX-item.pieceState.col);var dy=Math.abs(toY-item.pieceState.row);var pieceName=item.pieceName.split(\"_\")[0];var diagCollisions=checkDiagCollisions(toX,toY,boardState,monitor);var straightCollisions=checkStraightCollisions(toX,toY,boardState,monitor);switch(pieceName){case\"castle\":return(dx===0&&dy>0||dx>0&&dy===0)&&!straightCollisions;case\"knight\":return dx===2&&dy===1||dx===1&&dy===2;case\"bishop\":return!(dx===0&&dy>0)&&!(dx>0&&dy===0)&&(dx===dy||dx===dy)&&!diagCollisions;case\"queen\":return(dx===0&&dy>0||dx>0&&dy===0)&&!straightCollisions||(dx===dy||dx===dy)&&!diagCollisions;case\"king\":return(dx===1||dx===0)&&(dy===1||dy===0);case\"pawn\":// Recalculate dx/dy with direction\ndx=toX-item.pieceState.col;dy=toY-item.pieceState.row;// Allow pawn to move 2 squares on first move\nif(!item.pieceState.hasMoved){// Negative direction moves up the board (player always at bottom)\nif(dx===0&&(dy===-1||dy===-2)&&!straightCollisions){return square===null;}}// Allow pawn to take opponents pieces diagonal by 1 square\nif((dx===1||dx===-1)&&dy===-1&&square!==null)return true;// Allow pawn to move forward by 1 square\nreturn dx===0&&dy===-1&&square===null;default:return false;}}/**\r\n * Checks if the current square is empty\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @returns piece name and state if square is not empty, null otherwise\r\n */function squareIsEmpty(x,y,boardState){for(var _i=0,_Object$entries=Object.entries(boardState);_i<_Object$entries.length;_i++){var _Object$entries$_i=_slicedToArray(_Object$entries[_i],2),piece=_Object$entries$_i[0],state=_Object$entries$_i[1];if(x===state.col&&y===state.row){return{piece:piece,state:state};}}return null;}/**\r\n * Checks if there is a piece in the diagonal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} monitor contains data about the currently dragged piece\r\n * @returns true if an opponents piece is inbetween the square and the currently dragged piece, false otherwise\r\n */function checkDiagCollisions(x,y,boardState,monitor){var row=monitor.getItem().pieceState.row;var col=monitor.getItem().pieceState.col;var dirX=Math.sign(x-col);var dirY=Math.sign(y-row);for(var i=1;i<Math.abs(x-col)+1;i++){for(var _i2=0,_Object$entries2=Object.entries(boardState);_i2<_Object$entries2.length;_i2++){var _Object$entries2$_i=_slicedToArray(_Object$entries2[_i2],2),_=_Object$entries2$_i[0],state=_Object$entries2$_i[1];if(col+i*dirX===state.col&&row+i*dirY===state.row&&state.isAlive){if(i!==Math.abs(x-col)){// Stops opponents pieces from being taken when hidden behind each other\nreturn true;}return state.isOwner;}}}return false;}/**\r\n * Checks if there is a piece in the vertical and horizontal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} monitor contains data about the currently dragged piece\r\n * @returns true if an opponents piece is inbetween the square and the currently dragged piece, false otherwise\r\n */function checkStraightCollisions(x,y,boardState,monitor){var row=monitor.getItem().pieceState.row;var col=monitor.getItem().pieceState.col;var dx=Math.abs(x-col);var dy=Math.abs(y-row);if(dx>0&&dy>0)return true;var dirX=Math.sign(x-col);var dirY=Math.sign(y-row);for(var i=1;i<Math.max(dx,dy)+1;i++){for(var _i3=0,_Object$entries3=Object.entries(boardState);_i3<_Object$entries3.length;_i3++){var _Object$entries3$_i=_slicedToArray(_Object$entries3[_i3],2),_=_Object$entries3$_i[0],state=_Object$entries3$_i[1];if(state.isAlive){// Move is horizontal if dy = 0, otherwise vertical\nif(dy===0){if(col+i*dirX===state.col&&row===state.row){if(i!==Math.abs(x-col)){// Stops opponents pieces from being taken when hidden behind each other\nreturn true;}return state.isOwner;}}else{if(row+i*dirY===state.row&&col===state.col){if(i!==Math.abs(y-row)){// Stops opponents pieces from being taken when hidden behind each other\nreturn true;}return state.isOwner;}}}}}return false;}","map":{"version":3,"names":["movePiece","toX","toY","setBoardState","setTakenPieces","item","boardState","square","squareIsEmpty","isOwner","piece","isAlive","pieceNameSplit","split","piecePathName","pieceImgPath","require","colour","prevState","sort","pieceName","row","col","hasMoved","canMovePiece","monitor","state","dx","Math","abs","pieceState","dy","diagCollisions","checkDiagCollisions","straightCollisions","checkStraightCollisions","x","y","Object","entries","getItem","dirX","sign","dirY","i","_","max"],"sources":["C:/Users/charl/Documents/Code/Web Dev/Chess-Online/chessproject/frontend/src/components/Game.js"],"sourcesContent":["/**\r\n * Callback for setting the board state\r\n *\r\n * @callback setBoardState\r\n * @param {Object} board An dictionary representing the current board state\r\n */\r\n\r\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {setBoardState} setBoardState sets a new state of the board\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\r\nexport function movePiece(\r\n    toX,\r\n    toY,\r\n    setBoardState,\r\n    setTakenPieces,\r\n    item,\r\n    boardState\r\n) {\r\n    const square = squareIsEmpty(toX, toY, boardState);\r\n    if (square != null) {\r\n        if (!square.isOwner) {\r\n            boardState[square.piece].isAlive = false;\r\n\r\n            // Track what pieces are taken so that they can be rendered under player name\r\n            const pieceNameSplit = square.piece.split(\"_\");\r\n            const piecePathName = pieceNameSplit[0] + \"_\" + pieceNameSplit[1];\r\n            const pieceImgPath = require(\"../assets/images/pieces/\" +\r\n                piecePathName +\r\n                \".png\");\r\n\r\n            let colour;\r\n            if (pieceNameSplit[1] === \"w\") colour = \"white\";\r\n            else colour = \"black\";\r\n            // Sort the array of pieces so that matching pieces appear next to eachother\r\n            setTakenPieces((prevState) => ({\r\n                ...prevState,\r\n                [colour]: [...prevState[colour], pieceImgPath].sort(),\r\n            }));\r\n        }\r\n    }\r\n\r\n    // Update state of the moved piece\r\n    setBoardState((prevState) => ({\r\n        ...prevState,\r\n        [item.pieceName]: {\r\n            row: toY,\r\n            col: toX,\r\n            hasMoved: true,\r\n            isOwner: true,\r\n            isAlive: true,\r\n        },\r\n    }));\r\n}\r\n\r\n/**\r\n * Checks if the dragged piece can be placed at a square\r\n * @param {number} toX x coordinate of the square currently being checked\r\n * @param {number} toY y coordinate of the square currently being checked\r\n * @param {Object} item piece currently being dragged\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} monitor contains data about the currently dragged piece\r\n * @returns true if the dragged piece can be moved to the square at (x,y), false otherwise\r\n */\r\nexport function canMovePiece(toX, toY, item, boardState, monitor) {\r\n    const square = squareIsEmpty(toX, toY, boardState);\r\n\r\n    if (square && (square.state.isOwner || square.state.isAlive)) return false;\r\n\r\n    var dx = Math.abs(toX - item.pieceState.col);\r\n    var dy = Math.abs(toY - item.pieceState.row);\r\n\r\n    const pieceName = item.pieceName.split(\"_\")[0];\r\n\r\n    const diagCollisions = checkDiagCollisions(toX, toY, boardState, monitor);\r\n    const straightCollisions = checkStraightCollisions(\r\n        toX,\r\n        toY,\r\n        boardState,\r\n        monitor\r\n    );\r\n\r\n    switch (pieceName) {\r\n        case \"castle\":\r\n            return (\r\n                ((dx === 0 && dy > 0) || (dx > 0 && dy === 0)) &&\r\n                !straightCollisions\r\n            );\r\n\r\n        case \"knight\":\r\n            return (dx === 2 && dy === 1) || (dx === 1 && dy === 2);\r\n\r\n        case \"bishop\":\r\n            return (\r\n                !(dx === 0 && dy > 0) &&\r\n                !(dx > 0 && dy === 0) &&\r\n                (dx === dy || dx === dy) &&\r\n                !diagCollisions\r\n            );\r\n\r\n        case \"queen\":\r\n            return (\r\n                (((dx === 0 && dy > 0) || (dx > 0 && dy === 0)) &&\r\n                    !straightCollisions) ||\r\n                ((dx === dy || dx === dy) && !diagCollisions)\r\n            );\r\n\r\n        case \"king\":\r\n            return (dx === 1 || dx === 0) && (dy === 1 || dy === 0);\r\n\r\n        case \"pawn\":\r\n            // Recalculate dx/dy with direction\r\n            dx = toX - item.pieceState.col;\r\n            dy = toY - item.pieceState.row;\r\n            // Allow pawn to move 2 squares on first move\r\n            if (!item.pieceState.hasMoved) {\r\n                // Negative direction moves up the board (player always at bottom)\r\n                if (\r\n                    dx === 0 &&\r\n                    (dy === -1 || dy === -2) &&\r\n                    !straightCollisions\r\n                ) {\r\n                    return square === null;\r\n                }\r\n            }\r\n            // Allow pawn to take opponents pieces diagonal by 1 square\r\n            if ((dx === 1 || dx === -1) && dy === -1 && square !== null)\r\n                return true;\r\n\r\n            // Allow pawn to move forward by 1 square\r\n            return dx === 0 && dy === -1 && square === null;\r\n\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if the current square is empty\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @returns piece name and state if square is not empty, null otherwise\r\n */\r\nfunction squareIsEmpty(x, y, boardState) {\r\n    for (const [piece, state] of Object.entries(boardState)) {\r\n        if (x === state.col && y === state.row) {\r\n            return { piece, state };\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks if there is a piece in the diagonal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} monitor contains data about the currently dragged piece\r\n * @returns true if an opponents piece is inbetween the square and the currently dragged piece, false otherwise\r\n */\r\nfunction checkDiagCollisions(x, y, boardState, monitor) {\r\n    const row = monitor.getItem().pieceState.row;\r\n    const col = monitor.getItem().pieceState.col;\r\n\r\n    const dirX = Math.sign(x - col);\r\n    const dirY = Math.sign(y - row);\r\n    for (let i = 1; i < Math.abs(x - col) + 1; i++) {\r\n        for (const [_, state] of Object.entries(boardState)) {\r\n            if (\r\n                col + i * dirX === state.col &&\r\n                row + i * dirY === state.row &&\r\n                state.isAlive\r\n            ) {\r\n                if (i !== Math.abs(x - col)) {\r\n                    // Stops opponents pieces from being taken when hidden behind each other\r\n                    return true;\r\n                }\r\n                return state.isOwner;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Checks if there is a piece in the vertical and horizontal of the selected piece and the current square\r\n * @param {number} x x coordinate of the square currently being checked\r\n * @param {number} y y coordinate of the square currently being checked\r\n * @param {Object} boardState current state of the board\r\n * @param {Object} monitor contains data about the currently dragged piece\r\n * @returns true if an opponents piece is inbetween the square and the currently dragged piece, false otherwise\r\n */\r\nfunction checkStraightCollisions(x, y, boardState, monitor) {\r\n    const row = monitor.getItem().pieceState.row;\r\n    const col = monitor.getItem().pieceState.col;\r\n    const dx = Math.abs(x - col);\r\n    const dy = Math.abs(y - row);\r\n\r\n    if (dx > 0 && dy > 0) return true;\r\n    const dirX = Math.sign(x - col);\r\n    const dirY = Math.sign(y - row);\r\n\r\n    for (let i = 1; i < Math.max(dx, dy) + 1; i++) {\r\n        for (const [_, state] of Object.entries(boardState)) {\r\n            if (state.isAlive) {\r\n                // Move is horizontal if dy = 0, otherwise vertical\r\n                if (dy === 0) {\r\n                    if (col + i * dirX === state.col && row === state.row) {\r\n                        if (i !== Math.abs(x - col)) {\r\n                            // Stops opponents pieces from being taken when hidden behind each other\r\n                            return true;\r\n                        }\r\n                        return state.isOwner;\r\n                    }\r\n                } else {\r\n                    if (row + i * dirY === state.row && col === state.col) {\r\n                        if (i !== Math.abs(y - row)) {\r\n                            // Stops opponents pieces from being taken when hidden behind each other\r\n                            return true;\r\n                        }\r\n                        return state.isOwner;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}